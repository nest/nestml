{#
/*
*  NeuronClass.html
*
*  This file is part of NEST.
*
*  Copyright (C) 2004 The NEST Initiative
*
*  NEST is free software: you can redistribute it and/or modify
*  it under the terms of the GNU General Public License as published by
*  the Free Software Foundation, either version 2 of the License, or
*  (at your option) any later version.
*
*  NEST is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU General Public License for more details.
*
*  You should have received a copy of the GNU General Public License
*  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
*
*/
#}
/*
*  {{neuronName}}.cpp
*
*  This file is part of NEST.
*
*  Copyright (C) 2004 The NEST Initiative
*
*  NEST is free software: you can redistribute it and/or modify
*  it under the terms of the GNU General Public License as published by
*  the Free Software Foundation, either version 2 of the License, or
*  (at your option) any later version.
*
*  NEST is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU General Public License for more details.
*
*  You should have received a copy of the GNU General Public License
*  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
*
*/

// C++ includes:
#include <limits>

// Includes from libnestutil:
#include "numerics.h"

// Includes from nestkernel:
#include "exceptions.h"
#include "kernel_manager.h"
#include "universal_data_logger_impl.h"

// Includes from sli:
#include "dict.h"
#include "dictutils.h"
#include "doubledatum.h"
#include "integerdatum.h"
#include "lockptrdatum.h"

#include "{{neuronName}}.h"

{% set stateSize = len(neuron.getEquations()) %}
/* ----------------------------------------------------------------
* Recordables map
* ---------------------------------------------------------------- */
nest::RecordablesMap<{{neuronName}}> {{neuronName}}::recordablesMap_;

namespace nest
{
  // Override the create() method with one call to RecordablesMap::insert_()
  // for each quantity to be recorded.
  template <>
  void RecordablesMap<{{neuronName}}>::create()
  {
    // use standard names whereever you can for consistency!
    {% for variable in neuron.getStateSymbols() %}
      {% include "RecordCallback.html" %}
    {% endfor %}
    {% for variable in neuron.getInternalSymbols() %}
      {% include "RecordCallback.html" %}
    {% endfor %}
    {% for variable in neuron.getParameterSymbols() %}
      {% include "RecordCallback.html" %}
    {% endfor %}
    {% for odeAlias in neuron.getODEAliases() %}
      {% include "RecordCallback.html" %}
    {% endfor %}
  }

}

/* ----------------------------------------------------------------
 * Default constructors defining default parameters and state
 * Note: the implementation is empty. The initialization is of variables
 * is a part of the {{neuronName}}'s constructor.
 * ---------------------------------------------------------------- */
{{neuronName}}::Parameters_::Parameters_()
{
}

{{neuronName}}::State_::State_()
{
}

/* ----------------------------------------------------------------
* Parameter and state extractions and manipulation functions
* ---------------------------------------------------------------- */

{{neuronName}}::Buffers_::Buffers_({{neuronName}} &n): logger_(n)
{% if len(neuron.getMultipleReceptors()) > 1) %}
  , spike_inputs_( std::vector< nest::RingBuffer >( SUP_SPIKE_RECEPTOR - 1 ) )
{% endif %}
{% if useGSL %}
  , __s( 0 )
  , __c( 0 )
  , __e( 0 )
{% endif %}
{
  // Initialization of the remaining members is deferred to
  // init_buffers_().
}

{{neuronName}}::Buffers_::Buffers_(const Buffers_ &, {{neuronName}} &n): logger_(n)
{% if len(body.getMultipleReceptors()) > 1 %}
  , spike_inputs_( std::vector< nest::RingBuffer >( SUP_SPIKE_RECEPTOR - 1 ) )
{% endif %}
{% if useGSL %}
  , __s( 0 )
  , __c( 0 )
  , __e( 0 )
{% endif %}
{
  // Initialization of the remaining members is deferred to
  // init_buffers_().
}

/* ----------------------------------------------------------------
 * Default and copy constructor for node, and destructor
 * ---------------------------------------------------------------- */
{{neuronName}}::{{neuronName}}():Archiving_Node(), P_(), S_(), B_(*this)
{
  recordablesMap_.create();
  {% if useGSL %}
     // use a default `good` enough value for the absolute error.
     // it cab be adjusted via `SetStatus`
     P_.__gsl_error_tol = 1e-3;
  {% endif %}

  {% for parameter in body.getParameterNonAliasSymbols() %}
    {% include "MemberInitialization.html" %}
  {% endfor %}

  {% for state in body.getStateNonAliasSymbols() %}
    {% include "MemberInitialization.html" %}
  {% endfor %}

}

{{neuronName}}::{{neuronName}}(const {{neuronName}}& __n): Archiving_Node(), P_(__n.P_), S_(__n.S_), B_(__n.B_, *this)
{
  {% for parameter in body.getParameterNonAliasSymbols() %}
    P_.{{names.name(parameter)} = __n.P_.{{names.name(parameter)}};
  {% endfor %}

  {% for state in body.getStateNonAliasSymbols() %}
    S_.{{names.name(state)}} = __n.S_.{{names.name(state)}};
  {% endfor %}

  {% for internal in body.getInternalNonAliasSymbols() %}
    V_.{{names.name(internal)}} = __n.V_.{{names.name(internal)}};
  {% endfor %}
}

{{neuronName}}::~{{neuronName}}()
{
  {% if useGSL %}
    // GSL structs may not have been allocated, so we need to protect destruction
    if ( B_.__s )
      gsl_odeiv_step_free( B_.__s );
    if ( B_.__c )
      gsl_odeiv_control_free( B_.__c );
    if ( B_.__e )
      gsl_odeiv_evolve_free( B_.__e );
  {% endif %}
}

/* ----------------------------------------------------------------
* Node initialization functions
* ---------------------------------------------------------------- */

void
{{neuronName}}::init_state_(const Node& proto)
{
  const {{neuronName}}& pr = downcast<{{neuronName}}>(proto);
  S_ = pr.S_;
}

{% if useGSL %}
{% include "GSLDifferentiationFunction.html" %}
{% endif %}

void
{{neuronName}}::init_buffers_()
{
  {% for buffer in neuron.getInputBuffers() %}
  {{ printer.printBufferInitialization(buffer) }}
  {% endfor %}
  B_.logger_.reset(); // includes resize
  Archiving_Node::clear_history();
  {% if useGSL %}
    if ( B_.__s == 0 )
    {
      B_.__s = gsl_odeiv_step_alloc( gsl_odeiv_step_rkf45, {{stateSize}} );
    }
    else
    {
      gsl_odeiv_step_reset( B_.__s );
    }

    if ( B_.__c == 0 )
    {
      B_.__c = gsl_odeiv_control_y_new( P_.__gsl_error_tol, 0.0 );
    }
    else
    {
      gsl_odeiv_control_init( B_.__c, P_.__gsl_error_tol, 0.0, 1.0, 0.0 );
    }

    if ( B_.__e == 0 )
    {
      B_.__e = gsl_odeiv_evolve_alloc( {{stateSize}} );
    }
    else
    {
      gsl_odeiv_evolve_reset( B_.__e );
    }

    B_.__sys.function = {{neuronName}}_dynamics;
    B_.__sys.jacobian = NULL;
    B_.__sys.dimension = {{stateSize}};
    B_.__sys.params = reinterpret_cast< void* >( this );
    B_.__step = nest::Time::get_resolution().get_ms();
    B_.__integration_step = nest::Time::get_resolution().get_ms();
  {% endif %}

}

void
{{neuronName}}::calibrate()
{
  B_.logger_.init();

  {% for variable in neuron.getInternalNonAliasSymbols() %}
    {% includeArgs "Calibrate.html" %}
  {% endfor %}

  {% for variable in neuron.getStateNonAliasSymbols() %}
    {% if variable.hasVectorParameter() %}
      {% include "Calibrate.html" %}
    {% endif %}
  {% endfor %}

  {% for buffer in neuron.getInputBuffers() %}
    {% if buffer.hasVectorParameter() %}
        B_.{{buffer.getSymbolName()}.resize(P_.{{buffer.getVectorParameter()}});
        B_.{{buffer.getSymbolName()}_grid_sum_.resize(P_.{{buffer.getVectorParameter()}});
    {% endif %
  {% endfor %}
}

/* ----------------------------------------------------------------
* Update and spike handling functions
* ---------------------------------------------------------------- */

/*
 {{neuron.printDynamicsComment()}}
 */
void
{{neuronName}}::update(
        nest::Time const & origin,
        const long from, const long to)
{
  {% if useGSL %}
    double __t = 0;
  {% endif %}

  for ( long lag = from ; lag < to ; ++lag ) {
    {% for inputLine in neuron.getInputBuffers() %}
       {% if inputLine.hasVectorParameter() %}
       for (long i=0; i < P_.{{inputLine.getVectorParameter()}}; i++)
       {
         B_.{{names.bufferValue(inputLine)}}[i] = get_{{names.name(inputLine)}}()[i].get_value( lag );
       }
       {% else %}
         B_.{{names.bufferValue(inputLine)}} = get_{{names.name(inputLine)}}().get_value( lag );
       {% endif %}
    {% endfor %}

    {% set dynamics = neuron.getUpdateBlocks() %}
    {% include "Block.html" %}

    // voltage logging
    B_.logger_.record_data(origin.get_steps()+lag);
  }

}

// Do not move this function as inline to h-file. It depends on
// universal_data_logger_impl.h being included here.
void
{{neuronName}}::handle(nest::DataLoggingRequest& e)
{
  B_.logger_.handle(e);
}

{% for function in body.getFunctions() %}
{{printer.printFunctionDefinition(function, neuronName)}}
{
  {% include "Block.html" %}
}
{% endfor %}

{% if isSpikeInput %}
void
{{neuronName}}::handle(nest::SpikeEvent &e)
{
  assert(e.get_delay() > 0);

  {% if neuron.isMultisynapseSpikes() %}
    {% set spikeBuffer = neuron.getSpikeBuffers()[0] %}

    B_.{{spikeBuffer.getSymbolName()}}[e.get_rport() - 1].add_value(
      e.get_rel_delivery_steps( nest::kernel().simulation_manager.get_slice_origin() ),
      e.get_weight() * e.get_multiplicity() );
  {% elif len(neuron.getMultipleReceptors()) > 1 %}
    assert( e.get_rport() < static_cast< int >( B_.spike_inputs_.size() ) );

    B_.spike_inputs_[ e.get_rport() ].add_value(
      e.get_rel_delivery_steps( nest::kernel().simulation_manager.get_slice_origin() ),
      e.get_weight() * e.get_multiplicity() );
  {% else %}
      const double weight = e.get_weight();
      const double multiplicity = e.get_multiplicity();
      {% for buffer in neuron.getSpikeBuffers() %}
        {% if buffer.isExcitatory() %}
        if ( weight >= 0.0 ) // excitatory
        {
          get_{{buffer.getSymbolName()}}().add_value(e.get_rel_delivery_steps( nest::kernel().simulation_manager.get_slice_origin()),
                       weight * multiplicity );
        }
        {% endif %}
        {% if buffer.isInhibitory() %}
        if ( weight < 0.0 ) // inhibitory
        {
          get_{{buffer.getSymbolName()}}().add_value(e.get_rel_delivery_steps( nest::kernel().simulation_manager.get_slice_origin()),
                      {% if buffer.isConductanceBased() %} // ensure conductance is positive {% endif %}
                      {% if buffer.isConductanceBased() %} -1 * {% endif %} weight * multiplicity );
        }
        {% endif %}
      {% endfor %}

  {% endif %}
}
{% endif %}

{% if isCurrentInput %}
void
{{neuronName}}::handle(nest::CurrentEvent& e)
{
  assert(e.get_delay() > 0);

  const double current=e.get_current();
  const double weight=e.get_weight();

  // add weighted current; HEP 2002-10-04
  {% for buffer in body.getCurrentBuffers() %}
    get_{{buffer.getSymbolName()}}().add_value(
               e.get_rel_delivery_steps( nest::kernel().simulation_manager.get_slice_origin()),
               weight * current );
  {% endfor %}
}
{% endif %}