{#-
@SYNAPSE_NAME@.py.jinja2

This file is part of NEST.

Copyright (C) 2004 The NEST Initiative

NEST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

NEST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with NEST.  If not, see <http://www.gnu.org/licenses/>.
#}
{%- if tracing %}# generated by {{self._TemplateReference__context.name}} */ {% endif -%}
"""
{{synapseName}}.py

This file is part of NEST.

Copyright (C) 2004 The NEST Initiative

NEST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

NEST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with NEST.  If not, see <http://www.gnu.org/licenses/>.

Generated from NESTML at time: {{now}}
"""

from typing import Any, List, Mapping, Tuple

from .synapse import Synapse
from .vectorizable import Vectorizable


class Synapse_{{synapseName}}(Synapse):
  t_lastspike_: float = -1.

  def __init__(self, timestep: float):
    super().__init__()

    self.P_ = self.Parameters_()
    self.S_ = self.State_()
    self.V_ = self.Variables_()
    self.B_ = self.Buffers_()

{%- if parameter_syms_with_iv|length > 0 %}
    # initial values for parameters
{%- filter indent(4) %}
{%- for parameter in parameter_syms_with_iv %}
{%-   with variable = parameter %}
{%-     include "directives/MemberInitialization.jinja2" %}
{%-   endwith %}
{%- endfor %}
{%- endfilter %}
{%- endif %}

{%- if synapse.get_state_symbols()|length > 0 %}
    # initial values for state variables
{%- filter indent(4) %}
{%- for init in synapse.get_state_symbols() %}
{%-   with variable = init %}
{%-     include "directives/MemberInitialization.jinja2" %}
{%-   endwith %}
{%- endfor %}
{%- endfilter %}
{%- endif %}

    self.calibrate(timestep)

{%- if vt_ports is defined and vt_ports|length > 0  %}
  # time of last update, which is either time of last presyn. spike or time-driven update
  t_last_update_: float

  # vt_spikes_idx_ refers to the vt spike that has just been processes
  # after trigger_update_weight a pseudo vt spike at t_trig is stored at
  # index 0 and vt_spikes_idx_ = 0
  vt_spikes_idx_: float
{%- endif %}

{%- if synapse.get_parameter_symbols() | length > 0 %}

  class Parameters_:
{%- filter indent(4,True) %}
{%- for variable in synapse.get_parameter_symbols() %}
{%-   include 'directives/MemberDeclaration.jinja2' %}
{%- endfor %}
{%- endfilter %}
{%- endif %}
{%- if synapse.get_state_symbols() | length > 0 %}

  class State_(Vectorizable):
{%-   filter indent(4,True) %}
{%-   for variable in synapse.get_state_symbols() %}
{%-     include "directives/MemberDeclaration.jinja2" %}
{%-   endfor %}
{%-   endfilter %}
{%- endif %}
{%- if synapse.get_internal_symbols() | length > 0 %}

  class Variables_:
{%-   filter indent(4,True) %}
{%-     for variable in synapse.get_internal_symbols() %}
{%-       include "directives/MemberDeclaration.jinja2" %}
{%-     endfor %}
{%-   endfilter %}
{%- endif %}

  # -------------------------------------------------------------------------
  #   Constructor
  # -------------------------------------------------------------------------

  def __init__(self, timestep: float):
    super().__init__()

    self.P_ = self.Parameters_()
    self.S_ = self.State_()
    self.V_ = self.Variables_()
    self.B_ = self.Buffers_()

{%- if synapse.get_functions()|length > 0 %}

  # ---------------------------------------------------------------------------
  #   Functions defined in the NESTML model
  # ---------------------------------------------------------------------------
{% for function in synapse.get_functions() -%}
  {{printer.print_function_definition(function, synapseName)}}:
{%-   filter indent(4,True) %}
{%-   with ast = function.get_block() %}
{%-     include "directives/Block.jinja2" %}
{%-   endwith %}
{%-   endfilter %}
{%- endfor %}
{%- endif %}

  # -------------------------------------------------------------------------
  #   Getters/setters for state block
  # -------------------------------------------------------------------------
{% filter indent(2, True) -%}
{%- for state in synapse.get_state_symbols() %}
{%- if not is_delta_kernel(synapse.get_kernel_by_name(state.name)) %}
{%- with variable = state %}
{%- include "directives/MemberVariableGetterSetter.jinja2" %}
{% endwith -%}
{%- endif %}
{%- endfor %}
{%- endfilter %}

  # -------------------------------------------------------------------------
  #   Getters/setters for parameters block
  # -------------------------------------------------------------------------
{% filter indent(2, True) -%}
{%-    for parameter in synapse.get_parameter_symbols() %}
{%-        with variable = parameter %}
{%-            include "directives/MemberVariableGetterSetter.jinja2" %}
{%         endwith -%}
{%-     endfor %}
{%- endfilter %}
{%- if synapse.get_inline_expression_symbols()|length > 0 %}

  # -------------------------------------------------------------------------
  #   Getters/setters for inline expressions
  # -------------------------------------------------------------------------

{% filter indent(2, True) -%}
{%- for funcsym in synapse.get_inline_expression_symbols() %}
{%-    with variable = funcsym %}
{%-        include "directives/MemberVariableGetterSetter.jinja2" %}
{%    endwith -%}
{%- endfor %}
{%- endfilter %}
{% endif %}
{% if synapse.get_equations_block() %}

  # -------------------------------------------------------------------------
  #   Numeric + analytic solver stepping function
  # -------------------------------------------------------------------------

  def _integrate_odes(self, origin: float, timestep: float):
    r"""Integrate all ODEs defined in the model equation block by one timestep.
    """
{%- filter indent(4) %}
{%-     with analytic_state_variables_ = analytic_state_variables %}
{%-         include "directives/AnalyticIntegrationStep_begin.jinja2" %}
{%-     endwith %}
{%-     if uses_numeric_solver %}
{%-        include "directives/GSLIntegrationStep.jinja2" %}
{%-     endif %}
{%-     with analytic_state_variables_ = analytic_state_variables %}
{%-         include "directives/AnalyticIntegrationStep_end.jinja2" %}
{%-     endwith %}
{%- endfilter %}
{%- endif %}

  def step(self, origin: float, timestep: float) -> None:
    __resolution: float = timestep   # do not remove, this is necessary for the resolution() function
{% if synapse.get_update_blocks() %}
    # -------------------------------------------------------------------------
    #     NESTML generated code for the update block
    # -------------------------------------------------------------------------

{%- filter indent(4) %}
{%- set dynamics = synapse.get_update_blocks() %}
{%- with ast = dynamics.get_block() %}
{%-   include "directives/Block.jinja2" %}
{%- endwith %}
{%- endfilter %}
{%- else %}
    # no update block defined in the model; just call integrate_odes()
    self._integrate_odes(origin, timestep)
{%- endif %}


{% if synapse.get_input_blocks() and synapse.get_input_blocks().get_input_ports() | length > 0 %}
  # -------------------------------------------------------------------------
  #     Input spike handlers
  # -------------------------------------------------------------------------

  def handle(self, t_spike: float, port_names: List[str]):
    # XXX: here be @priority logic
{%- for spike_input_port in synapse.get_input_blocks().get_input_ports() %}
    if "{{spike_input_port.get_name()}}" in port_names:
      self.handle_{{spike_input_port.get_name()}}(t_spike)
{%- endfor %}

{% for on_receive_block in synapse.get_on_receive_blocks() %}
  def handle_{{on_receive_block.port_name}}(self, t_spike: float):
    if debug:
      print("{{synapseName}}::handle_{{on_receive_block.port_name}}: handling pre spike at t = " + str(t_spike))
{%- filter indent(4) %}
{%- with ast = on_receive_block.get_block() %}
{%-   include "directives/Block.jinja2" %}
{%- endwith %}
{%- endfilter %}

{% endfor %}
{%- endif %}

{%- if paired_neuron is not none and paired_neuron|length > 0 %}
  post_neuron_: Neuron

  def set_post_neuron(neuron: Neuron):
    self.post_neuron_ = neuron
{%- endif %}
