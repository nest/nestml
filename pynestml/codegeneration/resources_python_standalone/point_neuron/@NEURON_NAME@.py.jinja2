{#-
@NEURON_NAME@.py.jinja2

This file is part of NEST.

Copyright (C) 2004 The NEST Initiative

NEST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

NEST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with NEST.  If not, see <http://www.gnu.org/licenses/>.
#}
{%- import 'directives_py/FunctionDeclaration.jinja2' as function_declaration with context %}
"""
{{neuronName}}.py

This file is part of NEST.

Copyright (C) 2004 The NEST Initiative

NEST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

NEST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with NEST.  If not, see <http://www.gnu.org/licenses/>.

Generated from NESTML {{ nestml_version }} at time: {{ now }}
"""

{% if tracing %}# generated by {{self._TemplateReference__context.name}}
{% endif -%}

from typing import Any, List, Mapping, Tuple

import math
from math import *
import numpy as np
import scipy
import scipy.integrate

from .neuron import Neuron
from .utils import steps


{%- set stateSize = neuron.get_non_inline_state_symbols()|length %}

class Neuron_{{neuronName}}(Neuron):

  class Parameters_:
{%- filter indent(4, False) %}
{%- for variable_symbol in neuron.get_parameter_symbols() %}
{%-   set variable = utils.get_variable_by_name(astnode, variable_symbol.get_symbol_name()) %}
{%-   include 'directives_py/MemberDeclaration.jinja2' %}
{%- endfor %}
{%- endfilter %}

  class State_:
{%- if numeric_state_variables|length > 0 %}
    ode_state = np.nan * np.ones({{ numeric_state_variables|length }})
    ode_state_variable_name_to_index = {
{%- for var_name in numeric_state_variables %}
        "{{ var_name }}" : {{ loop.index - 1 }},
{%- endfor %}
    }

{% endif %}
{%- filter indent(4, False) %}
{%- for variable_symbol in neuron.get_state_symbols() %}
{%-   set variable = utils.get_variable_by_name(astnode, variable_symbol.get_symbol_name()) %}
{%-   include 'directives_py/MemberDeclaration.jinja2' %}
{%- endfor %}
{%- endfilter %}

  class Variables_:
{%- filter indent(4, False) %}
{%- for variable_symbol in neuron.get_internal_symbols() %}
{%-   set variable = utils.get_variable_by_name(astnode, variable_symbol.get_symbol_name()) %}
{%-   include "directives_py/MemberDeclaration.jinja2" %}
{%- endfor %}
{%- endfilter %}

  class Buffers_:
{%- if neuron.get_spike_input_ports() | length > 0 %}
    # spiking input ports
{%- endif %}
{%- for port in neuron.get_spike_input_ports() %}
{%-     if port.has_vector_parameter() %}
    {{ port.get_symbol_name() }}: List[float] = []
    spike_received_{{ port.get_symbol_name() }}: List[bool] = []
{%-     else %}
    {{ port.get_symbol_name() }}: float = 0.
    spike_received_{{ port.get_symbol_name() }}: bool = False
{%-     endif %}
{%- endfor %}

{%- if neuron.get_continuous_input_ports() | length > 0 %}
    # continuous input ports
{%- endif %}
{%- for port in neuron.get_continuous_input_ports() %}
{%-     if port.has_vector_parameter() %}
    {{ port.get_symbol_name() }}: List[float] = []
{%-     else %}
    {{ port.get_symbol_name() }}: float = 0.
{%-     endif %}
{%- endfor %}


  def __init__(self, timestep: float):
    super().__init__()

    self.P_ = self.Parameters_()
    self.S_ = self.State_()
    self.V_ = self.Variables_()
    self.B_ = self.Buffers_()

{%- if parameter_vars_with_iv|length > 0 %}
    # initial values for parameters
{%- filter indent(4) %}
{%- for variable in parameter_vars_with_iv %}
{%-   set variable_symbol = neuron.get_scope().resolve_to_symbol(variable.get_name(), SymbolKind.VARIABLE) %}
{%-   include "directives_py/MemberInitialization.jinja2" %}
{%- endfor %}
{%- endfilter %}
{%- endif %}

{%- if neuron.get_state_symbols()|length > 0 %}
    # initial values for state variables
{%- filter indent(4) %}
{%- for variable_symbol in neuron.get_state_symbols() %}
{%-   set variable = utils.get_variable_by_name(astnode, variable_symbol.get_symbol_name()) %}
{%-   include "directives_py/MemberInitialization.jinja2" %}
{%- endfor %}
{%- endfilter %}
{%- endif %}

    self._timestep = timestep
    self.recompute_internal_variables(self._timestep)

  def get_model(self) -> str:
    return "{{neuronName}}"

  def recompute_internal_variables(self, timestep: float, exclude_timestep: bool = False):
    __timestep: float = timestep  # do not remove, this is necessary for the timestep() function

    if exclude_timestep:
  {%- filter indent(6,True) %}
  {%- for variable_symbol in neuron.get_internal_symbols() %}
  {%-   set variable = utils.get_variable_by_name(astnode, variable_symbol.get_symbol_name()) %}
  {%-   if variable.name != "__h" %}
  {%-     include "directives_py/MemberInitialization.jinja2" %}
  {%-   endif %}
  {%- endfor %}
  {%- endfilter %}
      pass    # in case no variables
    else:
      # internals V_
  {%- filter indent(6) %}
  {%- for variable_symbol in neuron.get_internal_symbols() %}
  {%-   set variable = utils.get_variable_by_name(astnode, variable_symbol.get_symbol_name()) %}
  {%-   include "directives_py/MemberInitialization.jinja2" %}
  {%- endfor %}
  {%- endfilter %}
      pass    # in case no variables

{%- if neuron.get_functions()|length > 0 %}

  # ---------------------------------------------------------------------------
  #   Functions defined in the NESTML model
  # ---------------------------------------------------------------------------
{% for function in neuron.get_functions() -%}
  {{ function_declaration.FunctionDeclaration(function, neuronName) }}:
{%-   filter indent(4,True) %}
{%-   with ast = function.get_stmts_body() %}
{%-     include "directives_py/StmtsBody.jinja2" %}
{%-   endwith %}
{%-   endfilter %}
{%- endfor %}
{%- endif %}

  # -------------------------------------------------------------------------
  #   Getters/setters for state block
  # -------------------------------------------------------------------------
{% filter indent(2, True) -%}
{%- for variable_symbol in neuron.get_state_symbols() %}
{%-   if not is_delta_kernel(neuron.get_kernel_by_name(variable_symbol.get_symbol_name())) %}
{%-     set variable = utils.get_variable_by_name(astnode, variable_symbol.get_symbol_name()) %}
{%-     include "directives_py/MemberVariableGetterSetter.jinja2" %}
{%-   endif %}
{%- endfor %}
{%- endfilter %}

  # -------------------------------------------------------------------------
  #   Getters/setters for parameters block
  # -------------------------------------------------------------------------
{% filter indent(2, True) -%}
{%- for variable_symbol in neuron.get_parameter_symbols() %}
{%-   set variable = utils.get_variable_by_name(astnode, variable_symbol.get_symbol_name()) %}
{%-   include "directives_py/MemberVariableGetterSetter.jinja2" %}
{%- endfor %}
{%- endfilter %}

{% if neuron.get_equations_blocks()|length > 0 %}
  # -------------------------------------------------------------------------
  #   Numeric + analytic solver stepping function
  # -------------------------------------------------------------------------

{%- for ast in utils.get_all_integrate_odes_calls_unique(neuron) %}

{%- if uses_numeric_solver %}
{%  filter indent(2) %}
{%-     include "directives_py/GSLDifferentiationFunction.jinja2" %}
{%- endfilter %}
{%- endif %}

  def _integrate_odes{% if ast.get_args() | length > 0 %}_{{ utils.integrate_odes_args_str_from_function_call(ast) }}{% endif %}(self, origin: float, timestep: float):
    r"""Integrate {% if ast.get_args() | length > 0 %}a subset of {% endif %}ODE(s) defined in the model equation block by one timestep.
{%- if ast.get_args() | length > 0 %}

    The variables that will be integrated are: {{ ", ".join(utils.integrate_odes_args_strs_from_function_call(ast)) }}
{%- endif %}
    """
{%- filter indent(4) %}

{%-     set analytic_state_variables_ = analytic_state_variables %}
{%-     if ast.get_args() | length > 0 %}
{%-         set analytic_state_variables_ = utils.filter_variables_list(analytic_state_variables_, ast.get_args()) %}
{%-     endif %}

{#-      always integrate convolutions in time #}
{%-      for var in analytic_state_variables %}
{%-          if "__X__" in var %}
{%-              set tmp = analytic_state_variables_.append(var) %}
{%-          endif %}
{%-      endfor %}

{%-     include "directives_py/AnalyticIntegrationStep_begin.jinja2" %}

{%-     if uses_numeric_solver %}
{%-        include "directives_py/GSLIntegrationStep.jinja2" %}
{%-     endif %}

{%-     include "directives_py/AnalyticIntegrationStep_end.jinja2" %}
{%- endfilter %}
{%- endfor %}
{%- endif %}

  def step(self, origin: float, timestep: float) -> None:
    __timestep: float = timestep   # do not remove, this is necessary for the timestep() function

    # -------------------------------------------------------------------------
    #     integrate variables related to convolutions
    # -------------------------------------------------------------------------

{%- with analytic_state_variables_ = analytic_state_variables_from_convolutions %}
{%-     include "directives_py/AnalyticIntegrationStep_begin.jinja2" %}
{%- endwith %}

    # -------------------------------------------------------------------------
    #     NESTML generated code for the update block
    # -------------------------------------------------------------------------

{%  if neuron.get_update_blocks() | length > 0 %}
{%-     filter indent(4) %}
{%-         for dynamics in neuron.get_update_blocks() %}
{%-             set ast = dynamics.get_stmts_body() %}
{%-             include "directives_py/StmtsBody.jinja2" %}
{%-         endfor %}
{%-     endfilter %}
{%- endif %}

    # -------------------------------------------------------------------------
    #     integrate variables related to convolutions
    # -------------------------------------------------------------------------

{%- with analytic_state_variables_ = analytic_state_variables_from_convolutions %}
{%-     include "directives_py/AnalyticIntegrationStep_end.jinja2" %}
{%- endwith %}

    # -------------------------------------------------------------------------
    #     process spikes from buffers
    # -------------------------------------------------------------------------
{%- filter indent(4, True) -%}
{%-     include "directives_py/ApplySpikesFromBuffers.jinja2" %}
{%- endfilter %}

    # -------------------------------------------------------------------------
    #     begin NESTML generated code for the onReceive block(s)
    # -------------------------------------------------------------------------

{%  for blk in neuron.get_on_receive_blocks() %}
{%-     set inport = blk.get_port_name() %}
    if self.B_.spike_received_{{ inport }}:
      self.on_receive_block_{{ blk.get_port_name() }}()
{%- endfor %}

    # -------------------------------------------------------------------------
    #     Clear spike buffers at end of timestep
    # -------------------------------------------------------------------------

{%- for port in neuron.get_spike_input_ports() %}
    self.B_.{{port.get_symbol_name()}} = 0.
    self.B_.spike_received_{{port.get_symbol_name()}} = False
{%- endfor %}


    # -------------------------------------------------------------------------
    #     Begin NESTML generated code for the onCondition block(s)
    # -------------------------------------------------------------------------
{%- for block in neuron.get_on_condition_blocks() %}
    if {{ printer.print(block.get_cond_expr()) }}:
{%-     set ast = block.get_stmts_body() %}
{%-     if ast.print_comment('#') | length > 1 %}
# {{ast.print_comment('#')}}
{%-     endif %}
{%-     filter indent(6) %}
{%-             include "directives_py/StmtsBody.jinja2" %}
{%-     endfilter %}
{%- endfor %}


{%  if has_spike_input %}
  # -------------------------------------------------------------------------
  #   Spiking input handlers
  # -------------------------------------------------------------------------

  def handle(self, t_spike: float, w: float, port_name: str) -> None:
{%-     for port in neuron.get_spike_input_ports() %}
    if port_name == "{{port.name}}":
      self.B_.{{port.get_symbol_name()}} += abs(w)
      self.B_.spike_received_{{port.get_symbol_name()}} = True
      return
{%-     endfor %}
    raise Exception("Received a spike on unknown input port \"" + port_name + "\" at t = " + "{0:E}".format(t_spike))

  def get_spiking_input_ports(self) -> List[str]:
    return [
{%-     for port in neuron.get_spike_input_ports() %}
            "{{port.name}}",
{%-     endfor %}
    ]
{%- endif %}

  # -------------------------------------------------------------------------
  #   Methods corresponding to event handlers
  # -------------------------------------------------------------------------

{%- for blk in neuron.get_on_receive_blocks() %}
{%-     set ast = blk.get_stmts_body() %}
  def on_receive_block_{{ blk.get_port_name() }}(self):
{%-     filter indent(4, True) -%}
{%-         include "directives_py/StmtsBody.jinja2" %}
{%-     endfilter %}
{% endfor %}
