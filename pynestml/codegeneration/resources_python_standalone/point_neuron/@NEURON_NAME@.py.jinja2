{#-
@NEURON_NAME@.py.jinja2

This file is part of NEST.

Copyright (C) 2004 The NEST Initiative

NEST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

NEST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with NEST.  If not, see <http:#www.gnu.org/licenses/>.
#}
{%- import 'directives/FunctionDeclaration.jinja2' as function_declaration with context %}
"""
{{neuronName}}.py

This file is part of NEST.

Copyright (C) 2004 The NEST Initiative

NEST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

NEST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with NEST.  If not, see <http:#www.gnu.org/licenses/>.

Generated from NESTML at time: {{now}}
"""

{% if tracing %}# generated by {{self._TemplateReference__context.name}}
{% endif -%}

from typing import Any, List, Mapping, Tuple

import math
from math import *
import numpy as np
import scipy
import scipy.integrate

from .neuron import Neuron
from .utils import steps
from .vectorizable import Vectorizable

DEBUG = 1


{%- set stateSize = neuron.get_non_inline_state_symbols()|length %}

class Neuron_{{neuronName}}(Neuron):

  class Parameters_:
{%- filter indent(4,True) %}
{%- for variable_symbol in neuron.get_parameter_symbols() %}
{%-   set variable = utils.get_variable_by_name(astnode, variable_symbol.get_symbol_name()) %}
{%-   include 'directives/MemberDeclaration.jinja2' %}
{%- endfor %}
{%- endfilter %}

  class State_:
{%- if numeric_state_variables|length > 0 %}
    ode_state = np.nan * np.ones({{ numeric_state_variables|length }})
    ode_state_variable_name_to_index = {
{%- for var_name in numeric_state_variables %}
"{{ var_name }}" : {{ loop.index - 1 }},
{%- endfor %}
      }

{% endif %}
{%- filter indent(4,True) %}
{%- for variable_symbol in neuron.get_state_symbols() %}
{%-   set variable = utils.get_variable_by_name(astnode, variable_symbol.get_symbol_name()) %}
{%-   include 'directives/MemberDeclaration.jinja2' %}
{%- endfor %}
{%- endfilter %}

  class Variables_:
{%- filter indent(4,True) %}
{%- for variable_symbol in neuron.get_internal_symbols() %}
{%-   set variable = utils.get_variable_by_name(astnode, variable_symbol.get_symbol_name()) %}
{%-   include "directives/MemberDeclaration.jinja2" %}
{%- endfor %}
{%- endfilter %}

  class Buffers_:
{%- if neuron.get_spike_input_ports() | length > 0 %}
    # spiking input ports
{%- endif %}
{%- for port in neuron.get_spike_input_ports() %}
{%-     if port.has_vector_parameter() %}
    {{ port.get_symbol_name() }}: List[float] = []
{%-     else %}
    {{ port.get_symbol_name() }}: float = 0.
{%-     endif %}
{%- endfor %}

{%- if neuron.get_continuous_input_ports() | length > 0 %}
    # continuous input ports
{%- endif %}
{%- for port in neuron.get_continuous_input_ports() %}
{%-     if port.has_vector_parameter() %}
    {{ port.get_symbol_name() }}: List[float] = []
{%-     else %}
    {{ port.get_symbol_name() }}: float = 0.
{%-     endif %}
{%- endfor %}


  def __init__(self, timestep: float):
    super().__init__()

    self.P_ = self.Parameters_()
    self.S_ = self.State_()
    self.V_ = self.Variables_()
    self.B_ = self.Buffers_()

{%- if parameter_vars_with_iv|length > 0 %}
    # initial values for parameters
{%- filter indent(4) %}
{%- for variable in parameter_vars_with_iv %}
{%-   set variable_symbol = neuron.get_scope().resolve_to_symbol(variable.get_name(), SymbolKind.VARIABLE) %}
{%-   include "directives/MemberInitialization.jinja2" %}
{%- endfor %}
{%- endfilter %}
{%- endif %}

{%- if neuron.get_state_symbols()|length > 0 %}
    # initial values for state variables
{%- filter indent(4) %}
{%- for variable_symbol in neuron.get_state_symbols() %}
{%-   set variable = utils.get_variable_by_name(astnode, variable_symbol.get_symbol_name()) %}
{%-   include "directives/MemberInitialization.jinja2" %}
{%- endfor %}
{%- endfilter %}
{%- endif %}

    self.calibrate(timestep)

{%- if paired_synapse is defined %}
    # -----------------------------
    #    code for paired synapse
    # -----------------------------

    # state variables for archiving state for paired synapse
    self.n_incoming_ = 0.
    self.max_delay_ = 0.
    self.last_spike_ = -1.

    # cache initial values
{%- for var in transferred_variables %}
{%-   set variable_symbol = transferred_variables_syms[var] %}
{%-   set variable = utils.get_variable_by_name(astnode, variable_name) %}
{%-   if not var == variable_symbol.get_symbol_name() %}
    {{ raise('Error in resolving variable to symbol') }}
{%-   endif %}
    {{var}}__iv = get_{{ printer.print(variable) }}()
{%- endfor %}

    self.clear_history()
{%- endif %}

  def get_model(self) -> str:
    return "{{neuronName}}"

  def calibrate_variables(self, timestep: float, exclude_timestep: bool = False):
    __resolution: float = timestep  # do not remove, this is necessary for the resolution() function

    if exclude_timestep:
  {%- filter indent(6,True) %}
  {%- for variable_symbol in neuron.get_internal_symbols() %}
  {%-   set variable = utils.get_variable_by_name(astnode, variable_symbol.get_symbol_name()) %}
  {%-   if variable.name != "__h" %}
  {%-     include "directives/Calibrate.jinja2" %}
  {%-   endif %}
  {%- endfor %}
  {%- endfilter %}
    else:
      # internals V_
  {%- filter indent(6) %}
  {%- for variable_symbol in neuron.get_internal_symbols() %}
  {%-   set variable = utils.get_variable_by_name(astnode, variable_symbol.get_symbol_name()) %}
  {%-   include "directives/Calibrate.jinja2" %}
  {%- endfor %}
  {%- endfilter %}

  def calibrate(self, timestep: float):
    self._timestep = timestep
    self.calibrate_variables(timestep=timestep)

{%- if neuron.get_functions()|length > 0 %}

  # ---------------------------------------------------------------------------
  #   Functions defined in the NESTML model
  # ---------------------------------------------------------------------------
{% for function in neuron.get_functions() -%}
  {{ function_declaration.FunctionDeclaration(function, neuronName) }}:
{%-   filter indent(4,True) %}
{%-   with ast = function.get_block() %}
{%-     include "directives/Block.jinja2" %}
{%-   endwith %}
{%-   endfilter %}
{%- endfor %}
{%- endif %}

  # -------------------------------------------------------------------------
  #   Getters/setters for state block
  # -------------------------------------------------------------------------
{% filter indent(2, True) -%}
{%- for variable_symbol in neuron.get_state_symbols() %}
{%-   if not is_delta_kernel(neuron.get_kernel_by_name(variable_symbol.get_symbol_name())) %}
{%-     set variable = utils.get_variable_by_name(astnode, variable_symbol.get_symbol_name()) %}
{%-     include "directives/MemberVariableGetterSetter.jinja2" %}
{%-   endif %}
{%- endfor %}
{%- endfilter %}

  # -------------------------------------------------------------------------
  #   Getters/setters for parameters block
  # -------------------------------------------------------------------------
{% filter indent(2, True) -%}
{%- for variable_symbol in neuron.get_parameter_symbols() %}
{%-   set variable = utils.get_variable_by_name(astnode, variable_symbol.get_symbol_name()) %}
{%-   include "directives/MemberVariableGetterSetter.jinja2" %}
{%- endfor %}
{%- endfilter %}

{%- if uses_numeric_solver %}
  # -------------------------------------------------------------------------
  #   Numeric solver stepping function
  # -------------------------------------------------------------------------

{% filter indent(2) %}
{%- include "directives/GSLDifferentiationFunction.jinja2" %}
{%- endfilter %}
{%- endif %}

{% if neuron.get_equations_blocks()|length > 0 %}
  # -------------------------------------------------------------------------
  #   Numeric + analytic solver stepping function
  # -------------------------------------------------------------------------

  def _integrate_odes(self, origin: float, timestep: float):
    r"""Integrate all ODEs defined in the model equation block by one timestep.
    """
{%- filter indent(4) %}
{%-     with analytic_state_variables_ = analytic_state_variables %}
{%-         include "directives/AnalyticIntegrationStep_begin.jinja2" %}
{%-     endwith %}
{%-     if uses_numeric_solver %}
{%-        include "directives/GSLIntegrationStep.jinja2" %}
{%-     endif %}
{%-     with analytic_state_variables_ = analytic_state_variables %}
{%-         include "directives/AnalyticIntegrationStep_end.jinja2" %}
{%-     endwith %}
{%- endfilter %}
{%- endif %}

  def step(self, origin: float, timestep: float) -> None:
    __resolution: float = timestep   # do not remove, this is necessary for the resolution() function

    # -------------------------------------------------------------------------
    #     NESTML generated code for the update block
    # -------------------------------------------------------------------------

{% if neuron.get_update_blocks()|length > 0 %}
{%- filter indent(4) %}
{%- for dynamics in neuron.get_update_blocks() %}
{%-   set ast = dynamics.get_block() %}
{%-   include "directives/Block.jinja2" %}
{%- endfor %}
{%- endfilter %}
{%- endif %}

    # -------------------------------------------------------------------------
    #     Clear spike buffers at end of timestep
    # -------------------------------------------------------------------------

{%- for port in neuron.get_spike_input_ports() %}
    self.B_.{{port.get_symbol_name()}} = 0.
{%- endfor %}


{% if has_spike_input %}
  # -------------------------------------------------------------------------
  #   Spiking input handlers
  # -------------------------------------------------------------------------

  def handle(self, t_spike: float, w: float, port_name: str) -> None:
{%-   for port in neuron.get_spike_input_ports() %}
    if port_name == "{{port.name}}":
      self.B_.{{port.get_symbol_name()}} += abs(w)
      return
{%-   endfor %}
{%- endif %}
    raise Exception("Received a spike on unknown input port \"" + port_name + "\" at t = " + "{0:E}".format(t_spike))

  def get_spiking_input_ports(self) -> List[str]:
    return [
{%- for port in neuron.get_spike_input_ports() %}
            "{{port.name}}",
{%- endfor %}
    ]

{%- if paired_synapse is defined %}
  # -------------------------------------------------------------------------
  #   Synapse co-generation
  # -------------------------------------------------------------------------
  def get_spiketime_ms(self):
    return self.last_spike_

  def register_stdp_connection(self, t_first_read: float, delay: float):
    # Mark all entries in the deque, which we will not read in future as read by
    # this input input, so that we safely increment the incoming number of
    # connections afterwards without leaving spikes in the history.
    # For details see bug #218. MH 08-04-22

    for i, hist_entry in self.history_:
      #if ( t_first_read - hist_entry.t_ > -1.0 * nest::kernel().connection_manager.get_stdp_eps():
      if t_first_read - hist_entry.t_ > -1E-6:
        break
      hist_entry.access_counter_ += 1

    self.n_incoming_ += 1
    self.max_delay_ = max(delay, self.max_delay_)

  def get_history__(t1: float, t2: float):
    if len(history_) == 0:
      return

    t2_lim: float = t2 + 1E-6
    t1_lim: float = t1 + 1E-6

    histentry_times = [histentry.t_ for histentry in self.history_]

    for start_idx, histentry in enumerate(self.history_):
      if histentry.t_ < t2_lim:
        break

    for end_idx, histentry in enumerate(self.history_):
      histentry.access_counter_ += 1
      if histentry.t_ < t1_lim:
        break

    return self.history_[start_idx:end_idx]
{#
  def set_spiketime(t_sp: float, offset: float):
    num_transferred_variables: int = 0
{%- for var in transferred_variables %}
    num_transferred_variables += 1
{%- endfor %}

    t_sp_ms = t_sp - offset

    if n_incoming_:
        # prune all spikes from history which are no longer needed
        # only remove a spike if:
        # - its access counter indicates it has been read out by all connected
        #     STDP synapses, and
        # - there is another, later spike, that is strictly more than
        #     (max_delay_ + eps) away from the new spike (at t_sp_ms)
        while len(self.history_) > 1:
            next_t_sp: float = self.history_[0].t_
            if ( self.history_[0].access_counter_ >= n_incoming_ * num_transferred_variables
                and t_sp_ms - next_t_sp > max_delay_ + 1E-6 ):
                # remove the first element
                self.history_ = self.history_[1:]
            else:
                break

        if len(self.history_) > 0:
          assert self.history_[-1].t_ == last_spike_

{%- for var in purely_numeric_state_variables_moved|sort %}
          self.S_.{{printer.print(neuron.get_scope().resolve_to_symbol(var, SymbolKind.VARIABLE))}} = self.history_[-1].{{var}}_
{%- endfor %}
{%- for var in analytic_state_variables_moved|sort %}
          self.S_.{{printer.print(neuron.get_scope().resolve_to_symbol(var, SymbolKind.VARIABLE))}} = self.history_[-1].{{var}}_;
{%- endfor %}
        }
        else {
{%- for var in purely_numeric_state_variables_moved|sort %}
          self.S_.{{printer.print(neuron.get_scope().resolve_to_symbol(var, SymbolKind.VARIABLE))}} = 0.  # initial value for convolution is always 0
{%- endfor %}
{%- for var in analytic_state_variables_moved|sort %}
          self.S_.{{printer.print(neuron.get_scope().resolve_to_symbol(var, SymbolKind.VARIABLE))}} = 0.  # initial value for convolution is always 0
{%- endfor %}

        # update state variables transferred from synapse from `last_spike_` to `t_sp_ms`

        float old___h = self.V_.__h
        self.V_.__h = t_sp_ms - last_spike_
        if self.V_.__h > 1E-12:
          self.calibrate_variables(true)

#  Generates a series of C++ statements which perform one integration step of all ODEs that are solved by the analytic integrator.

{%- filter indent(6, True) %}
{%- with analytic_state_variables_ = analytic_state_variables_moved|sort %}
{%-     include "directives/AnalyticIntegrationStep_begin.jinja2" %}
{%- endwith %}

{%- if uses_numeric_solver %}
# update only synapse->neuron moved variables; back-up and restore the rest
ode_state_bak = {}

{%-   for variable_name in numeric_state_variables %}
ode_state_bak[S_.ode_state_variable_name_to_index["{{variable_name}}"]] = S_.ode_state[S_.ode_state_variable_name_to_index["{{variable_name}}"]]
{%-     endfor %}

{%- if uses_numeric_solver %}
{%-     include "directives/GSLIntegrationStep.jinja2" %}
{%- endif %}

# restore non-synapse->neuron-moved variables
{%-   for variable_name in numeric_state_variables %}
S_.ode_state[S_.ode_state_variable_name_to_index["{{variable_name}}"]] = ode_state_bak[S_.ode_state_variable_name_to_index["{{variable_name}}"]];
{%-     endfor %}

# restore variables solved analytically
{%-   for variable_name in numeric_state_variables %}
S_.ode_state[S_.ode_state_variable_name_to_index["{{variable_name}}"]] = ode_state_bak[S_.ode_state_variable_name_to_index["{{variable_name}}"]];
{%-     endfor %}

{%- endif %}

{%- with analytic_state_variables_ = analytic_state_variables_moved|sort %}
{%-     include "directives/AnalyticIntegrationStep_end.jinja2" %}
{%- endwith %}

{%- endfilter %}
        self.V_.__h = old___h
        self.calibrate_variables(true)

        #
        #    apply spike updates
        #

{%- for stmt in spike_update_stmts %}
{%- if uses_numeric_solver %}
        {{printer.print_node(stmt)}};
{%- else %}
        {{nest_printer.print_node(stmt)}};
{%- endif %}
{%- endfor %}

{%- for _, spike_update in post_spike_updates.items() %}
        S_.{{ printer.print(neuron.get_scope().resolve_to_symbol(spike_update.get_variable().get_complete_name(), SymbolKind.VARIABLE))}} += 1.;
{%- endfor %}

    last_spike_ = t_sp_ms;
    history_.push_back( histentry__{{neuronName}}( last_spike_
{%- for var in purely_numeric_state_variables_moved|sort %}
    , get_{{var}}()
{%- endfor %}
{%- for var in analytic_state_variables_moved|sort %}
    , get_{{var}}()
{%- endfor %}
, 0
 ) );
  }
  else
  {
    last_spike_ = t_sp_ms;
  }
}


  def clear_history():
    self.last_spike_ = -1.0;
    self.history_ = []


#	generate getter functions for the transferred variables


{%- for var in transferred_variables %}
{%- with variable_symbol = transferred_variables_syms[var] %}

{%- if not var == variable_symbol.get_symbol_name() %}
{{ raise('Error in resolving variable to symbol') }}
{%- endif %}

double
{{neuronName}}::get_{{var}}( double t, const bool before_increment )
{
#ifdef DEBUG
  std::cout << "{{neuronName}}::get_{{var}}: getting value at t = " << t << std::endl;
#endif

  # case when the neuron has not yet spiked
  if ( history_.empty() )
  {
#ifdef DEBUG
    std::cout << "{{neuronName}}::get_{{var}}: \thistory empty, returning initial value = " << {{var}}__iv << std::endl;
#endif
    # return initial value
    return {{var}}__iv;
  }

  # search for the latest post spike in the history buffer that came strictly before `t`
  int i = history_.size() - 1;
  double eps = 0.;
  if ( before_increment ) {
   eps = nest::kernel().connection_manager.get_stdp_eps();
  }
  while ( i >= 0 )
  {
    if ( t - history_[ i ].t_ >= eps )
    {
#ifdef DEBUG
      std::cout<<"{{neuronName}}::get_{{var}}: \tspike occurred at history[i].t_ = " << history_[i].t_ << std::endl;
#endif

{%- for var_ in purely_numeric_state_variables_moved %}
      S_.{{printer.print(neuron.get_scope().resolve_to_symbol(var_, SymbolKind.VARIABLE))}} = history_[ i ].{{var_}}_;
{%- endfor %}
{%- for var_ in analytic_state_variables_moved %}
      S_.{{printer.print(neuron.get_scope().resolve_to_symbol(var_, SymbolKind.VARIABLE))}} = history_[ i ].{{var_}}_;
{%- endfor %}

      /**
       * update state variables transferred from synapse from `history[i].t_` to `t`
      **/

      if ( t - history_[ i ].t_ >= nest::kernel().connection_manager.get_stdp_eps() )
      {
        const double old___h = V_.__h;
        V_.__h = t - history_[i].t_;
        assert(V_.__h > 0);
        calibrate_variables(true);

#  Generates a series of C++ statements which perform one integration step of all ODEs that are solved by the analytic integrator.


{%- filter indent(6, True) %}
{%- with analytic_state_variables_ = analytic_state_variables_moved|sort %}
{%-     include "directives/AnalyticIntegrationStep_begin.jinja2" %}
{%- endwith %}

{%- if purely_numeric_state_variables_moved|length > 0 %}
double ode_state_tmp[STATE_VEC_SIZE];

for (int i = 0; i < STATE_VEC_SIZE; ++i) {
  ode_state_tmp[i] = S_.ode_state[i];
}

{%- if uses_numeric_solver %}
{%-     include "directives/GSLIntegrationStep.jinja2" %}
{%- endif %}

{%- for variable_name in numeric_state_variables_moved|sort %}
{%- if not variable_name in analytic_state_variables_moved %}
S_.ode_state[S_.ode_state_variable_name_to_index["{{variable_name}}"]] = ode_state_tmp[S_.ode_state_variable_name_to_index["{{variable_name}}"]];
{%- endif %}
{%- endfor %}
{%- endif %}

{%- with analytic_state_variables_ = analytic_state_variables_moved|sort %}
{%-     include "directives/AnalyticIntegrationStep_end.jinja2" %}
{%- endwith %}
{%- endfilter %}

        V_.__h = old___h;
        calibrate_variables(true);
      }

#ifdef DEBUG
      std::cout << "{{neuronName}}::get_{{var}}: \treturning " << {{ printer.print(variable) }}() << std::endl;
#endif
      return get_{{ printer.print(variable) }}();       # type: {{ declarations.print_variable_type(variable_symbol) }}
    }
    --i;
  }

  # this case occurs when the trace was requested at a time precisely at that of the first spike in the history
  if ( (!before_increment) && t == history_[ 0 ].t_)
  {
{%- for var_ in purely_numeric_state_variables_moved %}
    S_.{{ printer.print(neuron.get_scope().resolve_to_symbol(var_, SymbolKind.VARIABLE))}} = history_[ 0 ].{{var_}}_;
{%- endfor %}
{%- for var_ in analytic_state_variables_moved %}
    S_.{{ printer.print(neuron.get_scope().resolve_to_symbol(var_, SymbolKind.VARIABLE))}} = history_[ 0 ].{{var_}}_;
{%- endfor %}

#ifdef DEBUG
    std::cout << "{{neuronName}}::get_{{var}}: \ttrace requested at exact time of history entry 0, returning " << get_{{ printer.print(variable) }}() << std::endl;
#endif
    return get_{{ printer.print(variable) }}();
  }

  # this case occurs when the trace was requested at a time before the first spike in the history
  # return initial value propagated in time
#ifdef DEBUG
  std::cout << "{{neuronName}}::get_{{var}}: \tfall-through, returning initial value = " << {{var}}__iv << std::endl;
#endif

  if (t == 0.) {
    return 0.;  # initial value for convolution is always 0
  }

  # set to initial value
{%- for var_ in purely_numeric_state_variables_moved %}
  S_.{{ printer.print(var_) }} = 0.;  # initial value for convolution is always 0
{%- endfor %}
{%- for var_ in analytic_state_variables_moved %}
  S_.{{ printer.print(var_) }} = 0.;  # initial value for convolution is always 0
{%- endfor %}

  # propagate in time
  const double old___h = V_.__h;
  V_.__h = t;   # from time 0 to the requested time
  assert(V_.__h > 0);
  calibrate_variables(true);

  # Generates a series of C++ statements which perform one integration step of all ODEs that are solved by the analytic integrator.
{%- filter indent(2, True) %}
{%- with analytic_state_variables_ = analytic_state_variables_moved|sort %}
{%-     include "directives/AnalyticIntegrationStep_begin.jinja2" %}
{%- endwith %}

{%- if purely_numeric_state_variables_moved|length > 0 %}
double ode_state_tmp[STATE_VEC_SIZE];

for (int i = 0; i < STATE_VEC_SIZE; ++i) {
    ode_state_tmp[i] = S_.ode_state[i];
}

{%- if uses_numeric_solver %}
{%-     include "directives/GSLIntegrationStep.jinja2" %}
{%- endif %}

{%- for variable_name in numeric_state_variables_moved|sort %}
{%- if not variable_name in analytic_state_variables_moved %}
  S_.ode_state[S_.ode_state_variable_name_to_index["{{variable_name}}"]] = ode_state_tmp[S_.ode_state_variable_name_to_index["{{variable_name}}"]];
{%- endif %}
{%- endfor %}
{%- endif %}

{%- with analytic_state_variables_ = analytic_state_variables_moved|sort %}
{%-     include "directives/AnalyticIntegrationStep_end.jinja2" %}
{%- endwith %}

{%- endfilter %}
  V_.__h = old___h;
  calibrate_variables(true);
{%-   set variable = utils.get_variable_by_name(astnode, variable_symbol.get_symbol_name()) %}
  return get_{{ printer.print(variable) }}();
}
{%- endwith -%}
{%- endfor %}
#}

{%- endif %}