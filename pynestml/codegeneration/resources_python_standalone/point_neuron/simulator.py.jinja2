{#-
simulator.py.jinja2

This file is part of NEST.

Copyright (C) 2004 The NEST Initiative

NEST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

NEST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with NEST.  If not, see <http://www.gnu.org/licenses/>.
#}
{%- if tracing %}# generated by {{self._TemplateReference__context.name}}{% endif -%}
"""
simulator.py

This file is part of NEST.

Copyright (C) 2004 The NEST Initiative

NEST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

NEST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with NEST.  If not, see <http://www.gnu.org/licenses/>.

Generated from NESTML at time: {{now}}
"""

from typing import List, Mapping, Optional, Union

import numpy as np

from .neuron import Neuron


class Simulator:
    r"""
    A very simple neural network simulator that allows a network to be instantiated and performs time stepping.

    Note that multiple connections between neurons are not supported.
    """
    neurons: List[Neuron] = []
    connections: Mapping[Neuron, List[Neuron]] = {}       # map from id(source) to list of id(target)
    connection_weights: Mapping[int, Mapping[int, float]] = {}
    connection_ports: Mapping[int, Mapping[int, str]] = {}
    log: Mapping[str, Mapping[str, List]] = {}              # map from id to (map from variable name to list of values over time)
    timestep: float = .1      # should stay constant (static variable), don't change at runtime!

    def __init__(self):
        self._t = 0.       # time [ms]
        self.neurons = []
        self.connections = {}
        self.connection_weights = {}
        self.connection_ports = {}
        self.log = {}

    def log_step(self):
        if not "t" in self.log.keys():
            self.log["t"] = []

        self.log["t"].append(self._t)

        for neuron in self.neurons:
            if not neuron.gid in self.log.keys():
                self.log[neuron.gid] = {}  # map from variable names to list of values

            if hasattr(neuron, "S_"):
                for var_name, value in neuron.S_.__dict__.items():
                    if var_name in ["ode_state", "ode_state_variable_name_to_index"]:
                        continue

                    if not var_name in self.log[neuron.gid].keys():
                        self.log[neuron.gid][var_name] = []

                    self.log[neuron.gid][var_name].append(value)

                if hasattr(neuron.S_, "ode_state"):
                    for var_name, idx in neuron.S_.ode_state_variable_name_to_index.items():
                        if not var_name in self.log[neuron.gid].keys():
                            self.log[neuron.gid][var_name] = []

                        value = neuron.S_.ode_state[idx]
                        self.log[neuron.gid][var_name].append(value)

    def step(self, timestep: float):
        for neuron in self.neurons:
            neuron.step(origin=self._t,
                        timestep=timestep)
        self._t += self.timestep

        self.log_step()

    def add_neuron(self, neuron: Neuron) -> int:
        r"""Add neuron instance to the simulator. Return a globally unique neuron ID for this instance."""
        self.neurons.append(neuron)
        gid: int = len(self.neurons) - 1
        neuron.gid = gid
        return gid

    def connect(self, source: int, target: int, port: str, w: float = 1.) -> None:
        r"""Connect a source and target neuron, passed as instances"""
        if not source in self.connections.keys():
            self.connections[source]: List[int] = []   # list of id_target

        if not source in self.connection_weights.keys():
            self.connection_weights[source] = {}
            self.connection_ports[source] = {}

        self.connection_weights[source][target] = w
        self.connection_ports[source][target] = port
        self.connections[source].append(target)
        if not port in self.neurons[target].get_spiking_input_ports():
            raise Exception("Tried to connect to unknown input port \"" + port_name + "\" on neuron type \"" + self.neurons[target].get_model() + "\"")

    def handle(self, source: Neuron) -> None:
        r"""Handle incoming spike"""
        self._incoming_spike_buffer.append(source)

    def deliver_spikes(self) -> None:
        r"""Deliver spikes in the queue"""
        for source_id in range(len(self.neurons)):
            if source_id not in self.connections.keys():
                # neuron is not connected to anything
                continue

            source = self.neurons[source_id]
            for t_spike in source.pop_emitted_spikes():
                for target_id in self.connections[source_id]:
                    w = self.connection_weights[source_id][target_id]
                    self.neurons[target_id].handle(t_spike, w, self.connection_ports[source_id][target_id])

        self._incoming_spike_buffer = []

    def run(self, t_stop: float):
        r"""Run the simulation.

        Parameters
        ----------
        t_stop
            Stopping time in milliseconds.
        """
        self._t = 0.
        while self._t < t_stop:
            self.step(self.timestep)
            self.deliver_spikes()
            self._t += self.timestep

    def get_log(self):
        return self._log
