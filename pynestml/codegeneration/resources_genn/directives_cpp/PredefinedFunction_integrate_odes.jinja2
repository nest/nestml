{#
  Generates code for integrate_odes() function call
  @param ast ASTFunctionCall
#}
{%- if tracing %}/* generated by {{self._TemplateReference__context.name}} */ {% endif %}
// start rendered code for integrate_odes({{ ", ".join(utils.integrate_odes_args_strs_from_function_call(ast)) }})

{%- if uses_analytic_solver %}
{%-     set analytic_state_variables_ = analytic_state_variables.copy() %}

{%-     if paired_synapse is defined %}
{%-         set tmp = analytic_state_variables_.extend(analytic_state_variables_moved) %}
{%-     endif %}

{%-     if ast.get_args() | length > 0 %}
{%-         set analytic_state_variables_ = utils.filter_variables_list(analytic_state_variables_, ast.get_args()) %}
{%-     endif %}

{%-     if analytic_state_variables_ | length > 0 %}
// analytic solver: integrating state variables (first step): {% for variable_name in analytic_state_variables_ %}{{ variable_name }}{% if not loop.last %}, {% endif %}{% endfor %}
{%-         include "directives_cpp/AnalyticIntegrationStep_begin.jinja2" %}
{%-     endif %}
{%- endif %}

{%- if uses_numeric_solver %}
{%-     set numeric_state_variables_to_be_integrated = numeric_state_variables + purely_numeric_state_variables_moved %}
{%-     if ast.get_args() | length > 0 %}
{%-         set numeric_state_variables_to_be_integrated = utils.filter_variables_list(numeric_state_variables_to_be_integrated, ast.get_args()) %}
{%-     endif %}
{%-     if numeric_state_variables_to_be_integrated | length > 0 %}
// numeric solver: integrating state variables: {% for variable_name in numeric_state_variables_to_be_integrated %}{{ variable_name }}{% if not loop.last %}, {% endif %}{% endfor %}

{%-         if analytic_state_variables_from_convolutions | length > 0 %}
// solver step should update state of convolutions internally, but not change ode_state[] pertaining to convolutions; convolution integration should be independent of integrate_odes() calls
// buffer the old values
{%-             for variable_name in analytic_state_variables_from_convolutions %}
{%-                 set update_expr = update_expressions[variable_name] %}
{%-                 set variable_symbol = variable_symbols[variable_name] %}
const double {{ variable_name }}__orig = {{ printer.print(utils.get_state_variable_by_name(astnode, variable_symbol.get_symbol_name())) }};
{%-             endfor %}

{%          endif %}
{%- for eq_block in neuron.get_equations_blocks() %}
{%-     for ode in eq_block.get_declarations() %}
{%-         for inline_expr in utils.get_inline_expression_symbols(ode) %}
{%-             if not inline_expr.is_equation() %}
{%-                 set declaring_expr = inline_expr.get_declaring_expression() %}
double {{ printer.print(utils.get_state_variable_by_name(astnode, inline_expr)) }} = {{ gsl_printer.print(declaring_expr) }};
{%-             endif %}
{%-         endfor %}
{%-     endfor %}
{%- endfor %}

{%      set numeric_state_variables_to_be_integrated = numeric_state_variables + purely_numeric_state_variables_moved %}
{%-     if ast.get_args() | length > 0 %}
{%-         set numeric_state_variables_to_be_integrated = utils.filter_variables_list(numeric_state_variables_to_be_integrated, ast.get_args()) %}
{%-     endif %}
{%- for variable_name in numeric_state_variables + numeric_state_variables_moved %}
{%-   set update_expr = numeric_update_expressions[variable_name] %}
{%-   set variable_symbol = variable_symbols[variable_name] %}
const scalar f_{{ variable_symbol.get_symbol_name() }} = {% if ast.get_args() | length > 0 %}{% if variable_name in numeric_state_variables_to_be_integrated + utils.all_convolution_variable_names(astnode) %}{{ gsl_printer.print(update_expr) }}{% else %}0{% endif %}{% else %}{{ gsl_printer.print(update_expr) }}{% endif %};
{%- endfor %}

{%- for variable_name in numeric_state_variables + numeric_state_variables_moved %}
{%-   set update_expr = numeric_update_expressions[variable_name] %}
{%-   set variable_symbol = variable_symbols[variable_name] %}
{{ variable_name }} += {% if ast.get_args() | length > 0 %}{% if variable_name in numeric_state_variables_to_be_integrated + utils.all_convolution_variable_names(astnode) %}dt * f_{{ variable_symbol.get_symbol_name() }}{% else %}0{% endif %}{% else %}dt * f_{{ variable_symbol.get_symbol_name() }}{% endif %};
{%- endfor %}

{%-         if analytic_state_variables_from_convolutions | length > 0 %}
// restore the old values for convolutions
{%-             for variable_name in analytic_state_variables_from_convolutions %}
{%-                 set variable_symbol = variable_symbols[variable_name] %}
{{ printer.print(utils.get_state_variable_by_name(astnode, variable_symbol.get_symbol_name())) }} = {{ variable_name }}__orig;
{%-             endfor %}
{%          endif %}

{%-     endif %}
{%- endif %}

{%- if uses_analytic_solver %}
{%- if analytic_state_variables_ | length > 0 %}
// analytic solver: integrating state variables (second step): {% for variable_name in analytic_state_variables_ %}{{ variable_name }}{% if not loop.last %}, {% endif %}{% endfor %}

{%-     include "directives_cpp/AnalyticIntegrationStep_end.jinja2" %}
{%- endif %}
{%- endif %}
