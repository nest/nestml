{#-
cm_compartmentcurrents_@NEURON_NAME@.cpp.jinja2

This file is part of NEST.

Copyright (C) 2004 The NEST Initiative

NEST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

NEST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with NEST.  If not, see <http://www.gnu.org/licenses/>.
#}
{%- if tracing %}/* generated by {{self._TemplateReference__context.name}} */ {% endif %}
{%- import 'directives_cpp/FunctionDeclaration.jinja2' as function_declaration with context %}
#include "{{neuronSpecificFileNamesCmSyns["compartmentcurrents"]}}.h"

{%- set current_conductance_name_prefix = "g" %}
{%- set current_equilibrium_name_prefix = "e" %}
{% macro render_dynamic_channel_variable_name(variable_type, ion_channel_name) %}
    {%- if variable_type == "gbar" %}
        {{ current_conductance_name_prefix~"_"~ion_channel_name }}
    {%- elif variable_type == "e" %}
        {{ current_equilibrium_name_prefix~"_"~ion_channel_name }}
    {%- endif %}
{%- endmacro %}

{%- macro render_state_variable_name(pure_variable_name, ion_channel_name) %}
    {{ pure_variable_name~"_"~ion_channel_name }}
{%- endmacro %}

{% macro render_time_resolution_variable(synapse_info) %}
{# we assume here that there is only one such variable ! #}
{%- for analytic_helper_name, analytic_helper_info in synapse_info["analytic_helpers"].items() %}
{%- if analytic_helper_info["is_time_resolution"] %}
    {{ analytic_helper_name }}
{%- endif %}
{%- endfor %}
{%- endmacro %}

{% macro render_function_return_type(function) %}
{%- with %}
    {%- set symbol = function.get_scope().resolve_to_symbol(function.get_name(), SymbolKind.FUNCTION) %}
    {{ types_printer.print(symbol.get_return_type()) }}
{%- endwith %}
{%- endmacro %}

{% macro render_inline_expression_type(inline_expression) %}
{%- with %}
    {%- set symbol = inline_expression.get_scope().resolve_to_symbol(inline_expression.variable_name, SymbolKind.VARIABLE) %}
    {{ types_printer.print(symbol.get_type_symbol()) }}
{%- endwith %}
{%- endmacro %}

{% macro render_static_channel_variable_name(variable_type, ion_channel_name) %}

{%- for ion_channel_nm, channel_info in chan_info.items() %}
    {%- if ion_channel_nm == ion_channel_name %}
        {%- for variable_tp, variable_info in channel_info["channel_parameters"].items() %}
            {%- if variable_tp == variable_type %}
                {%- set variable = variable_info["parameter_block_variable"] %}
                {{ variable.name }}
            {%- endif %}
        {%- endfor %}
    {%- endif %}
{%- endfor %}

{%- endmacro %}

{% macro render_channel_function(function, ion_channel_name) %}
{{ function_declaration.FunctionDeclaration(function, "nest::"~ion_channel_name~cm_unique_suffix~"::") }}
{
{%-   filter indent(2,True) %}
{%-   with ast = function.get_block() %}
{%-     include "directives_cpp/Block.jinja2" %}
{%-   endwith %}
{%-   endfilter %}
}
{%- endmacro %}


{%- for ion_channel_name, channel_info in chan_info.items() %}

// {{ion_channel_name}} channel //////////////////////////////////////////////////////////////////
nest::{{ion_channel_name}}{{cm_unique_suffix}}::{{ion_channel_name}}{{cm_unique_suffix}}()

{%- for pure_variable_name, variable_info in channel_info["States"].items() %}
// state variable {{pure_variable_name -}}
{%- set variable = variable_info["ASTVariable"] %}
{%- set rhs_expression = variable_info["rhs_expression"] %}
{% if loop.first %}: {% else %}, {% endif %}
{{- variable.name}}({{ printer_no_origin.print(rhs_expression) -}})
{%- endfor %}

{% for variable_type, variable_info in channel_info["Parameters"].items() %}
// channel parameter {{variable_type -}}
{%- set variable = variable_info["ASTVariable"] %}
{%- set rhs_expression = variable_info["rhs_expression"] %}
,{{- variable.name }}({{ printer_no_origin.print(rhs_expression) -}})
{%- endfor %}
{}

nest::{{ion_channel_name}}{{cm_unique_suffix}}::{{ion_channel_name}}{{cm_unique_suffix}}(const DictionaryDatum& channel_params)

{%- for pure_variable_name, variable_info in channel_info["States"].items() %}
// state variable {{pure_variable_name -}}
{%- set variable = variable_info["ASTVariable"] %}
{%- set rhs_expression = variable_info["rhs_expression"] %}
{% if loop.first %}: {% else %}, {% endif %}
{{- variable.name}}({{ printer_no_origin.print(rhs_expression) -}})
{%- endfor %}

{% for variable_type, variable_info in channel_info["Parameters"].items() %}
// channel parameter {{variable_type -}}
{%- set variable = variable_info["ASTVariable"] %}
{%- set rhs_expression = variable_info["rhs_expression"] %}
,{{- variable.name }}({{ printer_no_origin.print(rhs_expression) -}})
{%- endfor %}
// update {{ion_channel_name}} channel parameters
{
    {%- for variable_type, variable_info in channel_info["Parameters"].items() %}
        {%- set variable = variable_info["ASTVariable"] %}
        {%- set dynamic_variable = render_dynamic_channel_variable_name(variable_type, ion_channel_name) %} //have to remove???????????
    // {{ion_channel_name}} channel parameter {{dynamic_variable }}
    if( channel_params->known( "{{variable.name}}" ) )
        {{variable.name}} = getValue< double >( channel_params, "{{variable.name}}" );
    {%- endfor %}
}

void
nest::{{ion_channel_name}}{{cm_unique_suffix}}::append_recordables(std::map< Name, double* >* recordables,
                                               const long compartment_idx)
{
  // add state variables to recordables map
  {%- for pure_variable_name, variable_info in channel_info["States"].items() %}
  {%- set variable = variable_info["ASTVariable"] %}
  ( *recordables )[ Name( "{{variable.name}}" + std::to_string(compartment_idx) )] = &{{variable.name}};
  {%- endfor %}
    ( *recordables )[ Name( "i_tot_{{ion_channel_name}}" + std::to_string(compartment_idx) )] = &i_tot_{{ion_channel_name}};
}

std::pair< double, double > nest::{{ion_channel_name}}{{cm_unique_suffix}}::f_numstep(const double v_comp{% for ode in channel_info["Dependencies"]["concentrations"] %}, double {{ode.lhs.name}}{% endfor %}
                        {% for inline in channel_info["Dependencies"]["receptors"] %}, double {{inline.variable_name}}{% endfor %}
                        {% for inline in channel_info["Dependencies"]["channels"] %}, double {{inline.variable_name}}{% endfor %})
{
    double g_val = 0., i_val = 0.;

    if({%- for key_zero_param in channel_info["RootInlineKeyZeros"] %} {{ key_zero_param }} > 1e-9 && {%- endfor %} true ){
        {% if channel_info["ODEs"].items()|length %} double {{ printer_no_origin.print(channel_info["time_resolution_var"]) }} = Time::get_resolution().get_ms(); {% endif %}

        {%- for ode_variable, ode_info in channel_info["ODEs"].items() %}
            {%- for propagator, propagator_info in ode_info["transformed_solutions"][0]["propagators"].items() %}
        double {{ propagator }} = {{ printer_no_origin.print(propagator_info["init_expression"]) }};
            {%- endfor %}
            {%- for state, state_solution_info in ode_info["transformed_solutions"][0]["states"].items() %}
        {{state}} = {{ printer_no_origin.print(state_solution_info["update_expression"]) }};
            {%- endfor %}
        {%- endfor %}

        {%- set inline_expression = channel_info["root_expression"] %}
        {%- set inline_expression_d = channel_info["inline_derivative"] %}
        // compute the conductance of the {{ion_channel_name}} channel
        this->i_tot_{{ion_channel_name}} = {{ printer_no_origin.print(inline_expression.get_expression()) }};
        // derivative
        double d_i_tot_dv = {{ printer_no_origin.print(inline_expression_d) }};

        g_val = - d_i_tot_dv / 2.;
        i_val = this->i_tot_{{ion_channel_name}} - d_i_tot_dv * v_comp / 2.;
    }
    return std::make_pair(g_val, i_val);

}

{%- for function in channel_info["Functions"] %}
{{render_channel_function(function, ion_channel_name)}}
{%- endfor %}

double nest::{{ion_channel_name}}{{cm_unique_suffix}}::get_current_{{ion_channel_name}}(){
    return this->i_tot_{{ion_channel_name}};
}

// {{ion_channel_name}} channel end ///////////////////////////////////////////////////////////
{% endfor %}
////////////////////////////////////////////////////////////////////////////////

{%- for synapse_name, synapse_info in syns_info.items() %}
// {{synapse_name}} synapse ////////////////////////////////////////////////////////////////
nest::{{synapse_name}}{{cm_unique_suffix}}::{{synapse_name}}{{cm_unique_suffix}}( const long syn_index )
  {%- for param_name, param_declaration in synapse_info["Parameters"].items() %}
    {% if loop.first %}: {% else %}, {% endif %}
    {{ param_name }}({{ printer_no_origin.print(param_declaration["rhs_expression"]) }})
  {%- endfor %}
{
  syn_idx = syn_index;
}

nest::{{synapse_name}}{{cm_unique_suffix}}::{{synapse_name}}{{cm_unique_suffix}}( const long syn_index, const DictionaryDatum& receptor_params )
  {%- for param_name, param_declaration in synapse_info["Parameters"].items() %}
    {% if loop.first %}: {% else %}, {% endif %}
    {{ param_name }}({{ printer_no_origin.print(param_declaration["rhs_expression"]) }})
  {%- endfor %}
{
  syn_idx = syn_index;

  // update parameters
  {%- for param_name, param_declaration in synapse_info["Parameters"].items() %}
  if( receptor_params->known( "{{param_name}}" ) )
    {{param_name}} = getValue< double >( receptor_params, "{{param_name}}" );
  {%- endfor %}
}

void
nest::{{synapse_name}}{{cm_unique_suffix}}::append_recordables(std::map< Name, double* >* recordables)
{
  {%- for convolution, convolution_info in synapse_info["convolutions"].items() %}
  ( *recordables )[ Name( "{{convolution_info["kernel"]["name"]}}" + std::to_string(syn_idx) )] = &{{convolution}};
  {%- endfor %}
    ( *recordables )[ Name( "i_tot_{{synapse_name}}" + std::to_string(syn_idx) )] = &i_tot_{{synapse_name}};
}

{%- if nest_version.startswith("v2") or nest_version.startswith("v3.1") or nest_version.startswith("v3.2") or nest_version.startswith("v3.3") %}
void nest::{{synapse_name}}{{cm_unique_suffix}}::calibrate()
{%- else %}
void nest::{{synapse_name}}{{cm_unique_suffix}}::pre_run_hook()
{%- endif %}
{

  const double {{render_time_resolution_variable(synapse_info)}} = Time::get_resolution().get_ms();

  // set propagators to ode toolbox returned value
  {%- for convolution, convolution_info in synapse_info["convolutions"].items() %}
  {%- for state_variable_name, state_variable_info in convolution_info["analytic_solution"]["propagators"].items()%}
  {{state_variable_name}} = {{ printer_no_origin.print(state_variable_info["init_expression"]) }};
  {%- endfor %}
  {%- endfor %}

  // initial values for user defined states
  // warning: this shadows class variables
  {%- for state_name, state_declaration in synapse_info["States"].items() %}
  double {{state_name}} = {{ printer_no_origin.print(state_declaration["rhs_expression"]) }};
  {%- endfor %}

  // initial values for kernel state variables, set to zero
  {%- for convolution, convolution_info in synapse_info["convolutions"].items() %}
  {%- for state_variable_name, state_variable_info in convolution_info["analytic_solution"]["kernel_states"].items()%}
  {{state_variable_name}} = 0;
  {%- endfor %}
  {%- endfor %}

  // user declared internals in order they were declared
  {%- for internal_name, internal_declaration in synapse_info["internals_used_declared"] %}
  {{internal_name}} = {{ printer_no_origin.print(internal_declaration.get_expression()) }};
  {%- endfor %}

  {{synapse_info["buffer_name"]}}_->clear();
}

std::pair< double, double > nest::{{synapse_name}}{{cm_unique_suffix}}::f_numstep( const double v_comp, const long lag {% for ode in synapse_info["Dependencies"]["concentrations"] %}, double {{ode.lhs.name}}{% endfor %}
                        {% for inline in synapse_info["Dependencies"]["receptors"] %}, double {{inline.variable_name}}{% endfor %}
                        {% for inline in synapse_info["Dependencies"]["channels"] %}, double {{inline.variable_name}}{% endfor %})
{
  // get spikes
  double s_val = {{synapse_info["buffer_name"]}}_->get_value( lag ); //  * g_norm_;

  //update ODE state variable
  {% if synapse_info["ODEs"].items()|length %} double {{ printer_no_origin.print(synapse_info["time_resolution_var"]) }} = Time::get_resolution().get_ms(); {% endif %}
  {%- for ode_variable, ode_info in synapse_info["ODEs"].items() %}
      {%- for propagator, propagator_info in ode_info["transformed_solutions"][0]["propagators"].items() %}
  double {{ propagator }} = {{ printer_no_origin.print(propagator_info["init_expression"]) }};
      {%- endfor %}
      {%- for state, state_solution_info in ode_info["transformed_solutions"][0]["states"].items() %}
  {{state}} = {{ printer_no_origin.print(state_solution_info["update_expression"]) }};
      {%- endfor %}
  {%- endfor %}

  // update kernel state variable / compute synaptic conductance
  {%- for convolution, convolution_info in synapse_info["convolutions"].items() %}
  {%- for state_variable_name, state_variable_info in convolution_info["analytic_solution"]["kernel_states"].items() %}
  {{state_variable_name}} = {{ printer_no_origin.print(state_variable_info["update_expression"]) }};
  {{state_variable_name}} += s_val * {{ printer_no_origin.print(state_variable_info["init_expression"]) }};

  {%- endfor %}
  {%- endfor %}

  // total current
  // this expression should be the transformed inline expression
  this->i_tot_{{synapse_name}} = {{ printer_no_origin.print(synapse_info["root_expression"].get_expression()) }};

  // derivative of that expression
  // voltage derivative of total current
  // compute derivative with respect to current with sympy
  double d_i_tot_dv = {{ printer_no_origin.print(synapse_info["inline_expression_d"]) }};

  // for numerical integration
  double g_val = - d_i_tot_dv / 2.;
  double i_val = this->i_tot_{{synapse_name}} - d_i_tot_dv * v_comp / 2.;

  return std::make_pair(g_val, i_val);

}

{%- for function in synapse_info["functions_used"] %}
{{ function_declaration.FunctionDeclaration(function, "nest::"~synapse_name~cm_unique_suffix~"::") }}
{
{%-   filter indent(2,True) %}
{%-   with ast = function.get_block() %}
{%-     include "directives_cpp/Block.jinja2" %}
{%-   endwith %}
{%-   endfilter %}
}
{%- endfor %}

    double nest::{{synapse_name}}{{cm_unique_suffix}}::get_current_{{synapse_name}}(){
        return this->i_tot_{{synapse_name}};
    }

// {{synapse_name}} synapse end ///////////////////////////////////////////////////////////
{%- endfor %}

//////////////////////////////// concentrations
{%- for concentration_name, concentration_info in conc_info.items() %}

// {{ concentration_name }} concentration //////////////////////////////////////////////////////////////////
nest::{{ concentration_name }}{{cm_unique_suffix}}::{{ concentration_name }}{{cm_unique_suffix}}():
{%- set states_written = False %}
{%- for pure_variable_name, variable_info in concentration_info["States"].items() %}
// state variable {{pure_variable_name -}}
{%- set variable = variable_info["ASTVariable"] %}
{%- set rhs_expression = variable_info["rhs_expression"] %}
{% if loop.first %} {%- set states_written = True %} {% else %}, {% endif %}
{{- variable.name}}({{ printer_no_origin.print(rhs_expression) -}})
{%- endfor %}

{% for variable_type, variable_info in concentration_info["Parameters"].items() %}
// channel parameter {{variable_type -}}
{%- set variable = variable_info["ASTVariable"] %}
{%- set rhs_expression = variable_info["rhs_expression"] %}
{% if loop.first %} {% if states_written %}, {% endif %} {% else %}, {% endif %}
{{- variable.name }}({{ printer_no_origin.print(rhs_expression) -}})
{%- endfor %}
{}

nest::{{ concentration_name }}{{cm_unique_suffix}}::{{ concentration_name }}{{cm_unique_suffix}}(const DictionaryDatum& concentration_params):
{%- set states_written = False %}
{%- for pure_variable_name, variable_info in concentration_info["States"].items() %}
// state variable {{pure_variable_name -}}
{%- set variable = variable_info["ASTVariable"] %}
{%- set rhs_expression = variable_info["rhs_expression"] %}
{% if loop.first %} {%- set states_written = True %} {% else %}, {% endif %}
{{- variable.name}}({{ printer_no_origin.print(rhs_expression) -}})
{%- endfor %}

{% for variable_type, variable_info in concentration_info["Parameters"].items() %}
// channel parameter {{variable_type -}}
{%- set variable = variable_info["ASTVariable"] %}
{%- set rhs_expression = variable_info["rhs_expression"] %}
{% if loop.first %} {% if states_written %}, {% endif %} {% else %}, {% endif %}
{{- variable.name }}({{ printer_no_origin.print(rhs_expression) -}})
{%- endfor %}
// update {{ concentration_name }} concentration parameters
{
    {%- for variable_type, variable_info in concentration_info["Parameters"].items() %}
        {%- set variable = variable_info["ASTVariable"] %}
        {%- set dynamic_variable = render_dynamic_channel_variable_name(variable_type, concentration_name) %} //have to remove???????????
    // {{ concentration_name }} concentration parameter {{dynamic_variable }}
    if( concentration_params->known( "{{variable.name}}" ) )
        {{variable.name}} = getValue< double >( concentration_params, "{{variable.name}}" );
    {%- endfor %}
}

void
nest::{{ concentration_name }}{{cm_unique_suffix}}::append_recordables(std::map< Name, double* >* recordables,
                                               const long compartment_idx)
{
  // add state variables to recordables map
  {%- for pure_variable_name, variable_info in concentration_info["States"].items() %}
  {%- set variable = variable_info["ASTVariable"] %}
  ( *recordables )[ Name( "{{variable.name}}" + std::to_string(compartment_idx) )] = &{{variable.name}};
  {%- endfor %}
    ( *recordables )[ Name( "{{concentration_name}}" + std::to_string(compartment_idx) )] = &{{concentration_name}};
}

void nest::{{ concentration_name }}{{cm_unique_suffix}}::f_numstep(const double v_comp{% for ode in concentration_info["Dependencies"]["concentrations"] %}, double {{ode.lhs.name}}{% endfor %}
                        {% for inline in concentration_info["Dependencies"]["receptors"] %}, double {{inline.variable_name}}{% endfor %}
                        {% for inline in concentration_info["Dependencies"]["channels"] %}, double {{inline.variable_name}}{% endfor %})
{
    if({%- for key_zero_param in concentration_info["RootInlineKeyZeros"] %} {{ key_zero_param }} > 1e-9 && {%- endfor %} true ){
        double {{ printer_no_origin.print(concentration_info["time_resolution_var"]) }} = Time::get_resolution().get_ms();

        {%- for ode_variable, ode_info in concentration_info["ODEs"].items() %}
            {%- for propagator, propagator_info in ode_info["transformed_solutions"][0]["propagators"].items() %}
        double {{ propagator }} = {{ printer_no_origin.print(propagator_info["init_expression"]) }};
            {%- endfor %}
            {%- for state, state_solution_info in ode_info["transformed_solutions"][0]["states"].items() %}
        {{state}} = {{ printer_no_origin.print(state_solution_info["update_expression"]) }};
            {%- endfor %}
        {%- endfor %}
    }
}

{%- for function in concentration_info["Functions"] %}
{{render_channel_function(function, concentration_name)}}
{%- endfor %}

double nest::{{concentration_name}}{{cm_unique_suffix}}::get_concentration_{{concentration_name}}(){
    return this->{{concentration_name}};
}

// {{concentration_name}} concentration end ///////////////////////////////////////////////////////////
{% endfor %}
