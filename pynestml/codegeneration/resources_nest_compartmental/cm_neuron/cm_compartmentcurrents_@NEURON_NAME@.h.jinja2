#ifndef SYNAPSES_NEAT_H_{{cm_unique_suffix | upper }}
#define SYNAPSES_NEAT_H_{{cm_unique_suffix | upper }}

#include <stdlib.h>

#include "ring_buffer.h"

{% macro render_variable_type(variable) -%}
{%- with -%}
    {%- set symbol = variable.get_scope().resolve_to_symbol(variable.name, SymbolKind.VARIABLE) -%}
    {{ types_printer.convert(symbol.type_symbol) }}
{%- endwith -%}
{%- endmacro %}

namespace nest
{

{%- with %}
{%- for ion_channel_name, channel_info in chan_info.items() %}

class {{ion_channel_name}}{{cm_unique_suffix}}{
private:
// user-defined parameters {{ion_channel_name}} channel (maximal conductance, reversal potential)
    {%- for pure_variable_name, variable_info in channel_info["gating_variables"].items() %}
    // state variable {{pure_variable_name -}}
        {%- set variable = variable_info["state_variable"] %}
        {%- set rhs_expression = variable_info["rhs_expression"] %}
    {{render_variable_type(variable)}} {{ variable.name}} = {{printer.print_expression(rhs_expression, with_origins = False) -}};
    {%- endfor %}
// state variables {{ion_channel_name}} channel
    {%- for variable_type, variable_info in channel_info["channel_parameters"].items() %}
    // parameter {{variable_type -}}
        {%- set variable = variable_info["parameter_block_variable"] %}
        {%- set rhs_expression = variable_info["rhs_expression"] %}
    {{render_variable_type(variable)}} {{ variable.name}} = {{printer.print_expression(rhs_expression, with_origins = False) -}};
    {%- endfor %}

public:
    // constructor, destructor
    {{ion_channel_name}}{{cm_unique_suffix}}();
    {{ion_channel_name}}{{cm_unique_suffix}}(const DictionaryDatum& channel_params);
    ~{{ion_channel_name}}{{cm_unique_suffix}}(){};

    // initialization channel
{%- if nest_version.startswith("v2") or nest_version.startswith("v3.1") or nest_version.startswith("v3.2") or nest_version.startswith("v3.3") %}
    void calibrate() {
{%- else %}
    void pre_run_hook() {
{%- endif %}
    {%- for pure_variable_name, variable_info in channel_info["gating_variables"].items() -%}
        {%- set variable = variable_info["state_variable"] -%}
        {%- set rhs_expression = variable_info["rhs_expression"] -%}
        {{ variable.name}} = {{printer.print_expression(rhs_expression, with_origins = False) }};
    {%- endfor -%}
    };
    void append_recordables(std::map< Name, double* >* recordables,
                            const long compartment_idx);

    // numerical integration step
    std::pair< double, double > f_numstep( const double v_comp );

    // function declarations
{%- for pure_variable_name, state_variable_info in channel_info["gating_variables"].items() %}
{% for function_type, function_info in state_variable_info["expected_functions"].items() %}
    {{printer.print_function_declaration(function_info["ASTFunction"]) -}};
{% endfor %}
{%- endfor %}

};
{% endfor -%}
{% endwith -%}


////////////////////////////////////////////////// synapses

{% macro render_time_resolution_variable(synapse_info) -%}
{# we assume here that there is only one such variable ! #}
{%- with %}
{%- for analytic_helper_name, analytic_helper_info in synapse_info["analytic_helpers"].items() -%}
{%- if analytic_helper_info["is_time_resolution"] -%}
    {{ analytic_helper_name }}
{%- endif -%}
{%- endfor -%}
{% endwith %}
{%- endmacro %}

{%- with %}
{%- for synapse_name, synapse_info in syns_info.items() %}

class {{synapse_name}}{{cm_unique_suffix}}{
private:
  // global synapse index
  long syn_idx = 0;

  // propagators, initialized via pre_run_hook() or calibrate()
  {%- for convolution, convolution_info in synapse_info["convolutions"].items() %}
  {%- for state_variable_name, state_variable_info in convolution_info["analytic_solution"]["propagators"].items()%}
  double {{state_variable_name}};
  {%- endfor %}
  {%- endfor %}

  // kernel state variables, initialized via pre_run_hook() or calibrate()
  {%- for convolution, convolution_info in synapse_info["convolutions"].items() %}
  {%- for state_variable_name, state_variable_info in convolution_info["analytic_solution"]["kernel_states"].items()%}
  double {{state_variable_name}};
  {%- endfor %}
  {%- endfor %}

  // user defined parameters, initialized via pre_run_hook() or calibrate()
  {%- for param_name, param_declaration in synapse_info["parameters_used"].items() %}
  double {{param_name}};
  {%- endfor %}

  // user declared internals in order they were declared, initialized via pre_run_hook() or calibrate()
  {%- for internal_name, internal_declaration in synapse_info["internals_used_declared"] %}
  double {{internal_name}};
  {%- endfor %}

  // spike buffer
  RingBuffer* {{synapse_info["buffer_name"]}}_;

public:
  // constructor, destructor
  {{synapse_name}}{{cm_unique_suffix}}( const long syn_index);
  {{synapse_name}}{{cm_unique_suffix}}( const long syn_index, const DictionaryDatum& receptor_params);
  ~{{synapse_name}}{{cm_unique_suffix}}(){};

  long
  get_syn_idx()
  {
    return syn_idx;
  };

  // numerical integration step
  std::pair< double, double > f_numstep( const double v_comp, const long lag );

  // calibration
{%- if nest_version.startswith("v2") or nest_version.startswith("v3.1") or nest_version.startswith("v3.2") or nest_version.startswith("v3.3") %}
  void calibrate();
{%- else %}
  void pre_run_hook();
{%- endif %}
  void append_recordables(std::map< Name, double* >* recordables);
  void set_buffer_ptr( std::vector< RingBuffer >& syn_buffers )
  {
    {{synapse_info["buffer_name"]}}_ = &syn_buffers[ syn_idx ];
  };

  // function declarations
  {% for function in neuron.get_functions() %}
  {{printer.print_function_declaration(function)}};
  {% endfor %}
};


{% endfor -%}
{% endwith -%}

///////////////////////////////////////////// currents

{%- set channel_suffix = "_chan_" %}

class CompartmentCurrents{{cm_unique_suffix}} {
private:
  // ion channels
{% with %}
  {%- for ion_channel_name, channel_info in chan_info.items() %}
  {{ion_channel_name}}{{cm_unique_suffix}} {{ion_channel_name}}{{channel_suffix}};
  {% endfor -%}
{% endwith %}

  // synapses
  {%- with %}
  {%- for synapse_name, synapse_info in syns_info.items() %}
  std::vector < {{synapse_name}}{{cm_unique_suffix}} > {{synapse_name}}_syns_;
  {% endfor -%}
  {% endwith -%}

public:
  CompartmentCurrents{{cm_unique_suffix}}(){};
  explicit CompartmentCurrents{{cm_unique_suffix}}(const DictionaryDatum& channel_params)
  {
  {%- with %}
    {%- for ion_channel_name, channel_info in chan_info.items() %}
    {{ion_channel_name}}{{channel_suffix}} = {{ion_channel_name}}{{cm_unique_suffix}}( channel_params );
    {% endfor -%}
  {% endwith -%}
  };
  ~CompartmentCurrents{{cm_unique_suffix}}(){};

{%- if nest_version.startswith("v2") or nest_version.startswith("v3.1") or nest_version.startswith("v3.2") or nest_version.startswith("v3.3") %}
  void calibrate() {
{%- else %}
  void pre_run_hook() {
{%- endif %}
    // initialization of the ion channels
  {%- with %}
    {%- for ion_channel_name, channel_info in chan_info.items() %}
{%- if nest_version.startswith("v2") or nest_version.startswith("v3.1") or nest_version.startswith("v3.2") or nest_version.startswith("v3.3") %}
    {{ion_channel_name}}{{channel_suffix}}.calibrate();
{%- else %}
    {{ion_channel_name}}{{channel_suffix}}.pre_run_hook();
{%- endif %}
    {% endfor -%}
  {% endwith -%}

    // initialization of synapses
  {%- with %}
  {%- for synapse_name, synapse_info in syns_info.items() %}
    // initialization of {{synapse_name}} synapses
    for( auto syn_it = {{synapse_name}}_syns_.begin();
         syn_it != {{synapse_name}}_syns_.end();
         ++syn_it )
    {
{%- if nest_version.startswith("v2") or nest_version.startswith("v3.1") or nest_version.startswith("v3.2") or nest_version.startswith("v3.3") %}
      syn_it->calibrate();
{%- else %}
      syn_it->pre_run_hook();
{%- endif %}
    }
  {% endfor -%}
  {% endwith -%}
  };

  void add_synapse( const std::string& type, const long syn_idx )
  {
  {%- with %}
  {%- for synapse_name, synapse_info in syns_info.items() %}
    {% if not loop.first %}else{% endif %} if ( type == "{{synapse_name}}" )
    {
      {{synapse_name}}_syns_.push_back( {{synapse_name}}{{cm_unique_suffix}}( syn_idx ) );
    }
  {% endfor -%}
  {% endwith -%}
    else
    {
      assert( false );
    }
  };
  void add_synapse( const std::string& type, const long syn_idx, const DictionaryDatum& receptor_params )
  {
  {%- with %}
  {%- for synapse_name, synapse_info in syns_info.items() %}
    {% if not loop.first %}else{% endif %} if ( type == "{{synapse_name}}" )
    {
      {{synapse_name}}_syns_.push_back( {{synapse_name}}{{cm_unique_suffix}}( syn_idx, receptor_params ) );
    }
  {% endfor -%}
  {% endwith -%}
    else
    {
      assert( false );
    }
  };

  void
  add_receptor_info( ArrayDatum& ad, const long compartment_index )
  {

    {%- with %}
    {%- for synapse_name, synapse_info in syns_info.items() %}
    for( auto syn_it = {{synapse_name}}_syns_.begin(); syn_it != {{synapse_name}}_syns_.end(); syn_it++)
    {
      DictionaryDatum dd = DictionaryDatum( new Dictionary );
      def< long >( dd, names::receptor_idx, syn_it->get_syn_idx() );
      def< long >( dd, names::comp_idx, compartment_index );
      def< std::string >( dd, names::receptor_type, "{{synapse_name}}" );
      ad.push_back( dd );
    }
    {% endfor -%}
    {% endwith -%}
  };

  void
  set_syn_buffers( std::vector< RingBuffer >& syn_buffers )
  {
    // spike buffers for synapses
    {%- with %}
    {%- for synapse_name, synapse_info in syns_info.items() %}
    for( auto syn_it = {{synapse_name}}_syns_.begin(); syn_it != {{synapse_name}}_syns_.end(); syn_it++)
      syn_it->set_buffer_ptr( syn_buffers );
    {% endfor -%}
    {% endwith -%}
  };

  std::map< Name, double* >
  get_recordables( const long compartment_idx )
  {
    std::map< Name, double* > recordables;

    // append ion channel state variables to recordables
    {%- with %}
    {%- for ion_channel_name, channel_info in chan_info.items() %}
    {{ion_channel_name}}{{channel_suffix}}.append_recordables( &recordables, compartment_idx );
    {% endfor -%}
    {% endwith -%}

    // append synapse state variables to recordables
    {%- with %}
    {%- for synapse_name, synapse_info in syns_info.items() %}
    for( auto syn_it = {{synapse_name}}_syns_.begin(); syn_it != {{synapse_name}}_syns_.end(); syn_it++)
      syn_it->append_recordables( &recordables );
    {% endfor -%}
    {% endwith -%}

    return recordables;
  };

  std::pair< double, double >
  f_numstep( const double v_comp, const long lag )
  {
    std::pair< double, double > gi(0., 0.);
    double g_val = 0.;
    double i_val = 0.;

  {%- with %}
    {%- for ion_channel_name, channel_info in chan_info.items() %}
    // contribution of {{ion_channel_name}} channel
    gi = {{ion_channel_name}}{{channel_suffix}}.f_numstep( v_comp );

    g_val += gi.first;
    i_val += gi.second;

    {% endfor -%}
  {% endwith -%}

  {%- with %}
  {%- for synapse_name, synapse_info in syns_info.items() %}
    // contribution of {{synapse_name}} synapses
    for( auto syn_it = {{synapse_name}}_syns_.begin();
         syn_it != {{synapse_name}}_syns_.end();
         ++syn_it )
    {
      gi = syn_it->f_numstep( v_comp, lag );

      g_val += gi.first;
      i_val += gi.second;
    }
  {% endfor -%}
  {% endwith -%}

    return std::make_pair(g_val, i_val);
  };
};

} // namespace

#endif /* #ifndef SYNAPSES_NEAT_H_{{cm_unique_suffix | upper }} */
