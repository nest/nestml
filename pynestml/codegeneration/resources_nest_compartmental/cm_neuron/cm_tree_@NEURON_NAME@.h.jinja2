{#-
cm_tree_@NEURON_NAME@.h.jinja2

This file is part of NEST.

Copyright (C) 2004 The NEST Initiative

NEST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

NEST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with NEST.  If not, see <http://www.gnu.org/licenses/>.
#}
{%- if tracing %}/* generated by {{self._TemplateReference__context.name}} */ {% endif %}
{%- import 'directives_cpp/SpikeBufferGetter.jinja2' as buffer_getter with context %}
{%- import 'directives_cpp/ContinuousInputBufferGetter.jinja2' as continuous_buffer_getter with context %}
{%- import 'directives_cpp/BufferDeclaration.jinja2' as buffer_declaration with context %}
{%- import 'directives_cpp/BufferDeclarationValue.jinja2' as buffer_declaration_value with context %}
{%- import 'directives_cpp/FunctionDeclaration.jinja2' as function_declaration with context %}
{%- import 'directives_cpp/OutputEvent.jinja2' as output_event with context %}
/*
 *  {{neuronSpecificFileNamesCmSyns["tree"]}}.h
 *
 *  This file is part of NEST.
 *
 *  Copyright (C) 2004 The NEST Initiative
 *
 *  NEST is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  NEST is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef CM_TREE_{{cm_unique_suffix | upper }}_H
#define CM_TREE_{{cm_unique_suffix | upper }}_H

#include <stdlib.h>

#include "nest_time.h"
#include "ring_buffer.h"

// compartmental model
#include "{{neuronSpecificFileNamesCmSyns["compartmentcurrents"]}}.h"

// Includes from libnestutil:
#include "dict_util.h"
#include "numerics.h"

// Includes from nestkernel:
#include "exceptions.h"
#include "kernel_manager.h"
#include "universal_data_logger_impl.h"

// Includes from sli:
#include "dict.h"
#include "dictutils.h"


namespace nest
{

class Compartment{{cm_unique_suffix}}
{
private:
  // aggragators for numerical integration
  double xx_;
  double yy_;

public:
  // compartment index
  long comp_index;
  // parent compartment index
  long p_index;
  // tree structure indices
  Compartment{{cm_unique_suffix}}* parent;
  std::vector< Compartment{{cm_unique_suffix}} > children;
  // vector for synapses
  CompartmentCurrents{{cm_unique_suffix}} compartment_currents;

  // buffer for currents
  RingBuffer currents;
  // voltage variable
  double v_comp;
  // electrical parameters
  double ca; // compartment capacitance [uF]
  double gc; // coupling conductance with parent (meaningless if root) [uS]
  double gl; // leak conductance of compartment [uS]
  double el; // leak current reversal potential [mV]
  // auxiliary variables for efficienchy
  double gg0;
  double ca__div__dt;
  double gl__div__2;
  double gc__div__2;
  double gl__times__el;
  // for numerical integration
  double ff;
  double gg;
  double hh;
  // passage counter for recursion
  int n_passed;

  // constructor, destructor
  Compartment{{cm_unique_suffix}}( const long compartment_index, const long parent_index );
  Compartment{{cm_unique_suffix}}( const long compartment_index, const long parent_index, const DictionaryDatum& compartment_params );
  ~Compartment{{cm_unique_suffix}}(){};

  // initialization
{%- if nest_version.startswith("v2") or nest_version.startswith("v3.1") or nest_version.startswith("v3.2") or nest_version.startswith("v3.3") %}
  void calibrate();
{%- else %}
  void pre_run_hook();
{%- endif %}
  std::map< Name, double* > get_recordables();

  // matrix construction
  void construct_matrix_element( const long lag );

  // maxtrix inversion
  inline void gather_input( const std::pair< double, double >& in );
  inline std::pair< double, double > io();
  inline double calc_v( const double v_in );
}; // Compartment


/*
Short helper functions for solving the matrix equation. Can hopefully be inlined
*/
inline void
nest::Compartment{{cm_unique_suffix}}::gather_input( const std::pair< double, double >& in )
{
  xx_ += in.first;
  yy_ += in.second;
}
inline std::pair< double, double >
nest::Compartment{{cm_unique_suffix}}::io()
{
  // include inputs from child compartments
  gg -= xx_;
  ff -= yy_;

  // output values
  double g_val( hh * hh / gg );
  double f_val( ff * hh / gg );

  return std::make_pair( g_val, f_val );
}
inline double
nest::Compartment{{cm_unique_suffix}}::calc_v( const double v_in )
{
  // reset recursion variables
  xx_ = 0.0;
  yy_ = 0.0;

  // compute voltage
  v_comp = ( ff - v_in * hh ) / gg;

  return v_comp;
}


class CompTree{{cm_unique_suffix}}
{
private:
  /*
  structural data containers for the compartment model
  */
  mutable Compartment{{cm_unique_suffix}} root_;
  std::vector< long > compartment_indices_;
  std::vector< Compartment{{cm_unique_suffix}}* > compartments_;
  std::vector< Compartment{{cm_unique_suffix}}* > leafs_;

  long size_ = 0;

  // recursion functions for matrix inversion
  void solve_matrix_downsweep( Compartment{{cm_unique_suffix}}* compartment_ptr, std::vector< Compartment{{cm_unique_suffix}}* >::iterator leaf_it );
  void solve_matrix_upsweep( Compartment{{cm_unique_suffix}}* compartment, double vv );

  // functions for pointer initialization
  void set_parents();
  void set_compartments();
  void set_leafs();

public:
  // constructor, destructor
  CompTree{{cm_unique_suffix}}();
  ~CompTree{{cm_unique_suffix}}(){};

  // initialization functions for tree structure
  void add_compartment( const long parent_index );
  void add_compartment( const long parent_index, const DictionaryDatum& compartment_params );
  void add_compartment( Compartment{{cm_unique_suffix}}* compartment, const long parent_index );
{%- if nest_version.startswith("v2") or nest_version.startswith("v3.1") or nest_version.startswith("v3.2") or nest_version.startswith("v3.3") %}
  void calibrate();
{%- else %}
  void pre_run_hook();
{%- endif %}

  void init_pointers();
  void set_syn_buffers( std::vector< RingBuffer >& syn_buffers );
  std::map< Name, double* > get_recordables();

  // get a compartment pointer from the tree
  Compartment{{cm_unique_suffix}}* get_compartment( const long compartment_index ) const;
  Compartment{{cm_unique_suffix}}* get_compartment( const long compartment_index, Compartment{{cm_unique_suffix}}* compartment, const long raise_flag ) const;
  Compartment{{cm_unique_suffix}}* get_compartment_opt( const long compartment_indx ) const;
  Compartment{{cm_unique_suffix}}*
  get_root() const
  {
    return &root_;
  };

  // get tree size (number of compartments)
  long
  get_size() const
  {
    return size_;
  };

  // get voltage values
  std::vector< double > get_voltage() const;
  double get_compartment_voltage( const long compartment_index );

  // construct the numerical integration matrix and vector
  void construct_matrix( const long lag );
  // solve the matrix equation for next timestep voltage
  void solve_matrix();

  // print function
  void print_tree() const;
}; // CompTree

} // namespace

#endif /* #ifndef CM_TREE_{{cm_unique_suffix | upper }}_H */
