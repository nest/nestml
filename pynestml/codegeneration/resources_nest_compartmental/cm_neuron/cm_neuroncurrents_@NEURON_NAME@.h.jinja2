{#-
cm_compartmentcurrents_@NEURON_NAME@.h.jinja2

This file is part of NEST.

Copyright (C) 2004 The NEST Initiative

NEST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

NEST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with NEST.  If not, see <http://www.gnu.org/licenses/>.
#}

{%- if tracing %}/* generated by {{self._TemplateReference__context.name}} */ {% endif -%}
{%- import 'directives_cpp/FunctionDeclaration.jinja2' as function_declaration with context %}
{%- import 'directives_cpp/WriteInDictionary.jinja2' as write_in_dictionary with context %}
#ifndef RECEPTORS_NEAT_H_{{cm_unique_suffix | upper }}
#define RECEPTORS_NEAT_H_{{cm_unique_suffix | upper }}

#include <stdlib.h>
#include <vector>
#include <cmath>

#include "ring_buffer.h"

{% macro render_variable_type(variable) -%}
{%- with -%}
    {%- set symbol = variable.get_scope().resolve_to_symbol(variable.name, SymbolKind.VARIABLE) -%}
    {{ types_printer.print(symbol.type_symbol) }}
{%- endwith -%}
{%- endmacro %}

//elementwise vector operations:
#include <iostream>
#include <stdexcept>
#include <algorithm>

namespace nest
{

///////////////////////////////////// channels

{%- with %}
{%- for ion_channel_name, channel_info in chan_info.items() %}

class {{ion_channel_name}}{{cm_unique_suffix}}{
private:
    // states
    {%- for pure_variable_name, variable_info in channel_info["States"].items() %}
        {%- set variable = variable_info["ASTVariable"] %}
        {%- set rhs_expression = variable_info["rhs_expression"] %}
    std::vector< {{ render_variable_type(variable) }} > {{ variable.name }} = {};
    {%- endfor %}

    // parameters
    {%- for pure_variable_name, variable_info in channel_info["Parameters"].items() %}
        {%- set variable = variable_info["ASTVariable"] %}
        {%- set rhs_expression = variable_info["rhs_expression"] %}
    std::vector< {{ render_variable_type(variable) }} > {{ variable.name }} = {};
    {%- endfor %}

    // internals
    {%- for pure_variable_name, variable_info in channel_info["Internals"].items() %}
        {%- set variable = variable_info["ASTVariable"] %}
        {%- set rhs_expression = variable_info["rhs_expression"] %}
    std::vector< {{ render_variable_type(variable) }} > {{ variable.name }} = {};
    {%- endfor %}

    // recordable inlines
    {%- for variable_info in channel_info["SecondaryInlineExpressions"] %}
        {%- if variable_info.is_recordable %}
        {%- set variable = variable_info.variable_name %}
        {%- set rhs_expression = variable_info.expression %}
    std::vector< double > {{ variable }} = {};
        {%- endif %}
    {%- endfor %}

      // propagators, initialized via pre_run_hook() or calibrate()
  {%- for convolution, convolution_info in channel_info["convolutions"].items() %}
  {%- for state_variable_name, state_variable_info in convolution_info["analytic_solution"]["propagators"].items()%}
  std::vector< double > {{state_variable_name}};
  {%- endfor %}
  {%- endfor %}

  // kernel state variables, initialized via pre_run_hook() or calibrate()
  {%- for convolution, convolution_info in channel_info["convolutions"].items() %}
  {%- for state_variable_name, state_variable_info in convolution_info["analytic_solution"]["kernel_states"].items()%}
  std::vector< double > {{state_variable_name}};
  {%- endfor %}
  {%- endfor %}

    // ion-channel root-inline value
    std::vector< double > i_tot_{{ion_channel_name}} = {};

    //zero recordable variable in case of zero contribution channel
    double zero_recordable = 0;

    const bool& self_spikes;

public:
    // constructor, destructor
    {{ion_channel_name}}{{cm_unique_suffix}}(bool& global_self_spikes) : self_spikes(global_self_spikes) {};
    ~{{ion_channel_name}}{{cm_unique_suffix}}(){};

    void new_channel(std::size_t comp_ass);
    void new_channel(std::size_t comp_ass, const DictionaryDatum& channel_params);

    //number of channels
    std::size_t neuron_{{ ion_channel_name }}_channel_count = 0;

    std::vector< size_t > compartment_association = {};

    // initialization channel
{%- if nest_version.startswith("v2") or nest_version.startswith("v3.1") or nest_version.startswith("v3.2") or nest_version.startswith("v3.3") %}
    void calibrate();
{%- else %}
    void pre_run_hook();
{%- endif %}

    void append_recordables(std::map< Name, double* >* recordables, const long compartment_idx);

    // numerical integration step
    void f_numstep(const std::vector< double >& v_comp{% for ode in channel_info["Dependencies"]["concentrations"] %}, const std::vector< double >& {{ode.lhs.name}}{% endfor %}{% if channel_info["Dependencies"]["receptors"]|length %}
                        {% endif %}{% for inline in channel_info["Dependencies"]["receptors"] %}, const std::vector< double >& {{inline.variable_name}}{% endfor %}{% if channel_info["Dependencies"]["channels"]|length %}
                        {% endif %}{% for inline in channel_info["Dependencies"]["channels"] %}, const std::vector< double >& {{inline.variable_name}}{% endfor %}{% if channel_info["Dependencies"]["continuous"]|length %}
                        {% endif %}{% for inline in channel_info["Dependencies"]["continuous"] %}, const std::vector< double >& {{inline.variable_name}}{% endfor %}
                        , std::vector< double >& i_val, std::vector< double >& g_val);


    void f_update();
    void f_self_spike();

    // function declarations

{%- for function in channel_info["Functions"] %}
    #pragma omp declare simd
    __attribute__((always_inline)) inline {{ function_declaration.FunctionDeclaration(function, pass_by_reference = true) }};
{%- endfor %}

    // root_inline getter
    void get_currents_per_compartment(std::vector< double >& compartment_to_current);

    std::vector< double > distribute_shared_vector(std::vector< double > shared_vector);

};
{% endfor -%}
{% endwith -%}


///////////////////////////////////////////// concentrations

{%- with %}
{%- for concentration_name, concentration_info in conc_info.items() %}

class {{ concentration_name }}{{cm_unique_suffix}}{
private:
    // parameters
    {%- for pure_variable_name, variable_info in concentration_info["Parameters"].items() %}
        {%- set variable = variable_info["ASTVariable"] %}
        {%- set rhs_expression = variable_info["rhs_expression"] %}
    std::vector< {{ render_variable_type(variable) }} > {{ variable.name }} = {};
    {%- endfor %}

    // states
    {%- for pure_variable_name, variable_info in concentration_info["States"].items() %}
        {%- set variable = variable_info["ASTVariable"] %}
        {%- set rhs_expression = variable_info["rhs_expression"] %}
    std::vector< {{ render_variable_type(variable) }} > {{ variable.name }} = {};
    {%- endfor %}

    // internals
    {%- for pure_variable_name, variable_info in concentration_info["Internals"].items() %}
        {%- set variable = variable_info["ASTVariable"] %}
        {%- set rhs_expression = variable_info["rhs_expression"] %}
    std::vector< {{ render_variable_type(variable) }} > {{ variable.name }} = {};
    {%- endfor %}

    // recordable inlines
    {%- for variable_info in concentration_info["SecondaryInlineExpressions"] %}
        {%- if variable_info.is_recordable %}
        {%- set variable = variable_info.variable_name %}
        {%- set rhs_expression = variable_info.expression %}
    std::vector< double > {{ variable }} = {};
        {%- endif %}
    {%- endfor %}

      // propagators, initialized via pre_run_hook() or calibrate()
  {%- for convolution, convolution_info in concentration_info["convolutions"].items() %}
  {%- for state_variable_name, state_variable_info in convolution_info["analytic_solution"]["propagators"].items()%}
  std::vector< double > {{state_variable_name}};
  {%- endfor %}
  {%- endfor %}

  // kernel state variables, initialized via pre_run_hook() or calibrate()
  {%- for convolution, convolution_info in concentration_info["convolutions"].items() %}
  {%- for state_variable_name, state_variable_info in convolution_info["analytic_solution"]["kernel_states"].items()%}
  std::vector< double > {{state_variable_name}};
  {%- endfor %}
  {%- endfor %}

    // concentration value (root-ode state)
    std::vector< double > {{concentration_name}} = {};

    //zero recordable variable in case of zero contribution concentration
    double zero_recordable = 0;

    const bool& self_spikes;

public:
    // constructor, destructor
    {{ concentration_name }}{{cm_unique_suffix}}(bool& global_self_spikes) : self_spikes(global_self_spikes) {};
    ~{{ concentration_name }}{{cm_unique_suffix}}(){};

    void new_concentration(std::size_t comp_ass);
    void new_concentration(std::size_t comp_ass, const DictionaryDatum& concentration_params);

    //number of channels
    std::size_t neuron_{{ concentration_name }}_concentration_count = 0;

    std::vector< size_t > compartment_association = {};

    // initialization concentration
{%- if nest_version.startswith("v2") or nest_version.startswith("v3.1") or nest_version.startswith("v3.2") or nest_version.startswith("v3.3") %}
    void calibrate();
{%- else %}
    void pre_run_hook();
{%- endif %}
    void append_recordables(std::map< Name, double* >* recordables, const long compartment_idx);

    // numerical integration step
    void f_numstep(const std::vector< double >& v_comp{% for ode in concentration_info["Dependencies"]["concentrations"] %}, const std::vector< double >& {{ode.lhs.name}}{% endfor %}{% if concentration_info["Dependencies"]["receptors"]|length %}
                        {% endif %}{% for inline in concentration_info["Dependencies"]["receptors"] %}, const std::vector< double >& {{inline.variable_name}}{% endfor %}{% if concentration_info["Dependencies"]["channels"]|length %}
                        {% endif %}{% for inline in concentration_info["Dependencies"]["channels"] %}, const std::vector< double >& {{inline.variable_name}}{% endfor %}{% if concentration_info["Dependencies"]["continuous"]|length %}
                        {% endif %}{% for inline in concentration_info["Dependencies"]["continuous"] %}, const std::vector< double >& {{inline.variable_name}}{% endfor %});

    void f_update();
    void f_self_spike();

    // function declarations
{%- for function in concentration_info["Functions"] %}
    #pragma omp declare simd
    __attribute__((always_inline)) inline {{ function_declaration.FunctionDeclaration(function, pass_by_reference = true) }};
{%- endfor %}

    // root_ode getter
    void get_concentrations_per_compartment(std::vector< double >& compartment_to_concentration);

    std::vector< double > distribute_shared_vector(std::vector< double > shared_vector);

};
{% endfor -%}
{% endwith -%}


////////////////////////////////////////////////// receptors

{% macro render_time_resolution_variable(receptor_info) -%}
{# we assume here that there is only one such variable ! #}
{%- with %}
{%- for analytic_helper_name, analytic_helper_info in receptor_info["analytic_helpers"].items() -%}
{%- if analytic_helper_info["is_time_resolution"] -%}
    {{ analytic_helper_name }}
{%- endif -%}
{%- endfor -%}
{% endwith %}
{%- endmacro %}

{%- with %}
{%- for receptor_name, receptor_info in recs_info.items() %}

class {{receptor_name}}{{cm_unique_suffix}}{
private:
  // global receptor index
  std::vector< long > rec_idx = {};

  // propagators, initialized via pre_run_hook() or calibrate()
  {%- for convolution, convolution_info in receptor_info["convolutions"].items() %}
  {%- for state_variable_name, state_variable_info in convolution_info["analytic_solution"]["propagators"].items()%}
  std::vector< double > {{state_variable_name}};
  {%- endfor %}
  {%- endfor %}

  // kernel state variables, initialized via pre_run_hook() or calibrate()
  {%- for convolution, convolution_info in receptor_info["convolutions"].items() %}
  {%- for state_variable_name, state_variable_info in convolution_info["analytic_solution"]["kernel_states"].items()%}
  std::vector< double > {{state_variable_name}};
  {%- endfor %}
  {%- endfor %}

  // user defined parameters, initialized via pre_run_hook() or calibrate()
  {%- for param_name, param_declaration in receptor_info["Parameters"].items() %}
  std::vector< double > {{param_name}};
  {%- endfor %}

      // states
    {%- for pure_variable_name, variable_info in receptor_info["States"].items() %}
        {%- set variable = variable_info["ASTVariable"] %}
        {%- set rhs_expression = variable_info["rhs_expression"] %}
  std::vector<{{ render_variable_type(variable) }}> {{ variable.name }} = {}
        };
    {%- endfor %}

    // recordable inlines
    {%- for variable_info in receptor_info["SecondaryInlineExpressions"] %}
        {%- if variable_info.is_recordable %}
        {%- set variable = variable_info.variable_name %}
        {%- set rhs_expression = variable_info.expression %}
    std::vector< double > {{ variable }} = {};
        {%- endif %}
    {%- endfor %}

  std::vector < double > s_val = {};

  std::vector< double > i_tot_{{receptor_name}} = {};

  // user declared internals in order they were declared, initialized via pre_run_hook() or calibrate()
  {%- for internal_name, internal_declaration in receptor_info["internals_used_declared"] %}
  std::vector< double > {{internal_name}};
  {%- endfor %}

  // spike buffer
  std::vector< RingBuffer* > {{receptor_info["buffer_name"]}}_;

    const bool& self_spikes;

public:
  // constructor, destructor
  {{receptor_name}}{{cm_unique_suffix}}(bool& global_self_spikes) : self_spikes(global_self_spikes) {};
  ~{{receptor_name}}{{cm_unique_suffix}}(){};

  void new_receptor(std::size_t comp_ass, const long rec_index);
  void new_receptor(std::size_t comp_ass, const long rec_index, const DictionaryDatum& receptor_params);

  //number of receptors
  std::size_t neuron_{{ receptor_name }}_receptor_count = 0;

  std::vector< size_t > compartment_association = {};

  // numerical integration step
  void f_numstep(const std::vector< double >& v_comp, const long& lag {% for ode in receptor_info["Dependencies"]["concentrations"] %}, const std::vector< double >& {{ode.lhs.name}}{% endfor %}{% if receptor_info["Dependencies"]["receptors"]|length %}
                        {% endif %}{% for inline in receptor_info["Dependencies"]["receptors"] %}, const std::vector< double >& {{inline.variable_name}}{% endfor %}{% if receptor_info["Dependencies"]["channels"]|length %}
                        {% endif %}{% for inline in receptor_info["Dependencies"]["channels"] %}, const std::vector< double >& {{inline.variable_name}}{% endfor %}{% if receptor_info["Dependencies"]["continuous"]|length %}
                        {% endif %}{% for inline in receptor_info["Dependencies"]["continuous"] %}, const std::vector< double >& {{inline.variable_name}}{% endfor %}
                        , std::vector< double >& i_val, std::vector< double >& g_val);

    void f_update();
    void f_self_spike();

  // calibration
{%- if nest_version.startswith("v2") or nest_version.startswith("v3.1") or nest_version.startswith("v3.2") or nest_version.startswith("v3.3") %}
  void calibrate();
{%- else %}
  void pre_run_hook();
{%- endif %}
  void append_recordables(std::map< Name, double* >* recordables, const long compartment_idx);
  void set_buffer_ptr( std::vector< RingBuffer >& rec_buffers )
  {
    for(std::size_t i = 0; i < rec_idx.size(); i++){
        {{receptor_info["buffer_name"]}}_.push_back(&(rec_buffers[rec_idx[i]]));
    }
  };

  // function declarations
  {%- for function in receptor_info["Functions"] %}
  #pragma omp declare simd
    __attribute__((always_inline)) inline {{ function_declaration.FunctionDeclaration(function, pass_by_reference = true) -}};

  {% endfor %}

    // root_inline getter
    void get_currents_per_compartment(std::vector< double >& compartment_to_current);

    std::vector< double > distribute_shared_vector(std::vector< double > shared_vector);

};

{% endfor -%}
{% endwith -%}

////////////////////////////////////////////////// receptors with synapses attached


{%- with %}
{%- for synapse_name, synapse_info in syns_info.items() %}
{%- for receptor_name, receptor_info in recs_info.items() %}

class {{receptor_name}}{{cm_unique_suffix}}_con_{{synapse_name}}{
private:

  // dendritic delay buffer class
    class TimerDeque {
    public:
        TimerDeque(double delay) :
            countdown(nest::Time::delay_ms_to_steps(delay))
            {}

        void push(double value) {
            int local_countdown = countdown - total_countdown;
            total_countdown = countdown;
            dq.push_back(std::make_pair(local_countdown, value));
        }

        double tick() {
            if (!dq.empty()) {
                dq.front().first--;
                total_countdown--;
                if (dq.front().first == 0) {
                    double value = dq.front().second;
                    dq.pop_front();
                    return value;
                }
            }
            return 0;
        }

    private:
        std::deque<std::pair<int, double>> dq;

        const int countdown;
        int total_countdown = 0;
    };

  // delayed spikes queue
  std::vector<TimerDeque> delayed_spikes;

  // global receptor index
  std::vector< long > syn_idx = {};

  // propagators, initialized via pre_run_hook() or calibrate()
  {%- for convolution, convolution_info in receptor_info["convolutions"].items() %}
  {%- for state_variable_name, state_variable_info in convolution_info["analytic_solution"]["propagators"].items()%}
  std::vector< double > {{state_variable_name}};
  {%- endfor %}
  {%- endfor %}

  // kernel state variables, initialized via pre_run_hook() or calibrate()
  {%- for convolution, convolution_info in receptor_info["convolutions"].items() %}
  {%- for state_variable_name, state_variable_info in convolution_info["analytic_solution"]["kernel_states"].items()%}
  std::vector< double > {{state_variable_name}};
  {%- endfor %}
  {%- endfor %}

  // user defined parameters, initialized via pre_run_hook() or calibrate()
  {%- for param_name, param_declaration in receptor_info["Parameters"].items() %}
  std::vector< double > {{param_name}};
  {%- endfor %}

      // states
    {%- for pure_variable_name, variable_info in receptor_info["States"].items() %}
        {%- set variable = variable_info["ASTVariable"] %}
        {%- set rhs_expression = variable_info["rhs_expression"] %}
  std::vector<{{ render_variable_type(variable) }}> {{ variable.name }} = {}
        };
    {%- endfor %}

    // recordable inlines
    {%- for variable_info in receptor_info["SecondaryInlineExpressions"] %}
        {%- if variable_info.is_recordable %}
        {%- set variable = variable_info.variable_name %}
        {%- set rhs_expression = variable_info.expression %}
    std::vector< double > {{ variable }} = {};
        {%- endif %}
    {%- endfor %}

  std::vector < double > s_val = {};

  std::vector< double > i_tot_{{receptor_name}} = {};

  // user declared internals in order they were declared, initialized via pre_run_hook() or calibrate()
  {%- for internal_name, internal_declaration in receptor_info["internals_used_declared"] %}
  std::vector< double > {{internal_name}};
  {%- endfor %}



  // spike buffer
  std::vector< RingBuffer* > {{receptor_info["buffer_name"]}}_;

    //synapse related variables:
      // user defined parameters, initialized via pre_run_hook() or calibrate()
  {%- for param_name, param_declaration in synapse_info["Parameters"].items() %}
  std::vector< double > {{param_name}};
  {%- endfor %}

      // states
    {%- for pure_variable_name, variable_info in synapse_info["States"].items() %}
        {%- set variable = variable_info["ASTVariable"] %}
        {%- set rhs_expression = variable_info["rhs_expression"] %}
  std::vector<{{ render_variable_type(variable) }}> {{ variable.name }} = {};
    {%- endfor %}

    // user declared internals in order they were declared, initialized via pre_run_hook() or calibrate()
  {%- for internal_name, internal_declaration in synapse_info["Internals"].items() %}
  std::vector< double > {{internal_name}};
  {%- endfor %}

  {%- for in_function_declaration in synapse_info["InFunctionDeclarationsVars"] %}
      {%- for variable in declarations.get_variables(in_function_declaration) %}
  std::vector<{{declarations.print_variable_type(variable)}}> {{variable.get_symbol_name()}} = {};
      {%- endfor %}
  {%- endfor %}

  {%- for convolution, convolution_info in synapse_info["convolutions"].items() %}
  {%- for state_variable_name, state_variable_info in convolution_info["analytic_solution"]["propagators"].items()%}
  std::vector< double > {{state_variable_name}};
  {%- endfor %}
  {%- endfor %}

  {%- for convolution, convolution_info in synapse_info["convolutions"].items() %}
  {%- for state_variable_name, state_variable_info in convolution_info["analytic_solution"]["kernel_states"].items()%}
  std::vector< double > {{state_variable_name}};
  {%- endfor %}
  {%- endfor %}

  {%- for inline_name, inline in synapse_info["Inlines"].items() %}
  std::vector< double > {{inline_name}};
  {%- endfor %}

    const bool& self_spikes;

public:
  // constructor, destructor
  {{receptor_name}}{{cm_unique_suffix}}_con_{{synapse_name}}(bool& global_self_spikes) : self_spikes(global_self_spikes) {};
  ~{{receptor_name}}{{cm_unique_suffix}}_con_{{synapse_name}}(){};

  void new_receptor(std::size_t comp_ass, const long syn_index);
  void new_receptor(std::size_t comp_ass, const long syn_index, const DictionaryDatum& receptor_params);

  //number of receptors
  std::size_t neuron_{{ receptor_name }}_receptor_count = 0;

  std::vector< size_t > compartment_association = {};

  // numerical integration step
    {%- with  %}
    {%- set conc_dep = set(receptor_info["Dependencies"]["concentrations"]).union(synapse_info["Dependencies"]["concentrations"])%}
    {%- set rec_dep = set(receptor_info["Dependencies"]["receptors"]).union(synapse_info["Dependencies"]["receptors"])%}
    {%- set chan_dep = set(receptor_info["Dependencies"]["channels"]).union(synapse_info["Dependencies"]["channels"])%}
    {%- set con_in_dep = set(receptor_info["Dependencies"]["continuous"]).union(synapse_info["Dependencies"]["continuous"])%}
  void f_numstep(const std::vector< double >& v_comp, const long& lag {% for ode in conc_dep %}, const std::vector< double >& {{ode.lhs.name}}{% endfor %}{% if rec_dep|length %}
                        {% endif %}{% for inline in rec_dep %}, const std::vector< double >& {{inline.variable_name}}{% endfor %}{% if chan_dep|length %}
                        {% endif %}{% for inline in chan_dep %}, const std::vector< double >& {{inline.variable_name}}{% endfor %}{% if con_in_dep|length %}
                        {% endif %}{% for inline in con_in_dep %}, const std::vector< double >& {{inline.variable_name}}{% endfor %}
                        , std::vector< double >& i_val, std::vector< double >& g_val);
    {%- endwith %}

    void f_update();
    void f_self_spike();

  void  postsynaptic_synaptic_processing();

  // calibration
{%- if nest_version.startswith("v2") or nest_version.startswith("v3.1") or nest_version.startswith("v3.2") or nest_version.startswith("v3.3") %}
  void calibrate();
{%- else %}
  void pre_run_hook();
{%- endif %}
  void append_recordables(std::map< Name, double* >* recordables, const long compartment_idx);
  void set_buffer_ptr( std::vector< RingBuffer >& syn_buffers )
  {
    for(std::size_t i = 0; i < syn_idx.size(); i++){
        {{receptor_info["buffer_name"]}}_.push_back(&(syn_buffers[syn_idx[i]]));
    }
  };

  // function declarations
  {%- for function in receptor_info["Functions"] %}
  #pragma omp declare simd
    __attribute__((always_inline)) inline {{ function_declaration.FunctionDeclaration(function, pass_by_reference = true) -}};

  {% endfor %}

    // root_inline getter
    void get_currents_per_compartment(std::vector< double >& compartment_to_current);

    std::vector< double > distribute_shared_vector(std::vector< double > shared_vector);

    void get_history__( double t1,
    double t2,
    std::deque< histentry >::iterator* start,
    std::deque< histentry >::iterator* finish );


};

{% endfor -%}
{% endfor %}
{% endwith -%}


////////////////////////////////////////////////// continuous inputs

{%- with %}
{%- for continuous_name, continuous_info in con_in_info.items() %}

class {{continuous_name}}{{cm_unique_suffix}}{
private:
  // global continuous input index
  std::vector< long > continuous_idx = {};

  // user defined parameters, initialized via pre_run_hook() or calibrate()
  {%- for param_name, param_declaration in continuous_info["Parameters"].items() %}
  std::vector< double > {{param_name}};
  {%- endfor %}

      // states
    {%- for pure_variable_name, variable_info in continuous_info["States"].items() %}
        {%- set variable = variable_info["ASTVariable"] %}
        {%- set rhs_expression = variable_info["rhs_expression"] %}
  std::vector<{{ render_variable_type(variable) }}> {{ variable.name }} = {}
        };
    {%- endfor %}

  // recordable inlines
    {%- for variable_info in continuous_info["SecondaryInlineExpressions"] %}
        {%- if variable_info.is_recordable %}
        {%- set variable = variable_info.variable_name %}
        {%- set rhs_expression = variable_info.expression %}
    std::vector< double > {{ variable }} = {};
        {%- endif %}
    {%- endfor %}

  // propagators, initialized via pre_run_hook() or calibrate()
  {%- for convolution, convolution_info in continuous_info["convolutions"].items() %}
  {%- for state_variable_name, state_variable_info in convolution_info["analytic_solution"]["propagators"].items()%}
  std::vector< double > {{state_variable_name}};
  {%- endfor %}
  {%- endfor %}

  // kernel state variables, initialized via pre_run_hook() or calibrate()
  {%- for convolution, convolution_info in continuous_info["convolutions"].items() %}
  {%- for state_variable_name, state_variable_info in convolution_info["analytic_solution"]["kernel_states"].items()%}
  std::vector< double > {{state_variable_name}};
  {%- endfor %}
  {%- endfor %}

  std::vector< double > i_tot_{{continuous_name}} = {};

  // user declared internals in order they were declared, initialized via pre_run_hook() or calibrate()
  {%- for internal_name, internal_declaration in continuous_info["Internals"] %}
  std::vector< double > {{internal_name}};
  {%- endfor %}



  // continuous buffer
  {% for port_name, port_info in continuous_info["Continuous"].items() %}
  std::vector< RingBuffer* > {{ port_name }}_;
  {% endfor %}

    const bool& self_spikes;

public:
  // constructor, destructor
  {{continuous_name}}{{cm_unique_suffix}}(bool& global_self_spikes) : self_spikes(global_self_spikes) {};
  ~{{continuous_name}}{{cm_unique_suffix}}(){};

  void new_continuous_input(std::size_t comp_ass, const long con_in_index);
  void new_continuous_input(std::size_t comp_ass, const long con_in_index, const DictionaryDatum& con_in_params);

  //number of continuous inputs
  std::size_t neuron_{{ continuous_name }}_continuous_input_count = 0;

  std::vector< size_t > compartment_association = {};

  // numerical integration step
  void f_numstep(const std::vector< double >& v_comp, const long& lag {% for ode in continuous_info["Dependencies"]["concentrations"] %}, const std::vector< double >& {{ode.lhs.name}}{% endfor %}{% if continuous_info["Dependencies"]["receptors"]|length %}
                        {% endif %}{% for inline in continuous_info["Dependencies"]["receptors"] %}, const std::vector< double >& {{inline.variable_name}}{% endfor %}{% if continuous_info["Dependencies"]["channels"]|length %}
                        {% endif %}{% for inline in continuous_info["Dependencies"]["channels"] %}, const std::vector< double >& {{inline.variable_name}}{% endfor %}{% if continuous_info["Dependencies"]["continuous"]|length %}
                        {% endif %}{% for inline in continuous_info["Dependencies"]["continuous"] %}, const std::vector< double >& {{inline.variable_name}}{% endfor %}
                        , std::vector< double >& i_val, std::vector< double >& g_val);

    void f_update();
    void f_self_spike();

  // calibration
{%- if nest_version.startswith("v2") or nest_version.startswith("v3.1") or nest_version.startswith("v3.2") or nest_version.startswith("v3.3") %}
  void calibrate();
{%- else %}
  void pre_run_hook();
{%- endif %}
  void append_recordables(std::map< Name, double* >* recordables, const long compartment_idx);
  void set_buffer_ptr( std::vector< RingBuffer >& continuous_buffers )
  {
    for(std::size_t i = 0; i < continuous_idx.size(); i++){
        {% for port_name, port_info in continuous_info["Continuous"].items() %}
        {{port_name}}_.push_back(&(continuous_buffers[continuous_idx[i]]));
        {% endfor %}
    }
  };

  // function declarations
  {%- for function in continuous_info["Functions"] %}
    #pragma omp declare simd
    __attribute__((always_inline)) inline {{ function_declaration.FunctionDeclaration(function, pass_by_reference = true) -}};

  {% endfor %}

    // root_inline getter
    void get_currents_per_compartment(std::vector< double >& compartment_to_current);

    std::vector< double > distribute_shared_vector(std::vector< double > shared_vector);

};

{% endfor -%}
{% endwith -%}


///////////////////////////////////////////// currents

{%- set channel_suffix = "_chan_" %}
{%- set concentration_suffix = "_conc_" %}
{%- set receptor_suffix = "_syn_" %}
{%- set continuous_suffix = "_con_in_" %}

class NeuronCurrents{{cm_unique_suffix}} {
private:

    bool initialized = false;
  //mechanisms
  // ion channels
  {%- for ion_channel_name, channel_info in chan_info.items() %}
  {{ion_channel_name}}{{cm_unique_suffix}} {{ion_channel_name}}{{channel_suffix}};

  std::vector< double > i_vals_{{ion_channel_name}}{{channel_suffix}};
  std::vector< double > g_vals_{{ion_channel_name}}{{channel_suffix}};
  {% endfor -%}

  // concentrations
  {%- for concentration_name, concentration_info in conc_info.items() %}
  {{concentration_name}}{{cm_unique_suffix}} {{concentration_name}}{{concentration_suffix}};
  {% endfor -%}

  // receptors
  {%- for receptor_name, receptor_info in recs_info.items() %}
  {{receptor_name}}{{cm_unique_suffix}} {{receptor_name}}{{receptor_suffix}};

  std::vector< double > i_vals_{{receptor_name}}{{receptor_suffix}};
  std::vector< double > g_vals_{{receptor_name}}{{receptor_suffix}};
  {% endfor -%}

  // receptors with synapses
{%- for receptor_name, receptor_info in recs_info.items() %}
    {%- for synapse_name, synapse_info in syns_info.items() %}
  {{receptor_name}}{{cm_unique_suffix}}_con_{{synapse_name}} {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}};

  std::vector< double > i_vals_{{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}};
  std::vector< double > g_vals_{{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}};
    {% endfor -%}
{% endfor -%}

  // continuous inputs
  {%- for continuous_name, continuous_info in con_in_info.items() %}
  {{continuous_name}}{{cm_unique_suffix}} {{continuous_name}}{{continuous_suffix}};

  std::vector< double > i_vals_{{continuous_name}}{{continuous_suffix}};
  std::vector< double > g_vals_{{continuous_name}}{{continuous_suffix}};
  {% endfor -%}

  //number of compartments
  std::size_t compartment_number = 0;

  //interdependency shared reference vectors and consecutive area vectors
  // ion channels
  {%- for ion_channel_name, channel_info in chan_info.items() %}
  std::vector < double > {{ion_channel_name}}{{channel_suffix}}_shared_current;
  std::vector < std::pair< std::size_t, int > > {{ion_channel_name}}{{channel_suffix}}_con_area;
  {% endfor -%}

  // concentrations
  {%- for concentration_name, concentration_info in conc_info.items() %}
  std::vector < double > {{concentration_name}}{{concentration_suffix}}_shared_concentration;
  std::vector < std::pair< std::size_t, int > > {{concentration_name}}{{concentration_suffix}}_con_area;
  {% endfor -%}

  // receptors
  {%- for receptor_name, receptor_info in recs_info.items() %}
  std::vector < double > {{receptor_name}}{{receptor_suffix}}_shared_current;
  std::vector < std::pair< std::size_t, int > > {{receptor_name}}{{receptor_suffix}}_con_area;
  {% endfor -%}

  // receptors with synapses
  {%- for receptor_name, receptor_info in recs_info.items() %}
  {%- for synapse_name, synapse_info in syns_info.items() %}
  std::vector < double > {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}_shared_current;
  std::vector < std::pair< std::size_t, int > > {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}_con_area;
  {% endfor -%}
  {% endfor -%}

// continuous inputs
  {%- for continuous_name, continuous_info in con_in_info.items() %}
  std::vector < double > {{continuous_name}}{{continuous_suffix}}_shared_current;
  std::vector < std::pair< std::size_t, int > > {{continuous_name}}{{continuous_suffix}}_con_area;
  {% endfor -%}

  //compartment gi states
  std::vector< double >* g_vals_comp;
  std::vector< double >* i_vals_comp;

public:
  NeuronCurrents{{cm_unique_suffix}}(std::vector< double >* g_vals, std::vector< double >* i_vals, bool* self_spikes)
    : g_vals_comp(g_vals)
    , i_vals_comp(i_vals)
  {%- for ion_channel_name, channel_info in chan_info.items() %}
    , {{ion_channel_name}}{{channel_suffix}}( {{ion_channel_name}}{{cm_unique_suffix}}( *self_spikes ) )
  {% endfor -%}
  {%- for concentration_name, concentration_info in conc_info.items() %}
    , {{concentration_name}}{{concentration_suffix}}( {{concentration_name}}{{cm_unique_suffix}}( *self_spikes ) )
  {% endfor -%}
  {%- for receptor_name, receptor_info in recs_info.items() %}
    , {{receptor_name}}{{receptor_suffix}}( {{receptor_name}}{{cm_unique_suffix}}( *self_spikes ) )
  {% endfor -%}
  {%- for receptor_name, receptor_info in recs_info.items() %}
    {%- for synapse_name, synapse_info in syns_info.items() %}
    , {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}( {{receptor_name}}{{cm_unique_suffix}}_con_{{synapse_name}}( *self_spikes ) )
    {% endfor -%}
  {% endfor -%}
  {%- for continuous_name, continuous_info in con_in_info.items() %}
    , {{continuous_name}}{{continuous_suffix}}( {{continuous_name}}{{cm_unique_suffix}}( *self_spikes ) )
  {% endfor -%}
    {};
  ~NeuronCurrents{{cm_unique_suffix}}(){};

{%- if nest_version.startswith("v2") or nest_version.startswith("v3.1") or nest_version.startswith("v3.2") or nest_version.startswith("v3.3") %}
  void calibrate() {
{%- else %}
  void pre_run_hook() {
{%- endif %}
    if(!initialized){
    // initialization of ion channels
{%- if nest_version.startswith("v2") or nest_version.startswith("v3.1") or nest_version.startswith("v3.2") or nest_version.startswith("v3.3") %}
    {%- for ion_channel_name, channel_info in chan_info.items() %}
    {{ion_channel_name}}{{channel_suffix}}.calibrate();
    {% endfor -%}
    {%- for concentration_name, concentration_info in conc_info.items() %}
    {{concentration_name}}{{concentration_suffix}}.calibrate();
    {% endfor -%}
    {%- for receptor_name, receptor_info in recs_info.items() %}
    {{receptor_name}}{{receptor_suffix}}.calibrate();
    {% endfor -%}
    {%- for receptor_name, receptor_info in recs_info.items() %}
    {%- for synapse_name, synapse_info in syns_info.items() %}
    {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}.calibrate();
    {% endfor -%}
    {% endfor -%}
    {%- for continuous_name, continuous_info in con_in_info.items() %}
    {{continuous_name}}{{continuous_suffix}}.calibrate();
    {% endfor -%}
{%- else %}
    {%- for ion_channel_name, channel_info in chan_info.items() %}
    {{ion_channel_name}}{{channel_suffix}}.pre_run_hook();
    {% endfor -%}
    {%- for concentration_name, concentration_info in conc_info.items() %}
    {{concentration_name}}{{concentration_suffix}}.pre_run_hook();
    {% endfor -%}
    {%- for receptor_name, receptor_info in recs_info.items() %}
    {{receptor_name}}{{receptor_suffix}}.pre_run_hook();
    {% endfor -%}
    {%- for receptor_name, receptor_info in recs_info.items() %}
    {%- for synapse_name, synapse_info in syns_info.items() %}
    {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}.pre_run_hook();
    {% endfor -%}
    {% endfor -%}
    {%- for continuous_name, continuous_info in con_in_info.items() %}
    {{continuous_name}}{{continuous_suffix}}.pre_run_hook();
    {% endfor -%}
{%- endif %}

    int con_end_index;
    {%- for ion_channel_name, channel_info in chan_info.items() %}
    if({{ion_channel_name}}{{channel_suffix}}.neuron_{{ ion_channel_name }}_channel_count){
        con_end_index = int({{ion_channel_name}}{{channel_suffix}}.compartment_association[0]);
        {{ion_channel_name}}{{channel_suffix}}_con_area.push_back(std::pair< std::size_t, int >(0, con_end_index));
    }
    for(std::size_t chan_id = 1; chan_id < {{ion_channel_name}}{{channel_suffix}}.neuron_{{ ion_channel_name }}_channel_count; chan_id++){
        if(!({{ion_channel_name}}{{channel_suffix}}.compartment_association[chan_id] == size_t(int(chan_id) + con_end_index))){
            con_end_index = int({{ion_channel_name}}{{channel_suffix}}.compartment_association[chan_id]) - int(chan_id);
            {{ion_channel_name}}{{channel_suffix}}_con_area.push_back(std::pair< std::size_t, int >(chan_id, con_end_index));
        }
    }
    {% endfor -%}
    {%- for concentration_name, concentration_info in conc_info.items() %}
    if({{concentration_name}}{{concentration_suffix}}.neuron_{{ concentration_name }}_concentration_count){
        con_end_index = int({{concentration_name}}{{concentration_suffix}}.compartment_association[0]);
        {{concentration_name}}{{concentration_suffix}}_con_area.push_back(std::pair< std::size_t, int >(0, con_end_index));
    }
    for(std::size_t conc_id = 0; conc_id < {{concentration_name}}{{concentration_suffix}}.neuron_{{ concentration_name }}_concentration_count; conc_id++){
        if(!({{concentration_name}}{{concentration_suffix}}.compartment_association[conc_id] == size_t(int(conc_id) + con_end_index))){
            con_end_index = int({{concentration_name}}{{concentration_suffix}}.compartment_association[conc_id]) - int(conc_id);
            {{concentration_name}}{{concentration_suffix}}_con_area.push_back(std::pair< std::size_t, int >(conc_id, con_end_index));
        }
    }
    {% endfor -%}
    {%- for receptor_name, receptor_info in recs_info.items() %}
    if({{receptor_name}}{{receptor_suffix}}.neuron_{{ receptor_name }}_receptor_count){
        con_end_index = int({{receptor_name}}{{receptor_suffix}}.compartment_association[0]);
        {{receptor_name}}{{receptor_suffix}}_con_area.push_back(std::pair< std::size_t, int >(0, con_end_index));
    }
    for(std::size_t syn_id = 0; syn_id < {{receptor_name}}{{receptor_suffix}}.neuron_{{ receptor_name }}_receptor_count; syn_id++){
        if(!({{receptor_name}}{{receptor_suffix}}.compartment_association[syn_id] == size_t(int(syn_id) + con_end_index))){
            con_end_index = int({{receptor_name}}{{receptor_suffix}}.compartment_association[syn_id]) - int(syn_id);
            {{receptor_name}}{{receptor_suffix}}_con_area.push_back(std::pair< std::size_t, int >(syn_id, con_end_index));
        }
    }
    {% endfor -%}
    {%- for receptor_name, receptor_info in recs_info.items() %}
    {%- for synapse_name, synapse_info in syns_info.items() %}
    if({{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}.neuron_{{ receptor_name }}_receptor_count){
        con_end_index = int({{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}.compartment_association[0]);
        {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}_con_area.push_back(std::pair< std::size_t, int >(0, con_end_index));
    }
    for(std::size_t syn_id = 0; syn_id < {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}.neuron_{{ receptor_name }}_receptor_count; syn_id++){
        if(!({{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}.compartment_association[syn_id] == size_t(int(syn_id) + con_end_index))){
            con_end_index = int({{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}.compartment_association[syn_id]) - int(syn_id);
            {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}_con_area.push_back(std::pair< std::size_t, int >(syn_id, con_end_index));
        }
    }
    {% endfor -%}
    {% endfor -%}
    {%- for continuous_name, continuous_info in con_in_info.items() %}
    if({{continuous_name}}{{continuous_suffix}}.neuron_{{ continuous_name }}_continuous_input_count){
        con_end_index = int({{continuous_name}}{{continuous_suffix}}.compartment_association[0]);
        {{continuous_name}}{{continuous_suffix}}_con_area.push_back(std::pair< std::size_t, int >(0, con_end_index));
    }
    for(std::size_t cont_id = 0; cont_id < {{continuous_name}}{{continuous_suffix}}.neuron_{{ continuous_name }}_continuous_input_count; cont_id++){
        if(!({{continuous_name}}{{continuous_suffix}}.compartment_association[cont_id] == size_t(int(cont_id) + con_end_index))){
            con_end_index = int({{continuous_name}}{{continuous_suffix}}.compartment_association[cont_id]) - (cont_id);
            {{continuous_name}}{{continuous_suffix}}_con_area.push_back(std::pair< std::size_t, int >(cont_id, con_end_index));
        }
    }
    {% endfor -%}
    initialized = true;
  }
  };

  void add_mechanism( const std::string& type, const std::size_t compartment_id, const long multi_mech_index = 0)
  {
    bool mech_found = false;
  {%- for ion_channel_name, channel_info in chan_info.items() %}
    if ( type == "{{ion_channel_name}}" )
    {
      {{ion_channel_name}}{{channel_suffix}}.new_channel(compartment_id);
      i_vals_{{ion_channel_name}}{{channel_suffix}}.push_back(0);
      g_vals_{{ion_channel_name}}{{channel_suffix}}.push_back(0);
      mech_found = true;
    }
  {% endfor -%}

  {%- for concentration_name, concentration_info in conc_info.items() %}
    if ( type == "{{concentration_name}}" )
    {
      {{concentration_name}}{{concentration_suffix}}.new_concentration(compartment_id);
      mech_found = true;
    }
  {% endfor -%}

  {%- for receptor_name, receptor_info in recs_info.items() %}
    if ( type == "{{receptor_name}}" )
    {
      {{receptor_name}}{{receptor_suffix}}.new_receptor(compartment_id, multi_mech_index);
      i_vals_{{receptor_name}}{{receptor_suffix}}.push_back(0);
      g_vals_{{receptor_name}}{{receptor_suffix}}.push_back(0);
      mech_found = true;
    }
  {% endfor -%}

  {%- for receptor_name, receptor_info in recs_info.items() %}
  {%- for synapse_name, synapse_info in syns_info.items() %}
    if ( type == "{{receptor_name}}_{{synapse_name}}" )
    {
      {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}.new_receptor(compartment_id, multi_mech_index);
      i_vals_{{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}.push_back(0);
      g_vals_{{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}.push_back(0);
      mech_found = true;
    }
  {% endfor -%}
  {% endfor -%}

  {%- for continuous_name, continuous_info in con_in_info.items() %}
    if ( type == "{{continuous_name}}" )
    {
      {{continuous_name}}{{continuous_suffix}}.new_continuous_input(compartment_id, multi_mech_index);
      i_vals_{{continuous_name}}{{continuous_suffix}}.push_back(0);
      g_vals_{{continuous_name}}{{continuous_suffix}}.push_back(0);
      mech_found = true;
    }
  {% endfor -%}

    if(!mech_found)
    {
      throw BadProperty( type + " mechanism does not exist." );
      assert( false );
    }
  };

  void add_mechanism( const std::string& type, const std::size_t compartment_id, const DictionaryDatum& mechanism_params, const long multi_mech_index = 0)
  {
    bool mech_found = false;
  {%- for ion_channel_name, channel_info in chan_info.items() %}
    if ( type == "{{ion_channel_name}}" )
    {
      {{ion_channel_name}}{{channel_suffix}}.new_channel(compartment_id, mechanism_params);
      i_vals_{{ion_channel_name}}{{channel_suffix}}.push_back(0);
      g_vals_{{ion_channel_name}}{{channel_suffix}}.push_back(0);
      mech_found = true;
    }
  {% endfor -%}

  {%- for concentration_name, concentration_info in conc_info.items() %}
    if ( type == "{{concentration_name}}" )
    {
      {{concentration_name}}{{concentration_suffix}}.new_concentration(compartment_id, mechanism_params);
      mech_found = true;
    }
  {% endfor -%}

  {%- for receptor_name, receptor_info in recs_info.items() %}
    if ( type == "{{receptor_name}}" )
    {
      {{receptor_name}}{{receptor_suffix}}.new_receptor(compartment_id, multi_mech_index, mechanism_params);
      i_vals_{{receptor_name}}{{receptor_suffix}}.push_back(0);
      g_vals_{{receptor_name}}{{receptor_suffix}}.push_back(0);
      mech_found = true;
    }
  {% endfor -%}

  {%- for receptor_name, receptor_info in recs_info.items() %}
  {%- for synapse_name, synapse_info in syns_info.items() %}
    if ( type == "{{receptor_name}}_{{synapse_name}}" )
    {
      {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}.new_receptor(compartment_id, multi_mech_index, mechanism_params);
      i_vals_{{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}.push_back(0);
      g_vals_{{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}.push_back(0);
      mech_found = true;
    }
  {% endfor -%}
  {% endfor -%}

  {%- for continuous_name, continuous_info in con_in_info.items() %}
    if ( type == "{{continuous_name}}" )
    {
      {{continuous_name}}{{continuous_suffix}}.new_continuous_input(compartment_id, multi_mech_index, mechanism_params);
      i_vals_{{continuous_name}}{{continuous_suffix}}.push_back(0);
      g_vals_{{continuous_name}}{{continuous_suffix}}.push_back(0);
      mech_found = true;
    }
  {% endfor -%}
    if(!mech_found)
    {
      throw BadProperty( type + " mechanism does not exist." );
      assert( false );
    }
  };

  void add_compartment(){
    {%- for ion_channel_name, channel_info in chan_info.items() %}
    this->add_mechanism("{{ ion_channel_name }}", compartment_number);
    {% endfor -%}

    {%- for concentration_name, concentration_info in conc_info.items() %}
    this->add_mechanism("{{ concentration_name }}", compartment_number);
    {% endfor -%}

    compartment_number++;

    i_vals_comp->push_back(0);
    g_vals_comp->push_back(0);

    {%- for ion_channel_name, channel_info in chan_info.items() %}
    this->{{ion_channel_name}}{{channel_suffix}}_shared_current.push_back(0.0);
    {% endfor -%}

    {%- for concentration_name, concentration_info in conc_info.items() %}
    this->{{concentration_name}}{{concentration_suffix}}_shared_concentration.push_back(0.0);
    {% endfor -%}

    {%- for receptor_name, receptor_info in recs_info.items() %}
    this->{{receptor_name}}{{receptor_suffix}}_shared_current.push_back(0.0);
    {% endfor -%}

    {%- for receptor_name, receptor_info in recs_info.items() %}
    {%- for synapse_name, synapse_info in syns_info.items() %}
    this->{{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}_shared_current.push_back(0.0);
    {% endfor -%}
    {% endfor -%}

    {%- for continuous_name, continuous_info in con_in_info.items() %}
    this->{{continuous_name}}{{continuous_suffix}}_shared_current.push_back(0.0);
    {% endfor -%}

  };

  void add_compartment(const DictionaryDatum& compartment_params){
    {%- for ion_channel_name, channel_info in chan_info.items() %}
    this->add_mechanism("{{ ion_channel_name }}", compartment_number, compartment_params);
    {% endfor -%}

    {%- for concentration_name, concentration_info in conc_info.items() %}
    this->add_mechanism("{{ concentration_name }}", compartment_number, compartment_params);
    {% endfor -%}

    compartment_number++;

    i_vals_comp->push_back(0);
    g_vals_comp->push_back(0);

    {%- for ion_channel_name, channel_info in chan_info.items() %}
    this->{{ion_channel_name}}{{channel_suffix}}_shared_current.push_back(0.0);
    {% endfor -%}

    {%- for concentration_name, concentration_info in conc_info.items() %}
    this->{{concentration_name}}{{concentration_suffix}}_shared_concentration.push_back(0.0);
    {% endfor -%}

    {%- for receptor_name, receptor_info in recs_info.items() %}
    this->{{receptor_name}}{{receptor_suffix}}_shared_current.push_back(0.0);
    {% endfor -%}

    {%- for receptor_name, receptor_info in recs_info.items() %}
    {%- for synapse_name, synapse_info in syns_info.items() %}
    this->{{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}_shared_current.push_back(0.0);
    {% endfor -%}
    {% endfor -%}

    {%- for continuous_name, continuous_info in con_in_info.items() %}
    this->{{continuous_name}}{{continuous_suffix}}_shared_current.push_back(0.0);
    {% endfor -%}
  };

  void add_receptor_info( ArrayDatum& ad, long compartment_index )
  {
    {%- for receptor_name, receptor_info in recs_info.items() %}
    for( std::size_t syn_it = 0; syn_it != {{receptor_name}}{{receptor_suffix}}.neuron_{{receptor_name}}_receptor_count; syn_it++)
    {
      DictionaryDatum dd = DictionaryDatum( new Dictionary );
      {{ write_in_dictionary.WriteInDictionary("dd", "long", "names::receptor_idx", "syn_it") }}
      {{ write_in_dictionary.WriteInDictionary("dd", "long", "names::comp_idx", "compartment_index") }}
      {{ write_in_dictionary.WriteInDictionary("dd", "std::string", "names::receptor_type", "\"" + receptor_name + "\"") }}
      ad.push_back( dd );
    }
    {% endfor -%}

    {%- for receptor_name, receptor_info in recs_info.items() %}
    {%- for synapse_name, synapse_info in syns_info.items() %}
    for( std::size_t syn_it = 0; syn_it != {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}.neuron_{{receptor_name}}_receptor_count; syn_it++)
    {
      DictionaryDatum dd = DictionaryDatum( new Dictionary );
      {{ write_in_dictionary.WriteInDictionary("dd", "long", "names::receptor_idx", "syn_it") }}
      {{ write_in_dictionary.WriteInDictionary("dd", "long", "names::comp_idx", "compartment_index") }}
      {{ write_in_dictionary.WriteInDictionary("dd", "std::string", "names::receptor_type", "\"" + receptor_name +"_"+synapse_name + "\"") }}
      ad.push_back( dd );
    }
    {% endfor -%}
    {% endfor -%}

{%- for continuous_name, continuous_info in con_in_info.items() %}
    for( std::size_t con_it = 0; con_it != {{continuous_name}}{{continuous_suffix}}.neuron_{{continuous_name}}_continuous_input_count; con_it++)
    {
      DictionaryDatum dd = DictionaryDatum( new Dictionary );
{{ write_in_dictionary.WriteInDictionary("dd", "long", "names::receptor_idx", "con_it") }}
{{ write_in_dictionary.WriteInDictionary("dd", "long", "names::comp_idx", "compartment_index") }}
{{ write_in_dictionary.WriteInDictionary("dd", "std::string", "names::receptor_type", "\"" + continuous_name + "\"") }}
      ad.push_back( dd );
    }
    {% endfor -%}
  };

  void set_buffers( std::vector< RingBuffer >& buffers)
  {
    // spike and continuous buffers for receptors and continuous inputs
    {%- for receptor_name, receptor_info in recs_info.items() %}
      {{receptor_name}}{{ receptor_suffix }}.set_buffer_ptr( buffers );
    {% endfor -%}
    {%- for receptor_name, receptor_info in recs_info.items() %}
    {%- for synapse_name, synapse_info in syns_info.items() %}
      {{receptor_name}}{{ receptor_suffix }}_con_{{synapse_name}}.set_buffer_ptr( buffers );
    {% endfor -%}
    {% endfor -%}
    {%- for continuous_name, continuous_info in con_in_info.items() %}
      {{continuous_name}}{{ continuous_suffix }}.set_buffer_ptr( buffers );
    {% endfor -%}
  };

  std::map< Name, double* > get_recordables( const long compartment_idx )
  {
    std::map< Name, double* > recordables;

    // append ion channel state variables to recordables
    {%- for ion_channel_name, channel_info in chan_info.items() %}
    {{ion_channel_name}}{{channel_suffix}}.append_recordables( &recordables, compartment_idx );
    {% endfor %}

    // append concentration state variables to recordables
    {%- for concentration_name, concentration_info in conc_info.items() %}
    {{concentration_name}}{{concentration_suffix}}.append_recordables( &recordables, compartment_idx );
    {% endfor %}

    // append receptor state variables to recordables
    {%- for receptor_name, receptor_info in recs_info.items() %}
    {{receptor_name}}{{receptor_suffix}}.append_recordables( &recordables, compartment_idx );
    {% endfor %}

    // append receptor with synapse state variables to recordables
    {%- for receptor_name, receptor_info in recs_info.items() %}
    {%- for synapse_name, synapse_info in syns_info.items() %}
    {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}.append_recordables( &recordables, compartment_idx );
    {% endfor %}
    {% endfor %}

    // append continuous input state variables to recordables
    {%- for continuous_name, continuous_info in con_in_info.items() %}
    {{continuous_name}}{{continuous_suffix}}.append_recordables( &recordables, compartment_idx );
    {% endfor %}

    return recordables;
  };

  void f_numstep( const std::vector< double >& v_comp_vec, const long& lag )
  {
    std::fill(g_vals_comp->begin(), g_vals_comp->end(), 0.0);
    std::fill(i_vals_comp->begin(), i_vals_comp->end(), 0.0);

{%- for receptor_name, receptor_info in recs_info.items() %}
    {{receptor_name}}{{receptor_suffix}}.get_currents_per_compartment({{receptor_name}}{{receptor_suffix}}_shared_current);
{% endfor %}
{%- for receptor_name, receptor_info in recs_info.items() %}
    {%- for synapse_name, synapse_info in syns_info.items() %}
    {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}.get_currents_per_compartment({{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}_shared_current);
    for(size_t i = 0; i < {{receptor_name}}{{receptor_suffix}}_shared_current.size(); i++){
        {{receptor_name}}{{receptor_suffix}}_shared_current[i] += {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}_shared_current[i];
    }
    {% endfor %}
{% endfor %}
{%- for continuous_name, continuous_info in con_in_info.items() %}
    {{continuous_name}}{{continuous_suffix}}.get_currents_per_compartment({{continuous_name}}{{continuous_suffix}}_shared_current);
{% endfor %}
{%- for concentration_name, concentration_info in conc_info.items() %}
    {{ concentration_name }}{{concentration_suffix}}.get_concentrations_per_compartment({{concentration_name}}{{concentration_suffix}}_shared_concentration);
{% endfor -%}
{%- for ion_channel_name, channel_info in chan_info.items() %}
    {{ion_channel_name}}{{channel_suffix}}.get_currents_per_compartment({{ion_channel_name}}{{channel_suffix}}_shared_current);
{% endfor -%}

    {%- for concentration_name, concentration_info in conc_info.items() %}
    // computation of {{ concentration_name }} concentration
    {{ concentration_name }}{{concentration_suffix}}.f_numstep({{ concentration_name }}{{concentration_suffix}}.distribute_shared_vector(v_comp_vec){% for ode in concentration_info["Dependencies"]["concentrations"] %}, {{ concentration_name }}{{concentration_suffix}}.distribute_shared_vector({{ode.lhs.name}}{{concentration_suffix}}_shared_concentration){% endfor %}{% if concentration_info["Dependencies"]["receptors"]|length %}
                        {% endif %}{% for inline in concentration_info["Dependencies"]["receptors"] %}, {{ concentration_name }}{{concentration_suffix}}.distribute_shared_vector({{inline.variable_name}}{{receptor_suffix}}_shared_current){% endfor %}{% if concentration_info["Dependencies"]["channels"]|length %}
                        {% endif %}{% for inline in concentration_info["Dependencies"]["channels"] %}, {{ concentration_name }}{{concentration_suffix}}.distribute_shared_vector({{inline.variable_name}}{{channel_suffix}}_shared_current){% endfor %}{% if concentration_info["Dependencies"]["continuous"]|length %}
                        {% endif %}{% for inline in concentration_info["Dependencies"]["continuous"] %}, {{ concentration_name }}{{concentration_suffix}}.distribute_shared_vector({{inline.variable_name}}{{continuous_suffix}}_shared_current){% endfor %});

    {% endfor -%}
    std::size_t con_area_count;

    {%- for ion_channel_name, channel_info in chan_info.items() %}
    // contribution of {{ion_channel_name}} channel
    {{ion_channel_name}}{{channel_suffix}}.f_numstep({{ion_channel_name}}{{channel_suffix}}.distribute_shared_vector(v_comp_vec){% for ode in channel_info["Dependencies"]["concentrations"] %}, {{ion_channel_name}}{{channel_suffix}}.distribute_shared_vector({{ode.lhs.name}}{{concentration_suffix}}_shared_concentration){% endfor %}{% if channel_info["Dependencies"]["receptors"]|length %}
        {% endif %}{% for inline in channel_info["Dependencies"]["receptors"] %}, {{ion_channel_name}}{{channel_suffix}}.distribute_shared_vector({{inline.variable_name}}{{receptor_suffix}}_shared_current){% endfor %}{% if channel_info["Dependencies"]["channels"]|length %}
        {% endif %}{% for inline in channel_info["Dependencies"]["channels"] %}, {{ion_channel_name}}{{channel_suffix}}.distribute_shared_vector({{inline.variable_name}}{{channel_suffix}}_shared_current){% endfor %}{% if channel_info["Dependencies"]["continuous"]|length %}
        {% endif %}{% for inline in channel_info["Dependencies"]["continuous"] %}, {{ion_channel_name}}{{channel_suffix}}.distribute_shared_vector({{inline.variable_name}}{{continuous_suffix}}_shared_current){% endfor %}
        , i_vals_{{ion_channel_name}}{{channel_suffix}}, g_vals_{{ion_channel_name}}{{channel_suffix}});

    con_area_count = {{ion_channel_name}}{{channel_suffix}}_con_area.size();
    if(con_area_count > 0){
        for(std::size_t con_area_index = 0; con_area_index < con_area_count-1; con_area_index++){
            std::size_t con_area = {{ion_channel_name}}{{channel_suffix}}_con_area[con_area_index].first;
            std::size_t next_con_area = {{ion_channel_name}}{{channel_suffix}}_con_area[con_area_index+1].first;
            int offset = {{ion_channel_name}}{{channel_suffix}}_con_area[con_area_index].second;

            #pragma omp simd
            for(std::size_t chan_id = con_area; chan_id < next_con_area; chan_id++){
                (*g_vals_comp)[chan_id+offset] += g_vals_{{ion_channel_name}}{{channel_suffix}}[chan_id];
                (*i_vals_comp)[chan_id+offset] += i_vals_{{ion_channel_name}}{{channel_suffix}}[chan_id];
            }
        }

        std::size_t con_area = {{ion_channel_name}}{{channel_suffix}}_con_area[con_area_count-1].first;
        int offset = {{ion_channel_name}}{{channel_suffix}}_con_area[con_area_count-1].second;

        #pragma omp simd
        for(std::size_t chan_id = con_area; chan_id < {{ion_channel_name}}{{channel_suffix}}.neuron_{{ ion_channel_name }}_channel_count; chan_id++){
            (*g_vals_comp)[chan_id+offset] += g_vals_{{ion_channel_name}}{{channel_suffix}}[chan_id];
            (*i_vals_comp)[chan_id+offset] += i_vals_{{ion_channel_name}}{{channel_suffix}}[chan_id];
        }
    }
    {% endfor -%}

    {%- for receptor_name, receptor_info in recs_info.items() %}
    // contribution of {{receptor_name}} receptors
    {{receptor_name}}{{receptor_suffix}}.f_numstep({{receptor_name}}{{receptor_suffix}}.distribute_shared_vector(v_comp_vec), lag {% for ode in receptor_info["Dependencies"]["concentrations"] %}, {{receptor_name}}{{receptor_suffix}}.distribute_shared_vector({{ode.lhs.name}}{{concentration_suffix}}_shared_concentration){% endfor %}{% if receptor_info["Dependencies"]["receptors"]|length %}
                        {% endif %}{% for inline in receptor_info["Dependencies"]["receptors"] %}, {{receptor_name}}{{receptor_suffix}}.distribute_shared_vector({{inline.variable_name}}{{receptor_suffix}}_shared_current){% endfor %}{% if receptor_info["Dependencies"]["channels"]|length %}
                        {% endif %}{% for inline in receptor_info["Dependencies"]["channels"] %}, {{receptor_name}}{{receptor_suffix}}.distribute_shared_vector({{inline.variable_name}}{{channel_suffix}}_shared_current){% endfor %}{% if receptor_info["Dependencies"]["continuous"]|length %}
                        {% endif %}{% for inline in receptor_info["Dependencies"]["continuous"] %}, {{receptor_name}}{{receptor_suffix}}.distribute_shared_vector({{inline.variable_name}}{{continuous_suffix}}_shared_current){% endfor %}
                        , i_vals_{{receptor_name}}{{receptor_suffix}}, g_vals_{{receptor_name}}{{receptor_suffix}});

    con_area_count = {{receptor_name}}{{receptor_suffix}}_con_area.size();
    if(con_area_count > 0){
        for(std::size_t con_area_index = 0; con_area_index < con_area_count-1; con_area_index++){
            std::size_t con_area = {{receptor_name}}{{receptor_suffix}}_con_area[con_area_index].first;
            std::size_t next_con_area = {{receptor_name}}{{receptor_suffix}}_con_area[con_area_index+1].first;
            int offset = {{receptor_name}}{{receptor_suffix}}_con_area[con_area_index].second;

            #pragma omp simd
            for(std::size_t syn_id = con_area; syn_id < next_con_area; syn_id++){
                (*g_vals_comp)[syn_id+offset] += g_vals_{{receptor_name}}{{receptor_suffix}}[syn_id];
                (*i_vals_comp)[syn_id+offset] += i_vals_{{receptor_name}}{{receptor_suffix}}[syn_id];
            }
        }

        std::size_t con_area = {{receptor_name}}{{receptor_suffix}}_con_area[con_area_count-1].first;
        int offset = {{receptor_name}}{{receptor_suffix}}_con_area[con_area_count-1].second;

        #pragma omp simd
        for(std::size_t syn_id = con_area; syn_id < {{receptor_name}}{{receptor_suffix}}.neuron_{{ receptor_name }}_receptor_count; syn_id++){
            (*g_vals_comp)[syn_id+offset] += g_vals_{{receptor_name}}{{receptor_suffix}}[syn_id];
            (*i_vals_comp)[syn_id+offset] += i_vals_{{receptor_name}}{{receptor_suffix}}[syn_id];
        }
    }
    {% endfor -%}

    {%- for receptor_name, receptor_info in recs_info.items() %}
    {%- for synapse_name, synapse_info in syns_info.items() %}
    // contribution of {{receptor_name}}_{{synapse_name}} receptors
    {%- with  %}
    {%- set conc_dep = set(receptor_info["Dependencies"]["concentrations"]).union(synapse_info["Dependencies"]["concentrations"])%}
    {%- set rec_dep = set(receptor_info["Dependencies"]["receptors"]).union(synapse_info["Dependencies"]["receptors"])%}
    {%- set chan_dep = set(receptor_info["Dependencies"]["channels"]).union(synapse_info["Dependencies"]["channels"])%}
    {%- set con_in_dep = set(receptor_info["Dependencies"]["continuous"]).union(synapse_info["Dependencies"]["continuous"])%}
    {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}.f_numstep({{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}.distribute_shared_vector(v_comp_vec), lag {% for ode in conc_dep %}, {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}.distribute_shared_vector({{ode.lhs.name}}{{concentration_suffix}}_shared_concentration){% endfor %}{% if rec_dep|length %}
                        {% endif %}{% for inline in rec_dep %}, {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}.distribute_shared_vector({{inline.variable_name}}{{receptor_suffix}}_shared_current){% endfor %}{% if chan_dep|length %}
                        {% endif %}{% for inline in chan_dep %}, {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}.distribute_shared_vector({{inline.variable_name}}{{channel_suffix}}_shared_current){% endfor %}{% if con_in_dep|length %}
                        {% endif %}{% for inline in con_in_dep %}, {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}.distribute_shared_vector({{inline.variable_name}}{{continuous_suffix}}_shared_current){% endfor %}
                        , i_vals_{{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}, g_vals_{{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}});
    {%- endwith %}
    con_area_count = {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}_con_area.size();
    if(con_area_count > 0){
        for(std::size_t con_area_index = 0; con_area_index < con_area_count-1; con_area_index++){
            std::size_t con_area = {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}_con_area[con_area_index].first;
            std::size_t next_con_area = {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}_con_area[con_area_index+1].first;
            int offset = {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}_con_area[con_area_index].second;

            #pragma omp simd
            for(std::size_t syn_id = con_area; syn_id < next_con_area; syn_id++){
                (*g_vals_comp)[syn_id+offset] += g_vals_{{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}[syn_id];
                (*i_vals_comp)[syn_id+offset] += i_vals_{{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}[syn_id];
            }
        }

        std::size_t con_area = {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}_con_area[con_area_count-1].first;
        int offset = {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}_con_area[con_area_count-1].second;

        #pragma omp simd
        for(std::size_t syn_id = con_area; syn_id < {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}.neuron_{{ receptor_name }}_receptor_count; syn_id++){
            (*g_vals_comp)[syn_id+offset] += g_vals_{{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}[syn_id];
            (*i_vals_comp)[syn_id+offset] += i_vals_{{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}[syn_id];
        }
    }
    {% endfor -%}
    {% endfor -%}

    {%- for continuous_name, continuous_info in con_in_info.items() %}
    // contribution of {{continuous_name}} continuous inputs
    {{continuous_name}}{{continuous_suffix}}.f_numstep({{continuous_name}}{{continuous_suffix}}.distribute_shared_vector(v_comp_vec), lag {% for ode in continuous_info["Dependencies"]["concentrations"] %}, {{continuous_name}}{{continuous_suffix}}.distribute_shared_vector({{ode.lhs.name}}{{concentration_suffix}}_shared_concentration){% endfor %}{% if continuous_info["Dependencies"]["receptors"]|length %}
                        {% endif %}{% for inline in continuous_info["Dependencies"]["receptors"] %}, {{continuous_name}}{{continuous_suffix}}.distribute_shared_vector({{inline.variable_name}}{{receptor_suffix}}_shared_current){% endfor %}{% if continuous_info["Dependencies"]["channels"]|length %}
                        {% endif %}{% for inline in continuous_info["Dependencies"]["channels"] %}, {{continuous_name}}{{continuous_suffix}}.distribute_shared_vector({{inline.variable_name}}{{channel_suffix}}_shared_current){% endfor %}{% if continuous_info["Dependencies"]["continuous"]|length %}
                        {% endif %}{% for inline in continuous_info["Dependencies"]["continuous"] %}, {{continuous_name}}{{continuous_suffix}}.distribute_shared_vector({{inline.variable_name}}{{continuous_suffix}}_shared_current){% endfor %}
                        , i_vals_{{continuous_name}}{{continuous_suffix}}, g_vals_{{continuous_name}}{{continuous_suffix}});

    con_area_count = {{continuous_name}}{{continuous_suffix}}_con_area.size();
    if(con_area_count > 0){
        for(std::size_t con_area_index = 0; con_area_index < con_area_count-1; con_area_index++){
            std::size_t con_area = {{continuous_name}}{{continuous_suffix}}_con_area[con_area_index].first;
            std::size_t next_con_area = {{continuous_name}}{{continuous_suffix}}_con_area[con_area_index+1].first;
            int offset = {{continuous_name}}{{continuous_suffix}}_con_area[con_area_index].second;

            #pragma omp simd
            for(std::size_t cont_id = con_area; cont_id < next_con_area; cont_id++){
                (*g_vals_comp)[cont_id+offset] += g_vals_{{continuous_name}}{{continuous_suffix}}[cont_id];
                (*i_vals_comp)[cont_id+offset] += i_vals_{{continuous_name}}{{continuous_suffix}}[cont_id];
            }
        }

        std::size_t con_area = {{continuous_name}}{{continuous_suffix}}_con_area[con_area_count-1].first;
        int offset = {{continuous_name}}{{continuous_suffix}}_con_area[con_area_count-1].second;

        #pragma omp simd
        for(std::size_t cont_id = con_area; cont_id < {{continuous_name}}{{continuous_suffix}}.neuron_{{ continuous_name }}_continuous_input_count; cont_id++){
            (*g_vals_comp)[cont_id+offset] += g_vals_{{continuous_name}}{{continuous_suffix}}[cont_id];
            (*i_vals_comp)[cont_id+offset] += i_vals_{{continuous_name}}{{continuous_suffix}}[cont_id];
        }
    }
    {% endfor -%}
  };

  void f_self_spike(){
    {%- for receptor_name, receptor_info in recs_info.items() %}
        {%- for synapse_name, synapse_info in syns_info.items() %}
    {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}.postsynaptic_synaptic_processing();
    {{receptor_name}}{{receptor_suffix}}_con_{{synapse_name}}.f_self_spike();
        {% endfor -%}
    {{receptor_name}}{{receptor_suffix}}.f_self_spike();
    {% endfor -%}
    {%- for ion_channel_name, channel_info in chan_info.items() %}
    {{ion_channel_name}}{{channel_suffix}}.f_self_spike();
    {% endfor -%}
    {%- for concentration_name, concentration_info in conc_info.items() %}
    {{concentration_name}}{{concentration_suffix}}.f_self_spike();
    {% endfor -%}
    {%- for continuous_name, continuous_info in con_in_info.items() %}
    {{continuous_name}}{{continuous_suffix}}.f_self_spike();
    {% endfor -%}
  };
};

} // namespace

#endif /* #ifndef receptorS_NEAT_H_{{cm_unique_suffix | upper }} */
