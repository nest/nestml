#include "{{ synapseName }}_impl.h"

// uncomment the next line to enable printing of detailed debug information
#define DEBUG


//! Global plasticity parameter data (in DTCM)
plasticity_weight_region_data_t *plasticity_weight_region_data;




//! The format of the plastic data region of a synaptic row
struct synapse_row_plastic_data_t {
    //! The pre-event history
    pre_event_history_t history;
    //! The per-synapse information
    synapse_word_t synapses[];
};

extern uint32_t skipped_synapses;


bool synapse_dynamics_initialise(
        address_t address, uint32_t n_neurons, uint32_t n_synapse_types,
        uint32_t *ring_buffer_to_input_buffer_left_shifts) {

    char _string_buf[20];

    log_info("[NESTML synapse] In synapse_dynamics_initialise(n_neurons = %d, n_synapse_types = %d)", n_neurons, n_synapse_types);

    // Load parameters
    plasticity_weight_region_data_t *config = (plasticity_weight_region_data_t *) address;
    plasticity_weight_region_data = spin1_malloc(sizeof(plasticity_weight_region_data_t) * n_synapse_types);

    if (plasticity_weight_region_data == NULL) {
        log_error("Could not initialise weight region data");
        return false;
    }

//    for (uint32_t s = 0; s < n_synapse_types; s++, config++) {
    for (uint32_t s = 0; s < 1; s++, config++) {  // XXX: only permit one synapse type for now
{%- for sym in synapse.get_parameter_symbols() + synapse.get_internal_symbols() %}
        plasticity_weight_region_data[s].{{ sym.get_symbol_name() }} = config->{{ sym.get_symbol_name() }};
#ifdef DEBUG
        log_info("\t[NESTML synapse] \tSynapse type %u: Parameter {{ sym.get_symbol_name() }}, Raw value: %x, Value: %k", s, plasticity_weight_region_data[s].{{ sym.get_symbol_name() }}, plasticity_weight_region_data[s].{{ sym.get_symbol_name() }});
//        log_info("\t[NESTML synapse] \tSynapse type %u: Parameter {{ sym.get_symbol_name() }}, Value: %k", s, plasticity_weight_region_data[s].{{ sym.get_symbol_name() }});
 //       log_info("\t[NESTML synapse] \tSynapse type %u: Parameter {{ sym.get_symbol_name() }}, Raw value: %x, Decoded float value: %s", s, dtcm_copy[s].{{ sym.get_symbol_name() }}, _string_buf);
#endif
    //    {{ sym.get_symbol_name() }} = config->{{ sym.get_symbol_name() }};
{%- endfor %}
    }

    post_event_history = post_events_init_buffers(n_neurons);
    if (post_event_history == NULL) {
        return false;
    }

    return true;
}

//---------------------------------------
// Synaptic row plastic-region implementation
//---------------------------------------
void synapse_dynamics_print_plastic_synapses(
        synapse_row_plastic_data_t *plastic_region_data,
        synapse_row_fixed_part_t *fixed_region,
        uint32_t *ring_buffer_to_input_buffer_left_shifts) {

    return;

    __use(plastic_region_data);
    __use(fixed_region);
    __use(ring_buffer_to_input_buffer_left_shifts);
}

//---------------------------------------
//! \brief Get the axonal delay
//! \param[in] x: The packed plastic synapse control word
//! \return the axonal delay
static inline index_t sparse_axonal_delay(uint32_t x) {
#if 1
    // No axonal delay, ever
    __use(x);
    return 0;
#else
    return (x >> synapse_delay_index_type_bits) & SYNAPSE_AXONAL_DELAY_MASK;
#endif
}



static void update_internal_state_(synapse_state_t *state, double t_start, double timestep) {
    if (timestep < 1E-12) {
        return;
    }

    /**
     * Recompute propagator constants
    **/
    
    //recompute_internal_variables(timestep = ...);


    /**
     * Begin NESTML generated code for the update block
    **/

{%- if synapse.get_update_blocks() %}
{%-     filter indent(2) %}
{%-         for block in synapse.get_update_blocks() %}
{%-             set ast = block.get_stmts_body() %}
{%-             if ast.print_comment('*')|length > 1 %}
/*
 {{ast.print_comment('*')}}
 */
{%-             endif %}
{%-             include "directives_cpp/StmtsBody.jinja2" %}
{%-         endfor %}
{%-     endfilter %}
{%- endif %}

    /**
     * End NESTML generated code for the update block
    **/
}


static void process_post_spike(synapse_state_t *state, uint32_t time) {
{%- filter indent(8, True) %}
{%- if post_ports is defined %}
{%-     for post_port in spiking_post_ports %}
/**
 *  NESTML generated onReceive code block for postsynaptic port "{{ post_port }}" begins here!
**/
{%-         if synapse.get_on_receive_block(post_port) %}
{%-             set dynamics = synapse.get_on_receive_block(post_port) %}
{%-             with ast = dynamics.get_stmts_body() %}
{%-                 include "directives_cpp/StmtsBody.jinja2" %}
{%-             endwith %}
{%-         endif %}
{%-     endfor %}
{%- endif %}
{%- endfilter %}
}



static void process_pre_spike(synapse_state_t *state, uint32_t time) {
    /**
     * Process pre-synaptic spike
    **/

{%- for pre_port in pre_ports %}

    /**
     *  NESTML generated onReceive code block for presynaptic port "{{ pre_port }}" begins here!
    **/
{%      if synapse.get_on_receive_block(pre_port) %}
{%-         set dynamics = synapse.get_on_receive_block(pre_port) %}
{%-         with ast = dynamics.get_stmts_body() %}
{%-             filter indent(4, True) %}
{%-                 include "directives_cpp/StmtsBody.jinja2" %}
{%-             endfilter %}
{%-         endwith %}
{%-     endif %}
{%- endfor %}
}


static void process_plastic_synapse(
        uint32_t control_word, uint32_t last_pre_time, pre_trace_t last_pre_trace,
		pre_trace_t new_pre_trace, weight_t *ring_buffers, uint32_t pre_spike_time,
		uint32_t colour_delay, synapse_word_t *synapse_word) {

    log_info("[NESTML synapse] In process_plastic_synapse(time = %d, last_pre_time = %d)", pre_spike_time, last_pre_time);

    fixed_{{ synapseName }} s = synapse_dynamics_stdp_get_fixed(control_word, pre_spike_time, colour_delay);

    uint32_t post_delay = s.delay_dendritic;
    if (!params.backprop_delay) {
        post_delay = 0;
    }

    synapse_state_t state = synapse_word_to_state_t(synapse_word, plastic_synapse_word_stride);

    log_info("[NESTML synapse] \tCurrent state:");
{%- for sym in synapse.get_state_symbols() %}
    log_info("[NESTML synapse] \t\t{{ sym.get_symbol_name() }} = 0x%x\n", state.{{ sym.get_symbol_name() }});
{%- endfor %}

    //log_info("[NESTML synapse] \t__P__pre_trace__pre_trace: %x", plasticity_weight_region_data->__P__pre_trace__pre_trace);





    uint32_t current_time = last_pre_time; // at the start, the state is either the initial state, or however we left it when the previous pre-synaptic spike was processed



    // Apply axonal delay to time of last presynaptic spike
    const uint32_t delay_axonal = 0;
    const uint32_t delayed_last_pre_time = last_pre_time + delay_axonal;

    // Get the post-synaptic window of events to be processed
    const uint32_t window_begin_time =
            (delayed_last_pre_time >= s.delay_dendritic)
            ? (delayed_last_pre_time - s.delay_dendritic) : 0;
    const uint32_t delayed_pre_time = last_pre_time + delay_axonal;
    const uint32_t window_end_time =
            (delayed_pre_time >= s.delay_dendritic)
            ? (delayed_pre_time - s.delay_dendritic) : 0;
    post_event_window_t post_window = post_events_get_window_delayed(
            post_event_history, window_begin_time, window_end_time);

    // Process events in post-synaptic window
    while (post_window.num_events > 0) {
        const uint32_t delayed_post_time = *post_window.next_time + s.delay_dendritic;

        log_debug("[NESTML synapse] \t\tApplying post-synaptic event at delayed time:%u, pre:%u\n", delayed_post_time, delayed_last_pre_time);


        /**
         * update synapse internal state from `current_time` to `delayed_post_time`
        **/

        update_internal_state_(&state, current_time, delayed_post_time - current_time);
        current_time = delayed_post_time;

        /**
         * handle the postsynaptic spike
        **/

        process_post_spike(&state, current_time);

        // Go onto next event
        post_window = post_events_next(post_window);
    }


    /**
     * update synapse internal state from `current_time` to `pre_spike_time`
    **/

    update_internal_state_(&state, current_time, pre_spike_time - current_time);
    current_time = pre_spike_time;

    log_info("[NESTML synapse] \tNEW state after integration to t_pre:");
{%- for sym in synapse.get_state_symbols() %}
    log_info("[NESTML synapse] \t\t{{ sym.get_symbol_name() }} = 0x%x\n", state.{{ sym.get_symbol_name() }});
{%- endfor %}


    /**
     * process pre spike
    **/

    process_pre_spike(&state, current_time);

    log_info("[NESTML synapse] \tNEW state after processing pre_spikes:");
{%- for sym in synapse.get_state_symbols() %}
    log_info("[NESTML synapse] \t\t{{ sym.get_symbol_name() }} = 0x%x\n", state.{{ sym.get_symbol_name() }});
{%- endfor %}

	/**
	 * Add weight to ring-buffer entry, but only if not too late
	**/
	
	if (s.delay_axonal + s.delay_dendritic > colour_delay) {
	    int32_t weight = state.w;   // XXX: the variable name ``w`` is hard-coded here  // XXX: might need to bit-shift here! Store ``ring_buffer_to_input_buffer_left_shifts`` somewhere which is given in the init function
	    synapse_dynamics_stdp_update_ring_buffers(ring_buffers, s, weight);
    } else {
        skipped_synapses++;
    }

    /**
     * Encode the new state into synaptic word
    **/

    state_t_to_synapse_word(&state, synapse_word, plastic_synapse_word_stride);
//    log_info("[NESTML synapse] ---> the new synapse word is 0x%x, 0x%x, 0x%x", synapse_word->w, synapse_word->pre_trace, synapse_word->post_trace);
}


/**
 * print low-level synaptic row data
**/
void print_low_level_synaptic_row_data(synapse_row_plastic_data_t *plastic_region_address,
                                       synapse_row_fixed_part_t *fixed_region) {

    // data words: for each synapse, stores the complete state in a 32-bit word
    synapse_word_t *plastic_words = plastic_region_address->synapses;

    // control words: for each synapse, stores the delay, synapse type, and postsynaptic neuron ID
    control_t *control_words = synapse_row_plastic_controls(fixed_region);

    // Print out parsed data for static synapses
    uint32_t *synaptic_words = synapse_row_fixed_weight_controls(fixed_region);
    const uint32_t n_fixed_synapses = synapse_row_num_fixed_synapses(fixed_region);
    log_info("[NESTML synapse] \tFixed-Fixed Region (%u synapses):", n_fixed_synapses);
    for (size_t i = 0; i < n_fixed_synapses; ++i) {
        uint32_t synaptic_word = *synaptic_words++;

        uint32_t delay = synapse_row_sparse_delay(synaptic_word, synapse_type_index_bits, synapse_delay_mask);
        uint32_t type = synapse_row_sparse_type(synaptic_word, synapse_index_bits, synapse_type_mask);
        uint32_t neuron = synapse_row_sparse_index(synaptic_word, synapse_index_mask);
        log_info("[NESTML synapse] \t\tDelay %u, Synapse Type %u, Neuron %u", delay, type, neuron);
    }

    const size_t n_plastic_synapses = synapse_row_num_plastic_controls(fixed_region);

    log_info("[NESTML synapse] \tPlastic region %u synapses:", n_plastic_synapses);
    for (uint32_t i = 0; i < n_plastic_synapses; ++i) {
        // Get next control word (auto incrementing control word)
        uint32_t control_word = *(control_words + i);
        uint32_t synapse_type = synapse_row_sparse_type(control_word, synapse_index_bits, synapse_type_mask);

        // Get state
        const synapse_word_t data_word = *(plastic_words + i * plastic_synapse_word_stride * 4);  // 4 because of 32-bit word length
        synapse_state_t update_state = synapse_structure_get_update_state(data_word, synapse_type);

        log_info("[NESTML synapse] \t\tidx = %d; control word = %08x; data word = %08x; w = %5u; pre_trace = %d; post_trace = %d; d = %2u, post neuron id = %3u", i, control_word, data_word, update_state.w, update_state.pre_trace, update_state.post_trace, synapse_row_sparse_delay(control_word, synapse_type_index_bits, synapse_delay_mask), synapse_row_sparse_index(control_word, synapse_index_mask));
/*        log_info("[NESTML synapse] \td: %2u, n = %3u)] - { %08x %08x }\n",
                synapse_row_sparse_delay(control_word, synapse_type_index_bits, synapse_delay_mask),
                synapse_row_sparse_index(control_word, synapse_index_mask),
                synapse_delay_mask, synapse_type_index_bits);*/

    }

}




//! \brief Process the dynamics of the synapses
//! \param[in,out] plastic_region_data: Where the plastic data is
//! \param[in] fixed_region: Where the fixed data is
//! \param[in,out] ring_buffers: The ring buffers
//! \param[in] time: The current simulation time
//! \param[out] Whether to write back anything
//! \return Whether the processing was successful or not
bool synapse_dynamics_process_plastic_synapses(
        synapse_row_plastic_data_t *plastic_region_address,
        synapse_row_fixed_part_t *fixed_region,
        weight_t *ring_buffers, uint32_t time, uint32_t colour_delay,
        bool *write_back) {

    log_info("[NESTML synapse] synapse_dynamics_process_plastic_synapses()");
 


    // Extract separate arrays of plastic synapses (from plastic region),
    // Control words (from fixed region) and number of plastic synapses
    synapse_word_t *plastic_words = plastic_region_address->synapses;
    control_t *control_words = synapse_row_plastic_controls(fixed_region);
    const size_t n_plastic_synapses = synapse_row_num_plastic_controls(fixed_region);

//    log_info("[NESTML synapse] ------------------ AAAAAAAAAAAAAAAAAAA");
//    print_low_level_synaptic_row_data(plastic_region_address, fixed_region);



    num_plastic_pre_synaptic_events += n_plastic_synapses;

    // Get last pre-synaptic event from event history
    const uint32_t last_pre_time = plastic_region_address->history.prev_time;
    const pre_trace_t last_pre_trace = plastic_region_address->history.prev_trace;

    // Update pre-synaptic trace
//    plastic_region_address->history.prev_time = time - colour_delay;
//    plastic_region_address->history.prev_trace = timing_add_pre_spike(time - colour_delay, last_pre_time, last_pre_trace);

    control_words = synapse_row_plastic_controls(fixed_region);
    plastic_words = plastic_region_address->synapses;

    // Loop through plastic synapses
    for (size_t i = 0; i < n_plastic_synapses; ++i) {
        // Get next control word (auto incrementing)
        uint32_t control_word = *(control_words + i);

//        log_info("[NESTML synapse] old plastic word[%d] = %x\n", i, plastic_words[i * plastic_synapse_word_stride]);
        process_plastic_synapse(control_word, last_pre_time, last_pre_trace, plastic_region_address->history.prev_trace, ring_buffers, time, colour_delay, plastic_words);
//        log_info("[NESTML synapse] new plastic word[%d] = %x\n", i, plastic_words[i * plastic_synapse_word_stride]);

    }


    *write_back = true;

    return true;
}
