#include "{{ synapseName }}_impl.h"

// uncomment the next line to enable printing of detailed debug information
#define DEBUG


//! Global plasticity parameter data (in DTCM)
plasticity_weight_region_data_t *plasticity_weight_region_data;










// Define the number of fractional bits for the S16.15 format.
#define FRACTIONAL_BITS 16

/**
 * @brief Converts a 32-bit Q15.16 fixed-point number to a decimal string.
 *
 * This function extracts the sign, integer, and fractional parts of the Q15.16
 * number without using floating-point arithmetic. It then constructs a string
 * representation.
 *
 * @param q_num The 32-bit Q15.16 fixed-point number.
 * @param buffer A character buffer to store the resulting string.
 * @param buffer_size The size of the buffer.
 */
void q15_16_to_string(int32_t q_num, char *buffer, size_t buffer_size) {
#ifdef FOOBAR
    if (buffer == NULL || buffer_size == 0) {
        return;
    }

    // Determine the sign and work with the absolute value for calculations.
    // The sign bit is the MSB (bit 31)
    int is_negative = (q_num < 0);
    if (is_negative) {
        q_num = -q_num;
    }

    // Extract the integer part by right-shifting by 16 bits.
    // The integer part occupies bits 16 to 30 (15 bits)
    int32_t integer_part = q_num >> 16;

    // Extract the fractional part by masking the lower 16 bits.
    // The fractional part occupies bits 0 to 15 (16 bits)
    int32_t fractional_part = q_num & 0xFFFF;

    // To convert the fractional part to a decimal string without floats, we
    // treat it as a fraction of 2^16 (65536).
    // For example, if the fractional part is 32768, the value is 32768/65536 = 0.5.
    // To get a decimal string with, say, 5 digits, we multiply by 10^5 and
    // then divide by 65536, using a 64-bit integer to avoid overflow.
    // The fractional part will be (fractional_part * 100000) / 65536.
    int64_t decimal_fraction = ((int64_t)fractional_part * 100000 + 32768) >> 16;
    // We add 32768 (0.5 * 65536) for rounding before the bit shift, which is
    // equivalent to division. This is a common fixed-point rounding technique.

    // Start printing the string.
    char *ptr = buffer;
    if (is_negative) {
        *ptr++ = '-';
    }

    // Print the integer part.
    ptr += snprintf(ptr, buffer_size - (ptr - buffer), "%d.", integer_part);

    // Print the fractional part with leading zeros to maintain precision.
    snprintf(ptr, buffer_size - (ptr - buffer), "%05lld", (long long)decimal_fraction);
#endif
}

















#ifdef FOOBAR

/**
 * parameters from the NESTML model
**/

{%- for sym in synapse.get_parameter_symbols() %}
accum {{ sym.get_symbol_name() }};
{%- endfor %}

/**
 * internals from the NESTML model
**/

{%- for sym in synapse.get_internal_symbols() %}
accum {{ sym.get_symbol_name() }};
{%- endfor %}

#endif



//! The format of the plastic data region of a synaptic row
struct synapse_row_plastic_data_t {
    //! The pre-event history
    pre_event_history_t history;
    //! The per-synapse information
    synapse_word_t synapses[];
};

extern uint32_t skipped_synapses;


bool synapse_dynamics_initialise(
        address_t address, uint32_t n_neurons, uint32_t n_synapse_types,
        uint32_t *ring_buffer_to_input_buffer_left_shifts) {

    char _string_buf[20];

    log_info("[NESTML synapse] In synapse_dynamics_initialise(n_neurons = %d, n_synapse_types = %d)", n_neurons, n_synapse_types);

    // Load parameters
    plasticity_weight_region_data_t *config = (plasticity_weight_region_data_t *) address;
    plasticity_weight_region_data = spin1_malloc(sizeof(plasticity_weight_region_data_t) * n_synapse_types);

    if (plasticity_weight_region_data == NULL) {
        log_error("Could not initialise weight region data");
        return false;
    }

//    for (uint32_t s = 0; s < n_synapse_types; s++, config++) {
    for (uint32_t s = 0; s < 1; s++, config++) {  // XXX: only permit one synapse type for now
{%- for sym in synapse.get_parameter_symbols() + synapse.get_internal_symbols() %}
        plasticity_weight_region_data[s].{{ sym.get_symbol_name() }} = config->{{ sym.get_symbol_name() }};
#ifdef DEBUG
        log_info("\t[NESTML synapse] \tSynapse type %u: Parameter {{ sym.get_symbol_name() }}, Raw value: %x, Value: %k", s, plasticity_weight_region_data[s].{{ sym.get_symbol_name() }}, plasticity_weight_region_data[s].{{ sym.get_symbol_name() }});
//        log_info("\t[NESTML synapse] \tSynapse type %u: Parameter {{ sym.get_symbol_name() }}, Value: %k", s, plasticity_weight_region_data[s].{{ sym.get_symbol_name() }});
//        q15_16_to_string(dtcm_copy[s].{{ sym.get_symbol_name() }}, _string_buf, 20);
 //       log_info("\t[NESTML synapse] \tSynapse type %u: Parameter {{ sym.get_symbol_name() }}, Raw value: %x, Decoded float value: %s", s, dtcm_copy[s].{{ sym.get_symbol_name() }}, _string_buf);
#endif
    //    {{ sym.get_symbol_name() }} = config->{{ sym.get_symbol_name() }};
{%- endfor %}
    }

    post_event_history = post_events_init_buffers(n_neurons);
    if (post_event_history == NULL) {
        return false;
    }

    return true;
}

//---------------------------------------
// Synaptic row plastic-region implementation
//---------------------------------------
void synapse_dynamics_print_plastic_synapses(
        synapse_row_plastic_data_t *plastic_region_data,
        synapse_row_fixed_part_t *fixed_region,
        uint32_t *ring_buffer_to_input_buffer_left_shifts) {

    return;

    __use(plastic_region_data);
    __use(fixed_region);
    __use(ring_buffer_to_input_buffer_left_shifts);
}

//---------------------------------------
//! \brief Get the axonal delay
//! \param[in] x: The packed plastic synapse control word
//! \return the axonal delay
static inline index_t sparse_axonal_delay(uint32_t x) {
#if 1
    // No axonal delay, ever
    __use(x);
    return 0;
#else
    return (x >> synapse_delay_index_type_bits) & SYNAPSE_AXONAL_DELAY_MASK;
#endif
}




static void process_plastic_synapse(
        uint32_t control_word, uint32_t last_pre_time, pre_trace_t last_pre_trace,
		pre_trace_t new_pre_trace, weight_t *ring_buffers, uint32_t time,
		uint32_t colour_delay, synapse_word_t *synapse_word) {

    log_info("[NESTML synapse] In process_plastic_synapse(time = %d, last_pre_time = %d)", time, last_pre_time);

    fixed_{{ synapseName }} s = synapse_dynamics_stdp_get_fixed(control_word, time, colour_delay);

    uint32_t post_delay = s.delay_dendritic;
    if (!params.backprop_delay) {
        post_delay = 0;
    }

    synapse_state_t state = synapse_word_to_state_t(synapse_word, plastic_synapse_word_stride);

    log_info("[NESTML synapse] \tCurrent state:");
{%- for sym in synapse.get_state_symbols() %}
    log_info("[NESTML synapse] \t\t{{ sym.get_symbol_name() }} = 0x%x\n", state.{{ sym.get_symbol_name() }});
{%- endfor %}

//    log_info("[NESTML synapse] \t__P__pre_trace__pre_trace: %x", state.weight_region->__P__pre_trace__pre_trace);
    log_info("[NESTML synapse] \t__P__pre_trace__pre_trace: %x", plasticity_weight_region_data->__P__pre_trace__pre_trace);

    /**
     * Begin NESTML generated code for the update block
    **/

{%- if synapse.get_update_blocks() %}
{%-     filter indent(2) %}
{%-         for block in synapse.get_update_blocks() %}
{%-             set ast = block.get_stmts_body() %}
{%-             if ast.print_comment('*')|length > 1 %}
/*
 {{ast.print_comment('*')}}
 */
{%-             endif %}
{%-             include "directives_cpp/StmtsBody.jinja2" %}
{%-         endfor %}
{%-     endfilter %}
{%- endif %}

    /**
     * End NESTML generated code for the update block
    **/

    log_info("[NESTML synapse] \tNEW state:");
{%- for sym in synapse.get_state_symbols() %}
    log_info("[NESTML synapse] \t\t{{ sym.get_symbol_name() }} = 0x%x\n", state.{{ sym.get_symbol_name() }});
{%- endfor %}

	// Add weight to ring-buffer entry, but only if not too late
	if (s.delay_axonal + s.delay_dendritic > colour_delay) {
	    int32_t weight = state.w;   // XXX: the variable name ``w`` is hard-coded here  // XXX: might need to bit-shift here! Store ``ring_buffer_to_input_buffer_left_shifts`` somewhere which is given in the init function
	    synapse_dynamics_stdp_update_ring_buffers(ring_buffers, s, weight);
    } else {
        skipped_synapses++;
    }


/*    // Apply axonal delay to time of last presynaptic spike
    const uint32_t delayed_last_pre_time = last_pre_time + delay_axonal;

    // Get the post-synaptic window of events to be processed
    const uint32_t window_begin_time =
            (delayed_last_pre_time >= delay_dendritic)
            ? (delayed_last_pre_time - delay_dendritic) : 0;
    const uint32_t delayed_pre_time = time + delay_axonal;
    const uint32_t window_end_time =
            (delayed_pre_time >= delay_dendritic)
            ? (delayed_pre_time - delay_dendritic) : 0;
    post_event_window_t post_window = post_events_get_window_delayed(
            post_event_history, window_begin_time, window_end_time);



    state = timing_apply_pre_spike(
                delayed_pre_time, new_pre_trace, delayed_last_pre_time, last_pre_trace,
                delayed_last_post, post_window.prev_trace, state);

*/



    /**
     * Process pre-synaptic spike
    **/

{%- for pre_port in pre_ports %}

    /**
     *  NESTML generated onReceive code block for presynaptic port "{{ pre_port }}" begins here!
    **/
{%      if synapse.get_on_receive_block(pre_port) %}
{%-         set dynamics = synapse.get_on_receive_block(pre_port) %}
{%-         with ast = dynamics.get_stmts_body() %}
{%-             filter indent(4, True) %}
{%-                 include "directives_cpp/StmtsBody.jinja2" %}
{%-             endfilter %}
{%-         endwith %}
{%-     endif %}
{%- endfor %}

    /**
     * Encode the new state into synaptic word
    **/

    state_t_to_synapse_word(state, synapse_word, plastic_synapse_word_stride);
    log_info("[NESTML synapse] ---> the new synapse word is %d, %d, %d", synapse_word->w, synapse_word->pre_trace, synapse_word->post_trace);
}


/**
 * print low-level synaptic row data
**/
void print_low_level_synaptic_row_data(synapse_row_plastic_data_t *plastic_region_address,
                                       synapse_row_fixed_part_t *fixed_region) {

    // data words: for each synapse, stores the complete state in a 32-bit word
    synapse_word_t *plastic_words = plastic_region_address->synapses;

    // control words: for each synapse, stores the delay, synapse type, and postsynaptic neuron ID
    control_t *control_words = synapse_row_plastic_controls(fixed_region);

    // Print out parsed data for static synapses
    uint32_t *synaptic_words = synapse_row_fixed_weight_controls(fixed_region);
    const uint32_t n_fixed_synapses = synapse_row_num_fixed_synapses(fixed_region);
    log_info("[NESTML synapse] \tFixed-Fixed Region (%u synapses):", n_fixed_synapses);
    for (size_t i = 0; i < n_fixed_synapses; ++i) {
        uint32_t synaptic_word = *synaptic_words++;

        uint32_t delay = synapse_row_sparse_delay(synaptic_words, synapse_type_index_bits, synapse_delay_mask);
        uint32_t type = synapse_row_sparse_type(synaptic_word, synapse_index_bits, synapse_type_mask);
        uint32_t neuron = synapse_row_sparse_index(synaptic_word, synapse_index_mask);
        log_info("[NESTML synapse] \t\tDelay %u, Synapse Type %u, Neuron %u", delay, type, neuron);
    }

    const size_t n_plastic_synapses = synapse_row_num_plastic_controls(fixed_region);

    log_info("[NESTML synapse] \tPlastic region %u synapses:", n_plastic_synapses);
    for (uint32_t i = 0; i < n_plastic_synapses; ++i) {
        // Get next control word (auto incrementing control word)
        uint32_t control_word = *(control_words + i);
        uint32_t synapse_type = synapse_row_sparse_type(control_word, synapse_index_bits, synapse_type_mask);

        // Get state
        const synapse_word_t data_word = *(plastic_words + i * plastic_synapse_word_stride * 4);  // 4 because of 32-bit word length
        synapse_state_t update_state = synapse_structure_get_update_state(data_word, synapse_type);

        log_info("[NESTML synapse] \t\tidx = %d; control word = %08x; data word = %08x; w = %5u; pre_trace = %d; post_trace = %d; d = %2u, post neuron id = %3u", i, control_word, data_word, update_state.w, update_state.pre_trace, update_state.post_trace, synapse_row_sparse_delay(control_word, synapse_type_index_bits, synapse_delay_mask), synapse_row_sparse_index(control_word, synapse_index_mask));
/*        log_info("[NESTML synapse] \td: %2u, n = %3u)] - { %08x %08x }\n",
                synapse_row_sparse_delay(control_word, synapse_type_index_bits, synapse_delay_mask),
                synapse_row_sparse_index(control_word, synapse_index_mask),
                synapse_delay_mask, synapse_type_index_bits);*/

    }

}




//! \brief Process the dynamics of the synapses
//! \param[in,out] plastic_region_data: Where the plastic data is
//! \param[in] fixed_region: Where the fixed data is
//! \param[in,out] ring_buffers: The ring buffers
//! \param[in] time: The current simulation time
//! \param[out] Whether to write back anything
//! \return Whether the processing was successful or not
bool synapse_dynamics_process_plastic_synapses(
        synapse_row_plastic_data_t *plastic_region_address,
        synapse_row_fixed_part_t *fixed_region,
        weight_t *ring_buffers, uint32_t time, uint32_t colour_delay,
        bool *write_back) {

    log_info("[NESTML synapse] synapse_dynamics_process_plastic_synapses()");
 


    // Extract separate arrays of plastic synapses (from plastic region),
    // Control words (from fixed region) and number of plastic synapses
    synapse_word_t *plastic_words = plastic_region_address->synapses;
    control_t *control_words = synapse_row_plastic_controls(fixed_region);
    const size_t n_plastic_synapses = synapse_row_num_plastic_controls(fixed_region);

//    log_info("[NESTML synapse] ------------------ AAAAAAAAAAAAAAAAAAA");
    print_low_level_synaptic_row_data(plastic_region_address, fixed_region);



    num_plastic_pre_synaptic_events += n_plastic_synapses;

    // Get last pre-synaptic event from event history
    const uint32_t last_pre_time = plastic_region_address->history.prev_time;
    const pre_trace_t last_pre_trace = plastic_region_address->history.prev_trace;

    // Update pre-synaptic trace
//    plastic_region_address->history.prev_time = time - colour_delay;
//    plastic_region_address->history.prev_trace = timing_add_pre_spike(time - colour_delay, last_pre_time, last_pre_trace);

    control_words = synapse_row_plastic_controls(fixed_region);
    plastic_words = plastic_region_address->synapses;

    // Loop through plastic synapses
    for (size_t i = 0; i < n_plastic_synapses; ++i) {
        // Get next control word (auto incrementing)
        uint32_t control_word = *(control_words + i);

//        log_info("[NESTML synapse] old plastic word[%d] = %x\n", i, plastic_words[i * plastic_synapse_word_stride * 4]);
        process_plastic_synapse(control_word, last_pre_time, last_pre_trace, plastic_region_address->history.prev_trace, ring_buffers, time, colour_delay, plastic_words);
//        log_info("[NESTML synapse] new plastic word[%d] = %x\n", i, plastic_words[i * plastic_synapse_word_stride * 4]);

    }

//    log_info("[NESTML synapse] ------------------ BBBBBBBBBBBBBB");
//    print_low_level_synaptic_row_data(plastic_region_address, fixed_region);



    *write_back = true;

    return true;
}


#ifdef FOOBAR
bool synapse_dynamics_find_neuron(
        uint32_t id, synaptic_row_t row, weight_t *weight, uint16_t *delay,
        uint32_t *offset, uint32_t *synapse_type) {


//   log_info("[NESTML synapse] In synapse_dynamics_find_neuron()");


   synapse_row_fixed_part_t *fixed_region = synapse_row_fixed_region(row);
    const synapse_row_plastic_data_t *plastic_data = (void *)
            synapse_row_plastic_region(row);
    const synapse_word_t *plastic_words = plastic_data->synapses;
    const control_t *control_words = synapse_row_plastic_controls(fixed_region);
    const size_t n_plastic_synapses = synapse_row_num_plastic_controls(fixed_region);

    // Loop through plastic synapses
    for (size_t plastic_synapse = n_plastic_synapses; plastic_synapse > 0;
            plastic_synapse--) {
        // Take the weight anyway as this updates the plastic words
        *weight = 72;//synapse_structure_get_weight(*plastic_words++);

        // Check if index is the one I'm looking for
        uint32_t control_word = *control_words++;
        if (synapse_row_sparse_index(control_word, synapse_index_mask) == id) {
            *offset = n_plastic_synapses - plastic_synapse;
            *delay = synapse_row_sparse_delay(control_word,
                    synapse_type_index_bits, synapse_delay_mask);
            *synapse_type = synapse_row_sparse_type(
                    control_word, synapse_index_bits, synapse_type_mask);
            return true;
        }
    }

    return false;
}

bool synapse_dynamics_remove_neuron(uint32_t offset, synaptic_row_t row) {
    synapse_row_fixed_part_t *fixed_region = synapse_row_fixed_region(row);
    synapse_row_plastic_data_t *plastic_data = (void *)
            synapse_row_plastic_region(row);
    synapse_word_t *plastic_words = plastic_data->synapses;

    control_t *control_words = synapse_row_plastic_controls(fixed_region);
    int32_t plastic_synapse = synapse_row_num_plastic_controls(fixed_region);

    // Delete weight at offset
    plastic_words[offset] =  plastic_words[plastic_synapse - 1];

    // Delete control word at offset
    control_words[offset] = control_words[plastic_synapse - 1];
    control_words[plastic_synapse - 1] = 0;

    // Decrement FP
    fixed_region->num_plastic--;
    return true;
}

bool synapse_dynamics_add_neuron(uint32_t id, synaptic_row_t row,
        weight_t weight, uint32_t delay, uint32_t type) {



  //  log_info("[NESTML synapse] In synapse_dynamics_add_neuron()");


    synapse_row_fixed_part_t *fixed_region = synapse_row_fixed_region(row);
    synapse_row_plastic_data_t *plastic_data = synapse_row_plastic_region(row);
    synapse_word_t *plastic_words = plastic_data->synapses;
    synapse_word_t new_weight = (synapse_word_t) {

{%- for sym in synapse.get_state_symbols() %}
    .{{ sym.get_symbol_name() }} = 18882,
{%- endfor %}
    };
    control_t new_control = control_conversion(id, delay, type);

    control_t *control_words = synapse_row_plastic_controls(fixed_region);
    int32_t plastic_synapse = synapse_row_num_plastic_controls(fixed_region);

    // Add weight at offset
    plastic_words[plastic_synapse] = new_weight;

    // Add control word at offset
    control_words[plastic_synapse] = new_control;

    // Increment FP
    fixed_region->num_plastic++;
    return true;
}
#endif





//---------------------------------------
//! \brief Apply a post-spike timing rule state update
//! \param[in] time: the current time
//! \param[in] trace: the current post-spike trace
//! \param[in] last_pre_time: the time of the last pre-spike
//! \param[in] last_pre_trace: the trace of the last pre-spike
//! \param[in] last_post_time: the time of the last post-spike
//! \param[in] last_post_trace: the trace of the last post-spike
//! \param[in] previous_state: the state to update
//! \return the updated state
static inline synapse_word_t timing_apply_post_spike(
        uint32_t time, UNUSED post_trace_t trace, uint32_t last_pre_time,
        pre_trace_t last_pre_trace, UNUSED uint32_t last_post_time,
        UNUSED post_trace_t last_post_trace, synapse_word_t previous_state) {

    log_info("[NESTML synapse] timing_apply_post_spike()");
    log_info("[NESTML synapse] \tRaw weight = %x", previous_state.w);
    previous_state.w = 456;
#ifdef FOOBAR
    // Get time of event relative to last pre-synaptic event
    uint32_t time_since_last_pre = time - last_pre_time;
    if (time_since_last_pre > 0) {

{%- filter indent(6, True) %}
{%- if post_ports is defined %}
{%-     for post_port in spiking_post_ports %}
/**
 *  NESTML generated onReceive code block for postsynaptic port "{{ post_port }}" begins here!
**/
{%-         if synapse.get_on_receive_block(post_port) %}
{%-             set dynamics = synapse.get_on_receive_block(post_port) %}
{%-             with ast = dynamics.get_stmts_body() %}
{%-                 include "directives_cpp/StmtsBody.jinja2" %}
{%-             endwith %}
{%-         endif %}
{%-     endfor %}
{%- endif %}
{%- endfilter %}

        // Apply potentiation to state (which is a weight_state)
        return previous_state;//weight_one_term_apply_potentiation(previous_state, decayed_r1);
    } else {
        return previous_state;
    }
#endif
    return previous_state;
}




//---------------------------------------
//! \brief Apply a pre-spike timing rule state update
//! \param[in] time: the current time
//! \param[in] trace: the current pre-spike trace
//! \param[in] last_pre_time: the time of the last pre-spike
//! \param[in] last_pre_trace: the trace of the last pre-spike
//! \param[in] last_post_time: the time of the last post-spike
//! \param[in] last_post_trace: the trace of the last post-spike
//! \param[in] previous_state: the state to update
//! \return the updated state
static inline synapse_state_t timing_apply_pre_spike(
        uint32_t time, UNUSED pre_trace_t trace, UNUSED uint32_t last_pre_time,
        UNUSED pre_trace_t last_pre_trace, uint32_t last_post_time,
        post_trace_t last_post_trace, synapse_state_t state) {

    log_info("[NESTML synapse] timing_apply_pre_spike()");
{%- for sym in synapse.get_state_symbols() %}
    log_info("[NESTML synapse] \t{{ sym.get_symbol_name() }} = %x", state.{{ sym.get_symbol_name() }});
{%- endfor %}

{%- for pre_port in pre_ports %}

      /**
       *  NESTML generated onReceive code block for presynaptic port "{{ pre_port }}" begins here!
      **/
{%      if synapse.get_on_receive_block(pre_port) %}
{%-         set dynamics = synapse.get_on_receive_block(pre_port) %}
{%-         with ast = dynamics.get_stmts_body() %}
{%-             filter indent(6, True) %}
{%-                 include "directives_cpp/StmtsBody.jinja2" %}
{%-             endfilter %}
{%-         endwith %}
{%-     endif %}
{%- endfor %}

    return state;
}


