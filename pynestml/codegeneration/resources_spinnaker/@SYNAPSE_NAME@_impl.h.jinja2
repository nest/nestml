
#ifndef {{synapseName.upper()}}_IMPL_H
#define {{synapseName.upper()}}_IMPL_H

// Include generic plasticity maths functions
#include <neuron/plasticity/stdp/maths.h>
#include <neuron/plasticity/stdp/stdp_typedefs.h>
#include <neuron/synapse_row.h>

#include <debug.h>

#include "weight_one_term.h"

#include <neuron/plasticity/stdp/synapse_structure/synapse_structure_weight_impl.h>
#include "timing.h"
#include <neuron/plasticity/stdp/weight_dependence/weight_one_term.h>





// stuff from synapse_dynamics_stdp_common.h

// Spinn_common includes
#include <static-assert.h>

// sPyNNaker neural modelling includes
#include <neuron/synapses.h>

// Plasticity includes
#include "maths.h"
#include "post_events.h"

#include "weight_dependence/weight.h"
#include "timing_dependence/timing.h"
#include <debug.h>
#include <utils.h>
#include <neuron/plasticity/synapse_dynamics.h>
#include <stddef.h>

//---------------------------------------
// Macros
//---------------------------------------
// The plastic control words used by Morrison synapses store an axonal delay
// in the upper 3 bits.
// Assuming a maximum of 16 delay slots, this is all that is required as:
//
// 1) Dendritic + Axonal <= 15
// 2) Dendritic >= Axonal
//
// Therefore:
//
// * Maximum value of dendritic delay is 15 (with axonal delay of 0)
//    - It requires 4 bits
// * Maximum value of axonal delay is 7 (with dendritic delay of 8)
//    - It requires 3 bits
//
// |        Axonal delay       |  Dendritic delay   |       Type        |      Index         |
// |---------------------------|--------------------|-------------------|--------------------|
// | SYNAPSE_AXONAL_DELAY_BITS | SYNAPSE_DELAY_BITS | SYNAPSE_TYPE_BITS | SYNAPSE_INDEX_BITS |
// |                           |                    |        SYNAPSE_TYPE_INDEX_BITS         |
// |---------------------------|--------------------|----------------------------------------|
#ifndef SYNAPSE_AXONAL_DELAY_BITS
#define SYNAPSE_AXONAL_DELAY_BITS 3
#endif

#define SYNAPSE_AXONAL_DELAY_MASK \
    ((1 << SYNAPSE_AXONAL_DELAY_BITS) - 1)

//---------------------------------------
// Structures
//---------------------------------------
//! \brief The type of history data of pre-events
//!
//! This data is stored in SDRAM in the plastic part of the synaptic matrix
typedef struct {
    //! The event time
    uint32_t prev_time;
    //! The event trace
    pre_trace_t prev_trace;
} pre_event_history_t;

//! The type of configuration parameters in SDRAM (written by host)
typedef struct stdp_params {
    //! The back-propagation delay, in basic simulation timesteps
    uint32_t backprop_delay;
} stdp_params;

typedef struct fixed_stdp_synapse {
    uint32_t delay_dendritic;
    uint32_t delay_axonal;
    uint32_t type;
    uint32_t index;
    uint32_t type_index;
    uint32_t ring_buffer_index;
} fixed_stdp_synapse;

//! Configuration parameters
static stdp_params params;

//! \brief The history data of post-events
static post_event_history_t *post_event_history;

//! Count of pre-synaptic events relevant to plastic processing
static uint32_t num_plastic_pre_synaptic_events = 0;

//! Count of times that the plastic math became saturated
static uint32_t plastic_saturation_count = 0;

/* PRIVATE FUNCTIONS */

// Mark a value as possibly unused while not using any instructions, guaranteed
#ifndef __use
#define __use(x)    do { (void) (x); } while (0)
#endif

static inline bool synapse_dynamics_stdp_init(
        address_t *address, stdp_params *params, uint32_t n_synapse_types,
        uint32_t *ring_buffer_to_input_buffer_left_shifts) {

    // Load parameters
    stdp_params *sdram_params = (stdp_params *) *address;
    spin1_memcpy(params, sdram_params, sizeof(stdp_params));

    // Load timing dependence data
    address_t weight_region_address = timing_initialise(
            (address_t) &sdram_params[1]);
    if (weight_region_address == NULL) {
        return false;
    }

    // Load weight dependence data
    address_t weight_result = weight_initialise(
            weight_region_address, n_synapse_types,
            ring_buffer_to_input_buffer_left_shifts);
    if (weight_result == NULL) {
        return false;
    }

    // Update address to after the region just read
    *address = weight_result;
    return true;
}

input_t synapse_dynamics_get_intrinsic_bias(
        UNUSED uint32_t time, UNUSED index_t neuron_index) {
    return ZERO;
}

uint32_t synapse_dynamics_get_plastic_pre_synaptic_events(void) {
    return num_plastic_pre_synaptic_events;
}

uint32_t synapse_dynamics_get_plastic_saturation_count(void) {
    return plastic_saturation_count;
}

static inline fixed_stdp_synapse synapse_dynamics_stdp_get_fixed(
        uint32_t control_word, uint32_t time, uint32_t colour_delay) {
    // Extract control-word components
    // **NOTE** cunningly, control word is just the same as lower
    // 16-bits of 32-bit fixed synapse so same functions can be used
    uint32_t delay_dendritic = synapse_row_sparse_delay(control_word,
            synapse_type_index_bits, synapse_delay_mask);
    uint32_t delay_axonal = 0;  //sparse_axonal_delay(control_word);
    uint32_t type_index = synapse_row_sparse_type_index(control_word,
            synapse_type_index_mask);
    return (fixed_stdp_synapse) {
       .delay_dendritic = delay_dendritic,
       .delay_axonal = delay_axonal,
       .type = synapse_row_sparse_type(
                control_word, synapse_index_bits, synapse_type_mask),
       .index = synapse_row_sparse_index(
                control_word, synapse_index_mask),
       .type_index = type_index,
       .ring_buffer_index = synapse_row_get_ring_buffer_index_combined(
                (delay_axonal + delay_dendritic + time) - colour_delay, type_index,
                synapse_type_index_bits, synapse_delay_mask)
    };
}

static inline void synapse_dynamics_stdp_update_ring_buffers(
        weight_t *ring_buffers, fixed_stdp_synapse s, int32_t weight) {
    uint32_t accumulation = ring_buffers[s.ring_buffer_index] + weight;

    uint32_t sat_test = accumulation & 0xFFFF0000;
    if (sat_test) {
        accumulation = 0xFFFF;
        plastic_saturation_count++;
    }

    ring_buffers[s.ring_buffer_index] = accumulation;
}

//! packing all of the information into the required plastic control word
static inline control_t control_conversion(
        uint32_t id, uint32_t delay, uint32_t type) {
    control_t new_control =
            (delay & ((1 << synapse_delay_bits) - 1)) << synapse_type_index_bits;
    new_control |= (type & ((1 << synapse_type_index_bits) - 1)) << synapse_index_bits;
    new_control |= id & ((1 << synapse_index_bits) - 1);
    return new_control;
}

uint32_t synapse_dynamics_n_connections_in_row(synapse_row_fixed_part_t *fixed) {
    return synapse_row_num_plastic_controls(fixed);
}





// stuff from post_events.h


// Standard includes
#include <stdbool.h>
#include <stdint.h>

// Include debug header for log_info etc
#include <debug.h>

//---------------------------------------
// Macros
//---------------------------------------
//! Maximum number of post-synaptic events supported
#define MAX_POST_SYNAPTIC_EVENTS 16

//---------------------------------------
// Structures
//---------------------------------------
//! Trace history of post-synaptic events
typedef struct {
    //! Number of events stored (minus one)
    uint32_t count_minus_one;
    //! Event times
    uint32_t times[MAX_POST_SYNAPTIC_EVENTS];
    //! Event traces
    post_trace_t traces[MAX_POST_SYNAPTIC_EVENTS];
} post_event_history_t;

//! Post event window description
typedef struct {
    //! The previous post-synaptic event trace
    post_trace_t prev_trace;
    //! The previous post-synaptic event time
    uint32_t prev_time;
    //! The next post-synaptic event trace
    const post_trace_t *next_trace;
    //! The next post-synaptic event time
    const uint32_t *next_time;
    //! The number of events
    uint32_t num_events;
    //! Whether the previous post-synaptic event is valid (based on time)
    uint32_t prev_time_valid;
} post_event_window_t;

//---------------------------------------
// Inline functions
//---------------------------------------

#if LOG_LEVEL >= LOG_DEBUG
//! \brief Print a post-synaptic event history
//! \param[in] events: The history
static inline void print_event_history(const post_event_history_t *events) {
    log_debug("      ##  printing entire post event history  ##");
    for (uint32_t i = 0; i <= events->count_minus_one; i++) {
        log_debug("post event: %u, time: %u, trace: %u",
                i, events->times[i], events->traces[i]);
    }
}
#endif

//! \brief Initialise an array of post-synaptic event histories
//! \param[in] n_neurons: Number of neurons
//! \return The array
static inline post_event_history_t *post_events_init_buffers(
        uint32_t n_neurons) {
    post_event_history_t *post_event_history =
            spin1_malloc(n_neurons * sizeof(post_event_history_t));
    // Check allocations succeeded
    if (post_event_history == NULL) {
        log_error("Unable to allocate global STDP structures - Out of DTCM: Try "
                "reducing the number of neurons per core to fix this problem ");
        return NULL;
    }

    // Loop through neurons
    for (uint32_t n = 0; n < n_neurons; n++) {
        // Add initial placeholder entry to buffer
        post_event_history[n].times[0] = 0;
        post_event_history[n].traces[0] = timing_get_initial_post_trace();
        post_event_history[n].count_minus_one = 0;
    }

    return post_event_history;
}

//---------------------------------------
//! \brief Get the post-synaptic event window
//! \param[in] events: The post-synaptic event history
//! \param[in] begin_time: The start of the window
//! \param[in] end_time: The end of the window
//! \return The window
static inline post_event_window_t post_events_get_window_delayed(
        const post_event_history_t *events, uint32_t begin_time,
        uint32_t end_time) {
    // Start at end event - beyond end of post-event history
    const uint32_t count = events->count_minus_one + 1;
    const uint32_t *end_event_time = events->times + count;
    const uint32_t *event_time = end_event_time;
    const post_trace_t *event_trace = events->traces + count;

    post_event_window_t window;
    do {
        // If this event is still in the future, set it as the end
        if (*event_time > end_time) {
            end_event_time = event_time;
        }

        // Cache pointer to this event as potential next event and go back one
        // event.
        // **NOTE** next_time can be invalid
        window.next_time = event_time--;
        window.next_trace = event_trace--;

        // Keep looping while event occurred after start of window and we
        // haven't hit beginning of array...
    } while (*event_time > begin_time && event_time != events->times);

    // Deference event to use as previous
    window.prev_time = *event_time;
    window.prev_trace = *event_trace;
    window.prev_time_valid = event_time != events->times;

    // Calculate number of events
    window.num_events = (end_event_time - window.next_time);

    // Return window
    return window;
}

//---------------------------------------
//! \brief Advance a post-synaptic event window to the next event
//! \param[in] window: The window to advance
//! \return the advanced window
static inline post_event_window_t post_events_next(
        post_event_window_t window) {
    // Update previous time and increment next time
    window.prev_time = *window.next_time++;
    window.prev_trace = *window.next_trace++;

    // Time will now be valid for sure!
    window.prev_time_valid = 1;

    // Decrement remaining events
    window.num_events--;
    return window;
}

//---------------------------------------
//! \brief Add a post-synaptic event to the history
//! \param[in] time: the time of the event
//! \param[in,out] events: the history to add to
//! \param[in] trace: the trace of the event
static inline void post_events_add(
        uint32_t time, post_event_history_t *events, post_trace_t trace) {
    if (events->count_minus_one < MAX_POST_SYNAPTIC_EVENTS - 1) {
        // If there's still space, store time at current end
        // and increment count minus 1
        const uint32_t new_index = ++events->count_minus_one;
        events->times[new_index] = time;
        events->traces[new_index] = trace;
    } else {
        // Otherwise Shuffle down elements
        // **NOTE** 1st element is always an entry at time 0
        for (uint32_t e = 2; e < MAX_POST_SYNAPTIC_EVENTS; e++) {
            events->times[e - 1] = events->times[e];
            events->traces[e - 1] = events->traces[e];
        }

        // Stick new time at end
        events->times[MAX_POST_SYNAPTIC_EVENTS - 1] = time;
        events->traces[MAX_POST_SYNAPTIC_EVENTS - 1] = trace;
    }
}

#if LOG_LEVEL >= LOG_DEBUG
//! \brief Print the post-synaptic event history
//! \param[in] post_event_history: the history
//! \param[in] begin_time: The start time of the history
//! \param[in] end_time: The end time of the history
//! \param[in] delay_dendritic: The amount of dendritic delay
static inline void print_delayed_window_events(
        const post_event_history_t *post_event_history,
        uint32_t begin_time, uint32_t end_time, uint32_t delay_dendritic) {
    log_info("     ##  printing post window  ##");
    post_event_window_t post_window = post_events_get_window_delayed(
            post_event_history, begin_time, end_time);

    while (post_window.num_events > 0) {
        const uint32_t delayed_post_time =
                *post_window.next_time + delay_dendritic;
        log_info("post spike: %u, time: %u, trace: %u",
                post_window.num_events, delayed_post_time,
                *post_window.next_trace);

        post_window = post_events_next(post_window);
    }
}
#endif





// stuff from weight_additive_one_term_impl.h

//---------------------------------------
// Structures
//---------------------------------------
//! The configuration of the rule
typedef struct {
    accum min_weight;     //!< Minimum weight
    accum max_weight;     //!< Maximum weight

    accum a2_plus;        //!< Scaling factor for weight delta on potentiation
    accum a2_minus;       //!< Scaling factor for weight delta on depression
} plasticity_weight_region_data_t;

//! The current state data for the rule
typedef struct {
    accum weight; //!< The starting weight

    uint32_t weight_shift; //!< Weight shift to S1615 version

    //! Reference to the configuration data
    const plasticity_weight_region_data_t *weight_region;
} weight_state_t;



//---------------------------------------
// STDP weight dependence functions
//---------------------------------------
/*!
 * \brief Gets the initial weight state.
 * \param[in] weight: The weight at the start
 * \param[in] synapse_type: The type of synapse involved
 * \return The initial weight state.
 */
static inline weight_state_t weight_get_initial(
        weight_t weight, index_t synapse_type) {
    extern plasticity_weight_region_data_t *plasticity_weight_region_data;
    extern uint32_t *weight_shift;

    accum s1615_weight = kbits(weight << weight_shift[synapse_type]);
    return (weight_state_t) {
        .weight = s1615_weight,
        .weight_shift = weight_shift[synapse_type],
        .weight_region = &plasticity_weight_region_data[synapse_type]
    };
}

//---------------------------------------
//! \brief Apply the depression rule to the weight state
//! \param[in] state: The weight state to update
//! \param[in] a2_minus: The amount of depression to apply
//! \return the updated weight state
static inline weight_state_t weight_one_term_apply_depression(
        weight_state_t state, int32_t a2_minus) {
    state.weight -= mul_accum_fixed(state.weight_region->a2_minus, a2_minus);
    state.weight = kbits(MAX(bitsk(state.weight), bitsk(state.weight_region->min_weight)));
    return state;
}

//---------------------------------------
//! \brief Apply the potentiation rule to the weight state
//! \param[in] state: The weight state to update
//! \param[in] a2_plus: The amount of potentiation to apply
//! \return the updated weight state
static inline weight_state_t weight_one_term_apply_potentiation(
        weight_state_t state, int32_t a2_plus) {
    state.weight += mul_accum_fixed(state.weight_region->a2_plus, a2_plus);
    state.weight = kbits(MIN(bitsk(state.weight), bitsk(state.weight_region->max_weight)));
    return state;
}

//---------------------------------------
/*!
 * \brief Gets the final weight.
 * \param[in] state: The updated weight state
 * \return The new weight.
 */
static inline weight_t weight_get_final(weight_state_t state) {
    return (weight_t) (bitsk(state.weight) >> state.weight_shift);
}

static inline void weight_decay(weight_state_t *state, int32_t decay) {
    state->weight = mul_accum_fixed(state->weight, decay);
}

static inline accum weight_get_update(weight_state_t state) {
    return state.weight;
}



// stuff from timing_pair_impl.h

//---------------------------------------
// Typedefines
//---------------------------------------
//! The type of post-spike traces
typedef int16_t post_trace_t;
//! The type of pre-spike traces
typedef int16_t pre_trace_t;

//---------------------------------------
// Timing dependence inline functions
//---------------------------------------
//! \brief Get an initial post-synaptic timing trace
//! \return the post trace
static inline post_trace_t timing_get_initial_post_trace(void) {
    return 0;
}

static inline post_trace_t timing_decay_post(
        uint32_t time, uint32_t last_time, post_trace_t last_trace) {
    extern int16_lut *tau_minus_lookup;
    // Get time since last spike
    uint32_t delta_time = time - last_time;

    // Decay previous o1 and o2 traces
    return (post_trace_t) STDP_FIXED_MUL_16X16(last_trace,
            maths_lut_exponential_decay(delta_time, tau_minus_lookup));
}

//---------------------------------------
//! \brief Add a post spike to the post trace
//! \param[in] time: the time of the spike
//! \param[in] last_time: the time of the previous spike update
//! \param[in] last_trace: the post trace to update
//! \return the updated post trace
static inline post_trace_t timing_add_post_spike(
        uint32_t time, uint32_t last_time, post_trace_t last_trace) {

    // Decay previous o1 and o2 traces
    int16_t decayed_o1_trace = timing_decay_post(time, last_time, last_trace);

    // Add energy caused by new spike to trace
    // **NOTE** o2 trace is pre-multiplied by a3_plus
    int16_t new_o1_trace = decayed_o1_trace + STDP_FIXED_POINT_ONE;

    // Return new pre- synaptic event with decayed trace values with energy
    // for new spike added
    return (post_trace_t) new_o1_trace;
}

//---------------------------------------
//! \brief Add a pre spike to the pre trace
//! \param[in] time: the time of the spike
//! \param[in] last_time: the time of the previous spike update
//! \param[in] last_trace: the pre trace to update
//! \return the updated pre trace
static inline pre_trace_t timing_add_pre_spike(
        uint32_t time, uint32_t last_time, pre_trace_t last_trace) {
    extern int16_lut *tau_plus_lookup;
    // Get time since last spike
    uint32_t delta_time = time - last_time;

    // Decay previous r1 and r2 traces
    int32_t decayed_r1_trace = STDP_FIXED_MUL_16X16(last_trace,
        maths_lut_exponential_decay(delta_time, tau_plus_lookup));

    // Add energy caused by new spike to trace
    int32_t new_r1_trace = decayed_r1_trace + STDP_FIXED_POINT_ONE;

    log_debug("\tdelta_time=%u, r1=%d\n", delta_time, new_r1_trace);

    // Return new pre-synaptic event with decayed trace values with energy
    // for new spike added
    return (pre_trace_t) new_r1_trace;
}

//---------------------------------------
//! \brief Apply a pre-spike timing rule state update
//! \param[in] time: the current time
//! \param[in] trace: the current pre-spike trace
//! \param[in] last_pre_time: the time of the last pre-spike
//! \param[in] last_pre_trace: the trace of the last pre-spike
//! \param[in] last_post_time: the time of the last post-spike
//! \param[in] last_post_trace: the trace of the last post-spike
//! \param[in] previous_state: the state to update
//! \return the updated state
static inline update_state_t timing_apply_pre_spike(
        uint32_t time, UNUSED pre_trace_t trace, UNUSED uint32_t last_pre_time,
        UNUSED pre_trace_t last_pre_trace, uint32_t last_post_time,
        post_trace_t last_post_trace, update_state_t previous_state) {
    extern int16_lut *tau_minus_lookup;

    // Get time of event relative to last post-synaptic event
    uint32_t time_since_last_post = time - last_post_time;
    int32_t decayed_o1 = STDP_FIXED_MUL_16X16(last_post_trace,
        maths_lut_exponential_decay(time_since_last_post, tau_minus_lookup));

    log_debug("\t\t\ttime_since_last_post_event=%u, decayed_o1=%d\n",
            time_since_last_post, decayed_o1);

    // Apply depression to state (which is a weight_state)
    return weight_one_term_apply_depression(previous_state, decayed_o1);
}

//---------------------------------------
//! \brief Apply a post-spike timing rule state update
//! \param[in] time: the current time
//! \param[in] trace: the current post-spike trace
//! \param[in] last_pre_time: the time of the last pre-spike
//! \param[in] last_pre_trace: the trace of the last pre-spike
//! \param[in] last_post_time: the time of the last post-spike
//! \param[in] last_post_trace: the trace of the last post-spike
//! \param[in] previous_state: the state to update
//! \return the updated state
static inline update_state_t timing_apply_post_spike(
        uint32_t time, UNUSED post_trace_t trace, uint32_t last_pre_time,
        pre_trace_t last_pre_trace, UNUSED uint32_t last_post_time,
        UNUSED post_trace_t last_post_trace, update_state_t previous_state) {
    extern int16_lut *tau_plus_lookup;

    // Get time of event relative to last pre-synaptic event
    uint32_t time_since_last_pre = time - last_pre_time;
    if (time_since_last_pre > 0) {
        int32_t decayed_r1 = STDP_FIXED_MUL_16X16(last_pre_trace,
            maths_lut_exponential_decay(time_since_last_pre, tau_plus_lookup));

        log_debug("\t\t\ttime_since_last_pre_event=%u, decayed_r1=%d\n",
                time_since_last_pre, decayed_r1);

        // Apply potentiation to state (which is a weight_state)
        return weight_one_term_apply_potentiation(previous_state, decayed_r1);
    } else {
        return previous_state;
    }
}

#endif // {{synapseName.upper()}}_IMPL_H
