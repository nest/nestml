#include "spike_processing.h"
#include "param_defs.h"
#include {{ '<' }}comms.h{{ '>' }}
#include {{ '<' }}spinn2.h{{ '>' }}
#include "spinn_log.h"

extern volatile routing_info* routing_info_ptr;

/// Reconfigure the comms with the destination for sending the next SpiNNaker packet
///
/// @param dest: 4 bit vector representing the targetted PEs on the target QPE.
///     The MSB (index 3) is for PE0, the LSB (index 0) is for PE3 following
///     the format in NoC Packets.
/// @param qpex: x coordinate of target QPE
/// @param qpey: y coordinate of target QPE
void comms_reconfigure(uint8_t dest, uint8_t qpex, uint8_t qpey){
    // log_info("comms_reconfigure(%d, %d, %d)\n", dest, qpex, qpey);
    uint32_t tcr =
                (0x3 <<29) |
            ((qpex << COMMS_TCR_DEST_X_SHIFT) & COMMS_TCR_DEST_X_MASK)|
            ((qpey<< COMMS_TCR_DEST_Y_SHIFT) & COMMS_TCR_DEST_Y_MASK);
    tcr |= (dest << COMMS_TCR_DEST_P_SHIFT) & COMMS_TCR_DEST_P_MASK;

    tcr |= COMMS_TCR_TYPE_SPINN;
    tcr |= COMMS_TCR_SPINN_FROUTE_NONE;
    comms[COMMS_TCR_A] = tcr;
    comms[COMMS_TCTL] = 0xE;
}

void send_spikes(uint32_t key) {
    // log_info("send_spikes(%d)\n", key);
    while ((comms[COMMS_TCTL] & 0x80000000) == 0) {
    }
    comms[COMMS_TKR_A] =  key;
}

/// send spikes to all targets
void send_spikes_to_all_targets(uint32_t key) {
    // log_info("send_spikes_to_all_targets(%u)\n", key);
    uint32_t n_targets = routing_info_ptr->n_routing_targets;
    for (uint32_t i=0; i{{ '<' }}n_targets; ++i) {
        routing_target tgt = routing_info_ptr->routing_targets[i];
        comms_reconfigure(tgt.pes, tgt.qpe_x, tgt.qpe_y);
        send_spikes(key);
    }
}

