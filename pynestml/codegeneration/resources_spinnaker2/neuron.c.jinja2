#include "neuron.h"
#include "global_params.h"
#include "simulation.h"

uint32_t n_neurons;
extern input_t input_buffers[INPUT_BUFFER_SIZE];
neuron_impl_t neuron_array[N_NEURONS];
neuron_params_t neuron_params_array[N_NEURONS] __attribute__((section(".myNeuronParamsSection")));
global_neuron_params_t global_neuron_params;
REAL weight_scaling_factor;

// spike records for current timestep
uint32_t spike_records[SPIKE_RECORD_LENGTH] __attribute__((aligned(0x10)));
uint32_t spike_records_count[SPIKE_RECORD_COUNTER_LENGTH];

extern uint32_t* spike_records_all_timesteps;
extern uint32_t* voltage_records_all_timesteps;
extern uint32_t systicks;
extern uint32_t pe_id;
extern uint32_t qpe_x;
extern uint32_t qpe_y;
extern volatile routing_info* routing_info_ptr;
extern volatile struct global_params* global_params_ptr;
extern simulation_config sim_config;


bool neuron_initialise() {
    n_neurons = N_NEURONS;
    clear_spike_record();

    // neuron states
    for (index_t neuron_index = 0; neuron_index < n_neurons; neuron_index++) {
{#        neuron_params_t* neuron_params = &neuron_params_array[neuron_index];#}
        neuron_pointer_t neuron = &neuron_array[neuron_index];
        neuron_state_t* state = &neuron->state;
        {% set updated_state_dict = utils.generate_updated_state_dict(initial_values, neuron.get_parameter_value_dict()) %}
        {%- for name, value in updated_state_dict | dictsort %}
            state->{{ name }} = {{ value }};
        {%- endfor %}
    }

    return true;
}

void print_neuron_params() {
    log_info("Neuron params:\n");
    uint32_t n_used_neurons = global_params_ptr->n_used_neurons;
    for (index_t neuron_index = 0; neuron_index < n_used_neurons; neuron_index++) {
        neuron_params_t* neuron_params = &neuron_params_array[neuron_index];

        {%- for  name, value in neuron.get_parameter_value_dict() | dictsort %}
            log_info("%u:  {{ name }}=%i\n",
            neuron_index,(int32_t) (f2ui(neuron_params->{{  name }})));
        {%- endfor %}
{% if uses_analytic_solver == True %}
        {%- for  name, value in propagators | dictsort %}
            log_info("%u:  {{ name }}=%i\n",
            neuron_index,(int32_t) (f2ui(neuron_params->{{  name }})));
        {%- endfor %}
{%- endif  %}
    }
}

void record_voltages() {
    if (global_params_ptr->record_v == 1) { // record all voltages
        *voltage_records_all_timesteps = systicks;
        voltage_records_all_timesteps++;

        uint32_t n_used_neurons = global_params_ptr->n_used_neurons;
        // neuron states
        for (index_t neuron_index = 0; neuron_index < n_used_neurons; neuron_index++) {
            *voltage_records_all_timesteps = f2ui(neuron_array[neuron_index].state.V_m);
            voltage_records_all_timesteps++;
        }
    }
    else if (global_params_ptr->record_v == 2) { // record last voltage only
        if (systicks == sim_config.n_simulation_ticks - 1) {
            log_info("Recording voltages at last time step %i", systicks);
            *voltage_records_all_timesteps = systicks;
            voltage_records_all_timesteps++;

            uint32_t n_used_neurons = global_params_ptr->n_used_neurons;
            // neuron states
            for (index_t neuron_index = 0; neuron_index < n_used_neurons; neuron_index++) {
                *voltage_records_all_timesteps = f2ui(neuron_array[neuron_index].state.V_m);
                voltage_records_all_timesteps++;
            }
        }
    }
}

void neuron_do_timestep_update() {
    clear_spike_record();
    uint32_t n_used_neurons = global_params_ptr->n_used_neurons;
    for (index_t neuron_index = 0; neuron_index < n_used_neurons; neuron_index++) {

        neuron_pointer_t neuron = &neuron_array[neuron_index];
        neuron_params_t* neuron_params = &neuron_params_array[neuron_index];
        neuron_state_t* state = &neuron->state;
{#        neuron_input_t* input = &neuron->input;#}
{# GENERATE THIS!#}
        state->I_syn_exc = synapse_types_get_excitatory_input(input_buffers, neuron_index);
        state->I_syn_inh = synapse_types_get_inhibitory_input(input_buffers, neuron_index);
{# GENERATE THIS!#}
        {%- if neuron.get_update_blocks() %}
        {%-   filter indent(8) %}
        {%-     for block in neuron.get_update_blocks() %}
        {%-       set ast = block.get_stmts_body() %}
        {%-       if ast.print_comment('*')|length > 1 %}
        /*
         {{ast.print_comment('*')}}
         */
        {%-       endif %}
        {%-       include "directives_cpp/StmtsBody.jinja2" %}
        {%-     endfor %}
        {%-   endfilter %}
        {%- endif %}
    neuron_check_and_spike(state, neuron_params, neuron_index);
    }
    send_spike_record();
    record_voltages();
}

void neuron_check_and_spike(neuron_state_t* state, neuron_params_t* neuron_params, index_t neuron_index) {  // onCondition block processing
    {%- if neuron.get_on_condition_blocks() %}
    {%-   filter indent(8) %}
    {%-     for block in neuron.get_on_condition_blocks() %}
if ({{ printer.print(block.get_cond_expr()) }}){
    {%-       set ast = block.get_stmts_body() %}
    {%-       if ast.print_comment('*')|length > 1 %}
    /*
     {{ast.print_comment('*')}}
     */
    {%-       endif %}
    {%-       include "directives_cpp/StmtsBody.jinja2" %}
    {%-     endfor %}
    {%-   endfilter %}
    {%- endif %}
{#    record_spike(neuron_index);#}
{#    log_info("spike should be recorded\n");#}
{#    send_spikes_to_all_targets(routing_info_ptr->key_offset + neuron_index);#}
    }
}

void record_spike(uint32_t neuron_id){
	spike_records[neuron_id/32+2] |= 1 << ( neuron_id - neuron_id/32*32);
	log_info("neuron id %u:  value=%i\n", neuron_id/32+2, spike_records[neuron_id/32+2]);
	spike_records_count[neuron_id/32]++;
}


void neuron_reset(){
	clear_spike_record();
}

void send_spike_record(){
    if (global_params_ptr->record_spikes) {
        spike_records[0]=pe_id;
        spike_records[1]=systicks;
        for(uint32_t i = 0; i < SPIKE_RECORD_LENGTH; i++){
            *spike_records_all_timesteps = spike_records[i];
            spike_records_all_timesteps++;
        }
    }
}

void clear_spike_record(){
	for (uint32_t i = 0; i < SPIKE_RECORD_LENGTH ; i++){
    spike_records[i]=0;
	}
	for (uint32_t i = 0 ; i < SPIKE_RECORD_COUNTER_LENGTH ; i++){
		spike_records_count[i]=0;
	}
}

bool input_buffer_initialise() {
    for (uint32_t i = 0; i < INPUT_BUFFER_SIZE; i++) {
        input_buffers[i] = 0;
    }
    return true;
}

