{#-
SynapseHeader.jinja2

This file is part of NEST.

Copyright (C) 2004 The NEST Initiative

NEST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

NEST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with NEST.  If not, see <http://www.gnu.org/licenses/>.
#}
{%- if tracing %}/* generated by {{self._TemplateReference__context.name}} */ {% endif -%}
/**
 *  {{synapseName}}.h
 *
 *  This file is part of NEST.
 *
 *  Copyright (C) 2004 The NEST Initiative
 *
 *  NEST is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  NEST is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  Generated from NESTML at time: {{now}}
**/

#ifndef {{synapseName.upper()}}_H
#define {{synapseName.upper()}}_H

// C++ includes:
#include <cmath>

// Includes from nestkernel:
#include "common_synapse_properties.h"
#include "connection.h"
#include "connector_model.h"
#include "event.h"
{%- if norm_rng %}

// Includes for random number generator
#include "random_generators.h"
{%- endif %}

// Includes from sli:
#include "dictdatum.h"
#include "dictutils.h"

/** @BeginDocumentation
{{ synapse.print_comment() }}
**/

#define POST_NEURON_TYPE {{ paired_neuron }}

// #define DEBUG

namespace nest
{

/** @BeginDocumentation

**/
class {{synapseName}}CommonSynapseProperties : public CommonSynapseProperties {
public:

    {{synapseName}}CommonSynapseProperties()
    : CommonSynapseProperties()
    {
{%- filter indent(width=8) %}
{%- for parameter in synapse.get_parameter_symbols() %}
{%-     set isHomogeneous = PyNestMLLexer["DECORATOR_HOMOGENEOUS"] in parameter.get_decorators() %}
{%-     if isHomogeneous %}
{%-         with variable = parameter %}
{%-             include "directives/CommonPropertiesDictionaryMemberInitialization.jinja2" %}
{%-         endwith %}
{%-     endif %}
{%- endfor %}
{%- endfilter %}
    }

    /**
     * Get all properties and put them into a dictionary.
     */
    void get_status( DictionaryDatum& d ) const
    {
        CommonSynapseProperties::get_status( d );

{%- filter indent(width=8) %}
{%- for parameter in synapse.get_parameter_symbols() %}
{%-     set isHomogeneous = PyNestMLLexer["DECORATOR_HOMOGENEOUS"] in parameter.get_decorators() %}
{%-     if isHomogeneous %}
{%-         set namespaceName = parameter.get_namespace_decorator("nest") %}
{%-         if namespaceName == '' %}
{{ raise('nest::names decorator is required for parameter "%s" when used in a common properties class' % names.name(parameter)) }}
{%-         endif %}
{%-         with variable = parameter %}
{%-             include "directives/CommonPropertiesDictionaryWriter.jinja2" %}
{%-         endwith %}
{%-     endif %}
{%- endfor %}
{%- endfilter %}
    }
    
    
    /**
     * Set properties from the values given in dictionary.
     */
    void set_status( const DictionaryDatum& d, ConnectorModel& cm )
    {
        CommonSynapseProperties::set_status( d, cm );

{%- filter indent(width=8) %}
{%- for parameter in synapse.get_parameter_symbols() %}
{%-     set isHomogeneous = PyNestMLLexer["DECORATOR_HOMOGENEOUS"] in parameter.get_decorators() %}
{%-     if isHomogeneous %}
{%-         set namespaceName = parameter.get_namespace_decorator("nest") %}
{%-         if (namespaceName == '') %}
        {{ raise('nest::names decorator is required for parameter "%s" when used in a common properties class' % names.name(parameter)) }}
{%-         endif %}
{%-         with variable = parameter %}
{%-             include "directives/CommonPropertiesDictionaryReader.jinja2" %}
{%-         endwith %}
{%-     endif %}
{%- endfor %}
{%- endfilter %}
    }

    // N.B.: we define all parameters as public for easy reference conversion later on.
    // This may or may not benefit performance (TODO: compare with inline getters/setters)

{%- for parameter in synapse.get_parameter_symbols() %}
{%-     set isHomogeneous = PyNestMLLexer["DECORATOR_HOMOGENEOUS"] in parameter.get_decorators() %}
{%-     if (isHomogeneous) %}
{%-         set parameterName = names.name(parameter) %}
    {{declarations.print_variable_type(parameter)}} {{parameter.get_symbol_name()}};
{%-     endif %}
{%- endfor %}
};


/**
 * Class representing a static connection. A static connection has the
 * properties weight, delay and receiver port. A suitable Connector containing
 * these connections can be obtained from the template GenericConnector.
 */
template < typename targetidentifierT >
class {{synapseName}} : public Connection< targetidentifierT >
{

private:

//  double *weight_;
  double t_lastspike_;


  /**
  * Dynamic state of the synapse.
  *
  *
  * These are the state variables that are advanced in time by calls to
  * @c update(). In many models, some or all of them can be set by the user
  * through @c SetStatus. The state variables are initialized from the model
  * prototype when the node is created. State variables are reset by @c ResetNetwork.
  *
  * @note State_ need neither copy constructor nor @c operator=(), since
  *       all its members are copied properly by the default copy constructor
  *       and assignment operator. Important:
  *       - If State_ contained @c Time members, you need to define the
  *         assignment operator to recalibrate all members of type @c Time . You
  *         may also want to define the assignment operator.
  *       - If State_ contained members that cannot copy themselves, such
  *         as C-style arrays, you need to define the copy constructor and
  *         assignment operator to copy those members.
  */
  struct State_{
{%- if not useGSL %}
{%-   filter indent(4,True) %}
{%-   for variable in synapse.get_state_symbols() %}
{%-     include "directives/MemberDeclaration.jinja2" %}
{%-   endfor %}
{%-   endfilter %}
{%- else %}
    //! Symbolic indices to the elements of the state vector y
    enum StateVecElems{
{# N.B. numeric solver contains all state variables, including those that will be solved by analytic solver#}
{%-   if uses_numeric_solver %}
      // numeric solver state variables
{%-     for variable_name in numeric_state_variables: %}
      {{variable_name}},
{%-     endfor %}
{%-   endif %}
      STATE_VEC_SIZE
    };
    //! state vector, must be C-array for GSL solver
    double ode_state[STATE_VEC_SIZE];

    // state variables from state block
{%-   filter indent(4,True) %}
{%-   for variable in synapse.get_state_symbols() %}
{%-     include "directives/MemberDeclaration.jinja2" %}
{%-   endfor %}
{%-   endfilter %}
{%- endif %}

    State_() {};
  };
   
  // -------------------------------------------------------------------------
  //   Getters/setters for state block
  // -------------------------------------------------------------------------

{% filter indent(2, True) -%}
{%- for state in synapse.get_state_symbols() %}
{%-    with variable = state %}
{%-       include "directives/MemberVariableGetterSetter.jinja2" %}
{%-    endwith %}
{%- endfor %}
{%- endfilter %}
  // -------------------------------------------------------------------------
  //   Getters/setters for parameters
  // -------------------------------------------------------------------------




{% filter indent(2, True) -%}
{%- for parameter in synapse.get_parameter_symbols() %}
{%-     set isHomogeneous = PyNestMLLexer["DECORATOR_HOMOGENEOUS"] in parameter.get_decorators() %}
{%-     if (not isHomogeneous) %}
{%-     with variable = parameter %}
{%-        include "directives/MemberVariableGetterSetter.jinja2" %}
{%-     endwith %}
{%-     endif %}
{%- endfor %}
{%- endfilter %}
  // -------------------------------------------------------------------------
  //   Getters/setters for inline expressions
  // -------------------------------------------------------------------------
{% filter indent(2, True) -%}
{%- for funcsym in synapse.get_inline_expression_symbols() %}
{%-    with variable = funcsym %}
{%-        include "directives/MemberVariableGetterSetter.jinja2" %}
{%-    endwith %}
{%- endfor %}
{%- endfilter %}
  // -------------------------------------------------------------------------
  //   Function declarations
  // -------------------------------------------------------------------------

{% filter indent(2) -%}
{% for function in synapse.get_functions() %}
  {{printer.print_function_declaration(function)}};
{% endfor %}
{%- endfilter %} 

  /**
  * Free parameters of the synapse.
  *
  {{synapse.print_parameter_comment("*")}}
  *
  * These are the parameters that can be set by the user through @c SetStatus.
  * They are initialized from the model prototype when the node is created.
  * Parameters do not change during calls to @c update() and are not reset by
  * @c ResetNetwork.
  *
  * @note Parameters_ need neither copy constructor nor @c operator=(), since
  *       all its members are copied properly by the default copy constructor
  *       and assignment operator. Important:
  *       - If Parameters_ contained @c Time members, you need to define the
  *         assignment operator to recalibrate all members of type @c Time . You
  *         may also want to define the assignment operator.
  *       - If Parameters_ contained members that cannot copy themselves, such
  *         as C-style arrays, you need to define the copy constructor and
  *         assignment operator to copy those members.
  */
  struct Parameters_{
{%- filter indent(4,True) %}
{%- for variable in synapse.get_parameter_symbols() %}
{%-     set isHomogeneous = PyNestMLLexer["DECORATOR_HOMOGENEOUS"] in variable.get_decorators() %}
{%-     if (not isHomogeneous) %}
{%-   include 'directives/MemberDeclaration.jinja2' %}
{%-     else %}
    // N.B. the parameter `{{names.name(variable)}}` is defined in the common properties class
{%-     endif %}
{%- endfor %}
{%- endfilter %}

{% if useGSL %}
    double __gsl_error_tol;
{% endif %}

    /** Initialize parameters to their default values. */
    Parameters_() {};
  };

  /**
  * Internal variables of the synapse.
  *
  {{synapse.print_internal_comment('*')}}
  *
  * These variables must be initialized by @c calibrate, which is called before
  * the first call to @c update() upon each call to @c Simulate.
  * @node Variables_ needs neither constructor, copy constructor or assignment operator,
  *       since it is initialized by @c calibrate(). If Variables_ has members that
  *       cannot destroy themselves, Variables_ will need a destructor.
  */
  struct Variables_ {
{%- for variable in synapse.get_internal_symbols() %}
{%-     filter indent(4,True) %}
{%-     include "directives/MemberDeclaration.jinja2" %}
{%-     endfilter %}
{%- endfor %}
  };
  
    Parameters_ P_;  //!< Free parameters.
    State_      S_;  //!< Dynamic state.
    Variables_  V_;  //!< Internal Variables
{#
  /**
   * All parameters marked as homogeneous will go into a CommonPropertiesDictionary
  **/

  {% for parameter in synapse.get_parameter_symbols() %}
    {%- set isHomogeneous = PyNestMLLexer["DECORATOR_HOMOGENEOUS"] in parameter.get_decorators() %}
    {%- if (isHomogeneous) %}
    // {-{ assert ( decl.get_variables()|length == 1 ) }-}
    {%- set parameterName = names.name(parameter) %}
    !!! homeogensou decl -->> {{parameterName}}
    {%- endif %}
  {%- endfor %}

    {%- set isHeterogeneous = PyNestMLLexer["DECORATOR_HETEROGENEOUS"] in parameter.get_decorators() %}
    {%- if (isHeterogeneous) %}
    {%- set parameterName = decl.get_variables()[0].name %}
  heterogen decl -->> {{parameterName}}
    {%- endif %}
#}

public:

    // this line determines which common properties to use
    typedef {{synapseName}}CommonSynapseProperties CommonPropertiesType;

    typedef Connection< targetidentifierT > ConnectionBase;

    /**
    * Default constructor.
    * 
    * Sets default values for all parameters (skipping common properties).
    * 
    * Needed by GenericConnectorModel.
    */
    {{synapseName}}();


    /**
    * Copy constructor from a property object.
    * 
    * Sets default values for all parameters (skipping common properties).
    * 
    * Needs to be defined properly in order for GenericConnector to work.
    */
    {{synapseName}}( const {{synapseName}}& rhs );
  

    void init_internals_block_symbols();

  // Explicitly declare all methods inherited from the dependent base
  // ConnectionBase. This avoids explicit name prefixes in all places these
  // functions are used. Since ConnectionBase depends on the template parameter,
  // they are not automatically found in the base class.
  using ConnectionBase::get_delay_steps;
  using ConnectionBase::set_delay_steps;
  using ConnectionBase::get_delay;
  using ConnectionBase::set_delay;
  using ConnectionBase::get_rport;
  using ConnectionBase::get_target;


  class ConnTestDummyNode : public ConnTestDummyNodeBase
  {
  public:
    // Ensure proper overriding of overloaded virtual functions.
    // Return values from functions are ignored.
    using ConnTestDummyNodeBase::handles_test_event;
    port
    handles_test_event( SpikeEvent&, rport )
    {
      return invalid_port_;
    }
    port
    handles_test_event( RateEvent&, rport )
    {
      return invalid_port_;
    }
    port
    handles_test_event( DataLoggingRequest&, rport )
    {
      return invalid_port_;
    }
    port
    handles_test_event( CurrentEvent&, rport )
    {
      return invalid_port_;
    }
    port
    handles_test_event( ConductanceEvent&, rport )
    {
      return invalid_port_;
    }
    port
    handles_test_event( DoubleDataEvent&, rport )
    {
      return invalid_port_;
    }
    port
    handles_test_event( DSSpikeEvent&, rport )
    {
      return invalid_port_;
    }
    port
    handles_test_event( DSCurrentEvent&, rport )
    {
      return invalid_port_;
    }
  };


  /**
   * Get named parameter from the `Parameter_` struct
  **/
/*  template < typename T >
  T* get_named_parameter(const Name &n) {
{%- for parameter in synapse.get_parameter_symbols() %}
{%-     set namespaceName = parameter.get_namespace_decorator("nest") %}
    if (n == names::{{namespaceName}}) {
      return &{{printer.print_origin(parameter)}}{{names.name(parameter)}}; // type: {- {declarations.print_variable_type(parameter)} -}
    }
{%- endfor %}

    assert(false);    // unknown name requested
  }
*/
inline void set_weight(double w) {
assert(0);
}
{#
/*
  
  {{printer.print_origin(weight_parameter)}}{{names.name(weight_parameter)}} = w; // type: {{declarations.print_variable_type(weight_parameter)}}

{%- for parameter in synapse.get_parameter_symbols() %}
{%-     set namespaceName = parameter.get_namespace_decorator('nest') %}
{%-     if (namespaceName == 'weight') %}
{%-         set isHomogeneous = PyNestMLLexer["DECORATOR_HOMOGENEOUS"] in parameter.get_decorators() %}
{%-         if isHomogeneous %}
    throw BadProperty(
      "Setting of individual weights is not possible! The common weights can "
      "be changed via CopyModel()." );
{%-         else %}
    {{printer.print_origin(parameter)}}{{names.name(parameter)}} = w; // type: {{declarations.print_variable_type(parameter)}}
{%-         endif %}
{%-     endif %}
{%- endfor %}
  }
*/
#}

/*  inline double get_weight() {
{%- for parameter in synapse.get_parameter_symbols() %}
{%-     set namespaceName = parameter.get_namespace_decorator('nest') %}
{%-     if (namespaceName == 'weight') %}
{%-         set isHomogeneous = PyNestMLLexer["DECORATOR_HOMOGENEOUS"] in parameter.get_decorators() %}
{%-         if isHomogeneous %}
    return cp.{{printer.print_origin(parameter)}}{{names.name(parameter)}}; // type: {{declarations.print_variable_type(parameter)}}   // XXX: replace with get_status or throw()
{%-         else %}
    return {{printer.print_origin(parameter)}}{{names.name(parameter)}}; // type: {{declarations.print_variable_type(parameter)}}
{%-         endif %}
{%-     endif %}
{%- endfor %}
  }
*/
  void
  check_connection( Node& s,
    Node& t,
    rport receptor_type,
    const CommonPropertiesType& )
  {
    ConnTestDummyNode dummy_target;
    ConnectionBase::check_connection_( dummy_target, s, t, receptor_type );

{%- if paired_neuron is defined %}
    try {
      dynamic_cast<{{paired_neuron}}&>(t);
    }
    catch (std::bad_cast &exp) {
      std::cout << "wrong type of neuron connected! Synapse '{{synapseName}}' will only work with neuron '{{paired_neuron}}'.\n";
      exit(1);
    }
{%- endif %}
    t.register_stdp_connection( t_lastspike_ - get_delay(), get_delay() );
  }

  void
  send( Event& e, const thread tid, const {{synapseName}}CommonSynapseProperties& cp )
  {


    auto get_thread = [tid]()
    {
        return tid;
    };
     
    // synapse STDP depressing/facilitation dynamics
    const double __t_spike = e.get_stamp().get_ms();
#ifdef DEBUG
    std::cout << "{{synapseName}}::send(): handling pre spike at t = " << __t_spike << std::endl;
#endif

    // use accessor functions (inherited from Connection< >) to obtain delay and target
{%- if paired_neuron is not none and paired_neuron|length > 0 %}
    {{paired_neuron}}* __target = static_cast<{{paired_neuron}}*>(get_target(tid));
{%- else %}
    Node* __target = get_target( tid );
{%- endif %}
    const double __dendritic_delay = get_delay();

    if (t_lastspike_ < 0.) {
        // this is the first presynaptic spike to be processed
        t_lastspike_ = 0.;
    }

{%- if paired_neuron is not none and paired_neuron|length > 0 %}
    double timestep = 0;

    {
      // get spike history in relevant range (t1, t2] from post-synaptic neuron
      std::deque< histentry__ >::iterator start;
      std::deque< histentry__ >::iterator finish;

      // For a new synapse, t_lastspike_ contains the point in time of the last
      // spike. So we initially read the
      // history(t_last_spike - dendritic_delay, ..., T_spike-dendritic_delay]
      // which increases the access counter for these entries.
      // At registration, all entries' access counters of
      // history[0, ..., t_last_spike - dendritic_delay] have been
      // incremented by Archiving_Node::register_stdp_connection(). See bug #218 for
      // details.
      __target->get_history__( t_lastspike_ - __dendritic_delay,
        __t_spike - __dendritic_delay,
        &start,
        &finish );
      // facilitation due to post-synaptic spikes since last pre-synaptic spike
      while ( start != finish )
      {
        double minus_dt = t_lastspike_ - ( start->t_ + __dendritic_delay );
        // get_history() should make sure that
        // start->t_ > t_lastspike_ - dendritic_delay, i.e. minus_dt < 0
        assert( minus_dt < -kernel().connection_manager.get_stdp_eps() );

#ifdef DEBUG
        std::cout << "{{synapseName}}::send(): \tprocessing post spike at t = " << start->t_ << std::endl;
#endif
        
        /**
         * update synapse internal state from `t_lastspike_` to `start->t_`
        **/

        const double old___h = V_.__h;
        V_.__h = (start->t_ + __dendritic_delay) - t_lastspike_;
        timestep += V_.__h;
        init_internals_block_symbols();
{%- filter indent(6, True) %}
{%- include "directives/AnalyticIntegrationStep_begin.jinja2" %}
{%- if uses_numeric_solver %}
{%-     include "directives/GSLIntegrationStep.jinja2" %}
{%- endif %}
{%- include "directives/AnalyticIntegrationStep_end.jinja2" %}
{%- endfilter %}
        V_.__h = old___h;
        init_internals_block_symbols();  // XXX: can be skipped?


        /**
         *  NESTML generated postReceive code block begins here!
        **/

#ifdef DEBUG
        std::cout << "\tFacilitating, old w = " << S_.w << "\n";
#endif
        const double _tr_t = start->t_;

{%- filter indent(6, True) %}
{%- if synapse.get_post_receive() is not none %}
{%- set dynamics = synapse.get_post_receive() %}
{%- with ast = dynamics.get_block() %}
{%-     include "directives/Block.jinja2" %}
{%- endwith %}
{%- endif %}
{%- endfilter %}

#ifdef DEBUG
      std::cout << "\t--> new w = " << S_.w << std::endl;
#endif

        /**
         * internal state has now been fully updated to `start->t_ + __dendritic_delay`
        **/
        
        t_lastspike_ = start->t_ + __dendritic_delay;
        ++start;
      }
    }
{%- endif %}
    /**
     * update synapse internal state from `t_lastspike_` to `__t_spike`
    **/

    const double old___h = V_.__h;
    V_.__h = __t_spike - t_lastspike_;
    if (V_.__h > 1E-9) {
      init_internals_block_symbols();
{%- filter indent(6, True) %}
{%- include "directives/AnalyticIntegrationStep_begin.jinja2" %}
{%- if uses_numeric_solver %}
{%-     include "directives/GSLIntegrationStep.jinja2" %}
{%- endif %}
{%- include "directives/AnalyticIntegrationStep_end.jinja2" %}
{%- endfilter %}
    }
    V_.__h = old___h;
    init_internals_block_symbols();  // XXX: can be skipped?


    /**
     *  NESTML generated preReceive code block begins here!
    **/

    const double _tr_t = __t_spike - __dendritic_delay;

#ifdef DEBUG
    std::cout << "\tDepressing, old w = " << S_.w << "\n";
#endif


{%- filter indent(4,True) %}
{%- set dynamics = synapse.get_pre_receive() %}
{%- with ast = dynamics.get_block() %}
{%-     include "directives/Block.jinja2" %}
{%- endwith %}
{%- endfilter %}

#ifdef DEBUG
    std::cout <<"\t-> new w = " << S_.w << std::endl;
#endif

    /**
     *  update all convolutions with pre spikes
    **/

    // XXX: TODO: place this before resp. after the preReceive block to emulate ``before_increment``

{# {%- for inputLine in synapse.get_spike_buffers() %} #}
{%- for spike_update in spike_updates: %}
    S_.{{names.name(synapse.get_state_blocks().get_scope().resolve_to_symbol(spike_update.get_variable().get_complete_name(), SymbolKind.VARIABLE))}} += 1.;
{#    S_.{{names.name(spike_update.get_variable())}} += 1.; #}
{%- endfor %}


    /**
     *  synapse internal state has now been fully updated to `__t_spike`
    **/

    t_lastspike_ = __t_spike;
  }

  void get_status( DictionaryDatum& d ) const;

  void set_status( const DictionaryDatum& d, ConnectorModel& cm );

{%- if norm_rng %}

  nest::normal_distribution normal_dev_; //!< random deviate generator
{%- endif %}
};

template < typename targetidentifierT >
void
{{synapseName}}< targetidentifierT >::get_status( DictionaryDatum& __d ) const
{
  ConnectionBase::get_status( __d );
  def< long >( __d, names::size_of, sizeof( *this ) );

  // parameters
{%- for parameter in synapse.get_parameter_symbols() %}
{%-     set isHomogeneous = PyNestMLLexer["DECORATOR_HOMOGENEOUS"] in parameter.get_decorators() %}
{%-     if (not isHomogeneous) %}
{%- set namespaceName = parameter.get_namespace_decorator('nest') %}
{%- if namespaceName == '' %}
{%-   with variable = parameter %}
{%-   filter indent(2,True) %}
{%-   include "directives/WriteInDictionary.jinja2" %}
{%-   endfilter %}
{%-   endwith %}
{%- else %}
  def< {{declarations.print_variable_type(parameter)}} >( __d, names::{{namespaceName}}, {{printer.print_origin(parameter)}}{{names.name(parameter)}} );
{%- endif %}
{%- endif %}
{%- endfor %}

  // initial values for state variables in ODE or kernel
{%- for init in synapse.get_state_symbols() %}
{%-     with variable = init %}
{%-     if not is_delta_kernel(synapse.get_kernel_by_name(init.name)) %}
{%-         filter indent(2,True) %}
{%-         include "directives/WriteInDictionary.jinja2" %}
{%-         endfilter %}
{%-     endif %}
{%-     endwith %}
{%- endfor %}
}

template < typename targetidentifierT >
void
{{synapseName}}< targetidentifierT >::set_status( const DictionaryDatum& __d,
  ConnectorModel& cm )
{
    
    // parameters
{%- for parameter in synapse.get_parameter_symbols() %}
{%-     set namespaceName = parameter.get_namespace_decorator('nest') %}
{%-     set isHomogeneous = PyNestMLLexer["DECORATOR_HOMOGENEOUS"] in parameter.get_decorators() %}
{%-     if (not isHomogeneous) %}
{%-         with variable = parameter %}
{%-             filter indent(2,True) %}
{%-             include "directives/ReadFromDictionaryToTmp.jinja2" %}
{%-             endfilter %}
{%-         endwith %}
{%-     endif %}
{%- endfor %}

  // initial values for state variables in ODE or kernel
{%- for init in synapse.get_state_symbols() %}
{%-     with variable = init %}
{%-         if not is_delta_kernel(synapse.get_kernel_by_name(init.name)) %}
{%-             filter indent(2,True) %}
{%-             include "directives/ReadFromDictionaryToTmp.jinja2" %}
{%-             endfilter %}
{%-         endif %}
{%-     endwith %}
{%- endfor %}

  // We now know that (ptmp, stmp) are consistent. We do not
  // write them back to (P_, S_) before we are also sure that
  // the properties to be set in the parent class are internally
  // consistent.
  ConnectionBase::set_status( __d, cm );

  // if we get here, temporaries contain consistent set of properties
{%- for parameter in synapse.get_parameter_symbols() %}
{%-      set namespaceName = parameter.get_namespace_decorator('nest') %}
{%-      set isHomogeneous = PyNestMLLexer["DECORATOR_HOMOGENEOUS"] in parameter.get_decorators() %}
{%-      if (not isHomogeneous) %}
{%-          with variable = parameter %}
{%-              filter indent(2,True) %}
{%-              include "directives/AssignTmpDictionaryValue.jinja2" %}
{%-              endfilter %}
{%-         endwith %}
{%-      endif %}
{%- endfor %}

{%- for init in synapse.get_state_symbols() %}
{%-     with variable = init %}
{%-         if not is_delta_kernel(synapse.get_kernel_by_name(init.name)) %}
{%-             filter indent(2,True) %}
{%-             include "directives/AssignTmpDictionaryValue.jinja2" %}
{%-             endfilter %}
{%-         endif %}
{%-     endwith %}
{%- endfor %}

{% for invariant in synapse.get_parameter_invariants() %}
  if ( !({{printer.print_expression(invariant)}}) ) {
    throw nest::BadProperty("The constraint '{{idemPrinter.print_expression(invariant)}}' is violated!");
  }
{%- endfor %}

{% if useGSL %}
  updateValue< double >(__d, nest::names::gsl_error_tol, P_.__gsl_error_tol);
  if ( P_.__gsl_error_tol <= 0. ){
    throw nest::BadProperty( "The gsl_error_tol must be strictly positive." );
  }
{% endif %}



  // special treatment of NEST delay
  set_delay(
{%- for parameter in synapse.get_parameter_symbols() %}
{%-     set namespaceName = parameter.get_namespace_decorator("nest") %}
{%-     if namespaceName == "delay" %}
{{ names.getter(parameter) }}()
{%-     endif %}
{%- endfor %}
  );

  
}





/**
 * NESTML internals block symbols initialisation
**/
template < typename targetidentifierT >
void {{synapseName}}< targetidentifierT >::init_internals_block_symbols()
{
{%- for variable in synapse.get_internal_symbols() %}
{%-     if not variable.get_symbol_name() == "__h" %}
{%-         include "directives/Calibrate.jinja2" %}
{%-     endif %}
{%- endfor %}
}

/**
 * constructor
**/
template < typename targetidentifierT >
{{synapseName}}< targetidentifierT >::{{synapseName}}() : ConnectionBase()
{

{%- for parameter in synapse.get_parameter_symbols() %}
{%-     with variable = parameter %}
{%-         set isHomogeneous = PyNestMLLexer["DECORATOR_HOMOGENEOUS"] in variable.get_decorators() %}
{%-         if (not isHomogeneous) %}
{%-             include "directives/MemberInitialization.jinja2" %}
{%-         endif %}
{%-     endwith %}
{%- endfor %}

    V_.__h = nest::Time::get_resolution().get_ms();
    init_internals_block_symbols();

  // initial values for state variables in ODE or kernel
{%- for init in synapse.get_state_symbols() %}
{%-     with variable = init %}
{%-         include "directives/MemberInitialization.jinja2" %}
{%-     endwith %}
{%- endfor %}
    
    
    //weight_ = get_named_parameter<double>(names::weight);
    //set_weight( 1. );   // XXX: TODO: set weight to default value specified in nestml file; if no default specified, use 1.
    t_lastspike_ = 0.;
}

/**
 * copy constructor
**/
template < typename targetidentifierT >
{{synapseName}}< targetidentifierT >::{{synapseName}}( const {{synapseName}}< targetidentifierT >& rhs )
{
{%- for parameter in synapse.get_parameter_symbols() %}
{%-     set isHomogeneous = PyNestMLLexer["DECORATOR_HOMOGENEOUS"] in parameter.get_decorators() %}
{%-     if (not isHomogeneous) %}
    {{printer.print_origin(parameter)}}{{names.name(parameter)}} = rhs.{{printer.print_origin(parameter)}}{{names.name(parameter)}};
{%-     endif %}
{%- endfor %}

  // state variables in ODE or kernel
{%- for init in synapse.get_state_symbols() %}
{%-     with variable = init %}
    {{printer.print_origin(variable)}}{{names.name(variable)}} = rhs.{{printer.print_origin(variable)}}{{names.name(variable)}};
{%-     endwith %}
{%- endfor %}

    //weight_ = get_named_parameter<double>(names::weight);
    //set_weight( *rhs.weight_ );
    t_lastspike_  = rhs.t_lastspike_;

    // special treatment of NEST delay
    set_delay(rhs.get_delay());
}

} // namespace

#endif /* #ifndef {{synapseName.upper()}}_H */
