{#
  Generates a code snippet that retrieves a data from dictionary and sets it the the model variable.
  @param variable VariableSymbol
#}
{%- import 'directives/VectorSizeParameter.jinja2' as vector_size_parameter with context %}
{%- if tracing %}/* generated by {{self._TemplateReference__context.name}} */ {% endif %}

{%- if not variable.is_inline_expression %}
{%- if not variable.is_state() %}
{{declarations.print_variable_type(variable)}} tmp_{{names.name(variable)}} = {{names.getter(variable)}}();
{%- if synapse is defined or variable in vector_symbols %}
updateValue<{{declarations.print_variable_type(variable)}}>(__d, nest::{{names_namespace}}::_{{names.name(variable)}}, tmp_{{names.name(variable)}});
{%- else %}
nest::updateValueParam<{{declarations.print_variable_type(variable)}}>(__d, nest::{{names_namespace}}::_{{names.name(variable)}}, tmp_{{names.name(variable)}}, this);
{%- endif %}

{%- if vector_symbols|length > 0 %}
// Resize vectors
if (tmp_{{names.name(variable)}} != {{names.getter(variable)}}())
{
{%- for vector_var in vector_symbols %}
{%- if vector_var.get_vector_parameter().is_variable() and vector_var.get_vector_parameter().get_variable().get_complete_name() == variable.get_symbol_name() %}
  {{declarations.print_variable_type(vector_var)}} _tmp_{{names.name(vector_var)}} = {{names.getter(vector_var)}}();
  _tmp_{{names.name(vector_var)}}.resize(tmp_{{names.name(variable)}}, 0.);
  set_{{names.name(vector_var)}}(_tmp_{{names.name(vector_var)}});
{%- endif %}
{%- endfor %}
}
{%- endif %}

{%- else %}
{{declarations.print_variable_type(variable)}} tmp_{{names.convert_to_cpp_name(variable.get_symbol_name())}} = {{names.getter(variable)}}();
{%- if synapse is defined or variable in vector_symbols %}
updateValue<{{declarations.print_variable_type(variable)}}>(__d, nest::{{names_namespace}}::_{{variable.get_symbol_name()}}, tmp_{{names.convert_to_cpp_name(variable.get_symbol_name())}});
{%- else %}
nest::updateValueParam<{{declarations.print_variable_type(variable)}}>(__d, nest::{{names_namespace}}::_{{variable.get_symbol_name()}}, tmp_{{names.convert_to_cpp_name(variable.get_symbol_name())}}, this);
{%- endif %}
{%- endif %}

{%- if variable.has_vector_parameter() %}
 {#
Typecast the vector parameter to an int. If the typecast fails with a return value of 0, the vector parameter is a
variable
 #}
{%- if variable.get_vector_parameter().is_numeric_literal() -%}
{%- set vector_size = vector_size_parameter.VectorSizeParameter(variable, true) %}
{%- elif variable.get_vector_parameter().is_variable() -%}
{%- set vector_size = "tmp_" + vector_size_parameter.VectorSizeParameter(variable, false) %}
{%- else %}
{{ raise("Vector size expression needs to be numeric literal or variable") }}
{%- endif %}
// Check if the new vector size matches its original size
if ( tmp_{{names.name(variable)}}.size() != {{vector_size}} )
{
  std::stringstream msg;
  msg << "The vector \"{{names.name(variable)}}\" does not match its size: " << {{vector_size}};
  throw nest::BadProperty(msg.str());
}
{%- endif %}
{%- else %}
  // ignores '{{names.name(variable)}}' {{declarations.print_variable_type(variable)}}' since it is an function and setter isn't defined
{%- endif %}
