{#-
NeuronClass.jinja2

This file is part of NEST.

Copyright (C) 2004 The NEST Initiative

NEST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

NEST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with NEST.  If not, see <http://www.gnu.org/licenses/>.
#}
{%- if tracing %}/* generated by {{self._TemplateReference__context.name}} */{% endif -%}
/*
 *  {{neuronName}}.cpp
 *
 *  This file is part of NEST.
 *
 *  Copyright (C) 2004 The NEST Initiative
 *
 *  NEST is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  NEST is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  Generated from NESTML at time: {{now}}
**/

// C++ includes:
#include <limits>

// Includes from libnestutil:
#include "numerics.h"

// Includes from nestkernel:
#include "exceptions.h"
#include "kernel_manager.h"
#include "universal_data_logger_impl.h"

// Includes from sli:
#include "dict.h"
#include "dictutils.h"
#include "doubledatum.h"
#include "integerdatum.h"
#include "lockptrdatum.h"

#include "{{neuronName}}.h"

{%- set stateSize = neuron.get_non_inline_state_symbols()|length %}

// ---------------------------------------------------------------------------
//   Recordables map
// ---------------------------------------------------------------------------
{%- if not has_vectors %}
nest::RecordablesMap<{{neuronName}}> {{neuronName}}::recordablesMap_;
{%- endif %}
namespace nest
{
  // Override the create() method with one call to RecordablesMap::insert_()
  // for each quantity to be recorded.
{%- if has_vectors %}
template <> void DynamicRecordablesMap<{{neuronName}}>::create({{neuronName}}& host)
{%- else %}
template <> void RecordablesMap<{{neuronName}}>::create()
{%- endif %}
  {

{%- if recordable_state_variables|length > 0 %}
{%- if has_vectors %}
{%-   for sym in recordable_state_variables %}
{%-     if not sym.has_vector_parameter() %}
    insert("{{sym.get_symbol_name()}}", host.get_data_access_functor( {{neuronName}}::State_::{{names.name(sym).upper()}} ));
{%-     endif %}
{%-   endfor %}
{%- else %}
    // add state variables to recordables map
{%-   for sym in recordable_state_variables %}
   insert_("{{sym.get_symbol_name()}}", &{{neuronName}}::{{names.getter(sym)}});
{%-   endfor %}
{%- endif %}
{%- endif %}

{%- if recordable_inline_expressions|length > 0 %}
    // add recordable inline expressions to recordables map
{%- for sym in recordable_inline_expressions %}
	insert_("{{sym.get_symbol_name()}}", &{{neuronName}}::{{names.getter(sym)}});
{%- endfor %}
{%- endif %}

    // Add vector variables
{%- filter indent(2,True) %}
{%- if has_vectors %}
    host.insert_recordables();
{%- endif %}
{%- endfilter %}
  }
}

{%- if has_vectors %}
  std::string {{neuronName}}::get_var_name(size_t elem, std::string var_name)
  {
    std::stringstream n;
    n << var_name << elem + 1;
    return n.str();
  }

  void {{neuronName}}::insert_recordables(size_t first)
  {
{%- for variable in neuron.get_vector_state_symbols() %}
{%- set size = variable.get_vector_parameter() %}
{%-   if size|int == 0 -%}
{%-   set size = utils.get_numeric_vector_size(variable) %}
{%-   endif %}
      for (size_t i = 0; i < {{size}}; i++)
      {
        size_t elem = {{neuronName}}::State_::{{names.name(variable).upper()}} + i;
        recordablesMap_.insert(get_var_name(i, "{{names.name(variable).upper()}}_"), this->get_data_access_functor(elem));
      }
{%- endfor %}
  }

  nest::DataAccessFunctor< {{neuronName}} >
  {{neuronName}}::get_data_access_functor( size_t elem )
  {
    return nest::DataAccessFunctor< {{neuronName}} >( *this, elem );
  }
{%- endif %}

// ---------------------------------------------------------------------------
//   Default constructors defining default parameters and state
//   Note: the implementation is empty. The initialization is of variables
//   is a part of {{neuronName}}'s constructor.
// ---------------------------------------------------------------------------

{{neuronName}}::Parameters_::Parameters_()
{
}

{{neuronName}}::State_::State_()
{
}

// ---------------------------------------------------------------------------
//   Parameter and state extractions and manipulation functions
// ---------------------------------------------------------------------------

{{neuronName}}::Buffers_::Buffers_({{neuronName}} &n):
  logger_(n)
{%- if neuron.get_multiple_receptors()|length > 1 %}
  , spike_inputs_( std::vector< nest::RingBuffer >( SUP_SPIKE_RECEPTOR - 1 ) )
{%- endif %}
{%- if useGSL %}
  , __s( 0 ), __c( 0 ), __e( 0 )
{%- endif %}
{
  // Initialization of the remaining members is deferred to init_buffers_().
}

{{neuronName}}::Buffers_::Buffers_(const Buffers_ &, {{neuronName}} &n):
  logger_(n)
{%- if neuron.get_multiple_receptors()|length > 1 %}
  , spike_inputs_( std::vector< nest::RingBuffer >( SUP_SPIKE_RECEPTOR - 1 ) )
{%- endif %}
{%- if useGSL %}
  , __s( 0 ), __c( 0 ), __e( 0 )
{%- endif %}
{
  // Initialization of the remaining members is deferred to init_buffers_().
}

// ---------------------------------------------------------------------------
//   Default constructor for node
// ---------------------------------------------------------------------------

{{neuronName}}::{{neuronName}}():{{neuron_parent_class}}(), P_(), S_(), B_(*this)
{
{%- if has_vectors %}
  recordablesMap_.create(*this);
{%- else %}
  recordablesMap_.create();
{%- endif %}

  calibrate();
{%- if useGSL %}

  // use a default "good enough" value for the absolute error. It can be adjusted via `node.set()`
  P_.__gsl_error_tol = 1e-3;
{%- endif %}

{%- if parameter_syms_with_iv|length > 0 %}
  // initial values for parameters
{%- filter indent(2) %}
{%- for parameter in parameter_syms_with_iv %}
{%-   with variable = parameter %}
{%-     include "directives/MemberInitialization.jinja2" %}
{%-   endwith %}
{%- endfor %}
{%- endfilter %}
{%- endif %}

{%- if neuron.get_state_symbols()|length > 0 %}
  // initial values for state variables
{%- filter indent(2) %}
{%- for init in neuron.get_state_symbols() %}
{%-   with variable = init %}
{%-     include "directives/MemberInitialization.jinja2" %}
{%-   endwith %}
{%- endfor %}
{%- endfilter %}
{%- endif %}
}

// ---------------------------------------------------------------------------
//   Copy constructor for node
// ---------------------------------------------------------------------------

{{neuronName}}::{{neuronName}}(const {{neuronName}}& __n):
  {{neuron_parent_class}}(), P_(__n.P_), S_(__n.S_), B_(__n.B_, *this) {

{%- if has_vectors %}
  recordablesMap_.create(*this);
{%- endif %}

  // copy parameter struct P_
{%- for parameter in neuron.get_parameter_symbols() %}
  P_.{{names.name(parameter)}} = __n.P_.{{names.name(parameter)}};
{%- endfor %}

  // copy state struct S_
{%- for state in neuron.get_state_symbols() %}
{%-   if not is_delta_kernel(neuron.get_kernel_by_name(state.name)) %}
  S_.{{names.name(state)}} = __n.S_.{{names.name(state)}};
{%-   endif %}
{%- endfor %}


  // copy internals V_
{%- for internal in neuron.get_internal_symbols() %}
  V_.{{names.name(internal)}} = __n.V_.{{names.name(internal)}};
{%- endfor %}
}

// ---------------------------------------------------------------------------
//   Destructor for node
// ---------------------------------------------------------------------------

{{neuronName}}::~{{neuronName}}()
{
{%- if useGSL %}
  // GSL structs may not have been allocated, so we need to protect destruction

  if (B_.__s)
  {
    gsl_odeiv_step_free( B_.__s );
  }

  if (B_.__c)
  {
    gsl_odeiv_control_free( B_.__c );
  }

  if (B_.__e)
  {
    gsl_odeiv_evolve_free( B_.__e );
  }
{%- endif %}
}

// ---------------------------------------------------------------------------
//   Node initialization functions
// ---------------------------------------------------------------------------

void {{neuronName}}::init_state_(const Node& proto)
{
  const {{neuronName}}& pr = downcast<{{neuronName}}>(proto);
  S_ = pr.S_;
}

void {{neuronName}}::init_buffers_()
{
{%- for buffer in neuron.get_input_buffers() %}
  {{ printer.print_buffer_initialization(buffer) }}
{%- endfor %}
  B_.logger_.reset(); // includes resize
  {{neuron_parent_class}}::clear_history();
{%- if useGSL %}

  if ( B_.__s == 0 )
  {
    B_.__s = gsl_odeiv_step_alloc( gsl_odeiv_step_rkf45, {{stateSize}} );
  }
  else
  {
    gsl_odeiv_step_reset( B_.__s );
  }

  if ( B_.__c == 0 )
  {
    B_.__c = gsl_odeiv_control_y_new( P_.__gsl_error_tol, 0.0 );
  }
  else
  {
    gsl_odeiv_control_init( B_.__c, P_.__gsl_error_tol, 0.0, 1.0, 0.0 );
  }

  if ( B_.__e == 0 )
  {
    B_.__e = gsl_odeiv_evolve_alloc( {{stateSize}} );
  }
  else
  {
    gsl_odeiv_evolve_reset( B_.__e );
  }

  B_.__sys.function = {{neuronName}}_dynamics;
  B_.__sys.jacobian = NULL;
  B_.__sys.dimension = {{stateSize}};
  B_.__sys.params = reinterpret_cast< void* >( this );
  B_.__step = nest::Time::get_resolution().get_ms();
  B_.__integration_step = nest::Time::get_resolution().get_ms();
{%- endif %}
}

void {{neuronName}}::calibrate()
{
  B_.logger_.init();

  // internals V_
{%- filter indent(2) %}
{%- for variable in neuron.get_internal_symbols() %}
{%-   include "directives/Calibrate.jinja2" %}
{%- endfor %}
{%- endfilter %}

{%- filter indent(2) %}
  // buffers B_
{%- for buffer in neuron.get_input_buffers() %}
{%-   if buffer.has_vector_parameter() %}
  B_.{{buffer.get_symbol_name()}}.resize(P_.{{buffer.get_vector_parameter()}});
  B_.{{buffer.get_symbol_name()}}_grid_sum_.resize(P_.{{buffer.get_vector_parameter()}});
{%-   endif %}
{%- endfor %}
{%- endfilter %}
}

// ---------------------------------------------------------------------------
//   Functions defined in the NESTML model
// ---------------------------------------------------------------------------

{%- if neuron.get_functions()|length > 0 %}
{%- for function in neuron.get_functions() %}
{{printer.print_function_definition(function, neuronName)}}
{
{%-   filter indent(2,True) %}
{%-   with ast = function.get_block() %}
{%-     include "directives/Block.jinja2" %}
{%-   endwith %}
{%-   endfilter %}
}
{%- endfor %}
{%- endif %}

// ---------------------------------------------------------------------------
//   Update and spike handling functions
// ---------------------------------------------------------------------------

{% if useGSL %}
{%- include "directives/GSLDifferentiationFunction.jinja2" %}
{% endif %}

{%- if neuron.print_dynamics_comment('*')|length > 1 %}
/*
 {{neuron.print_dynamics_comment('*')}}
 */
{%- endif %}
void {{neuronName}}::update(nest::Time const & origin,const long from, const long to)
{
{%- if useGSL %}
  double __t = 0;
{%- endif %}

  for ( long lag = from ; lag < to ; ++lag )
  {
{%- for inputPort in neuron.get_input_buffers() %}
{%-   if inputPort.has_vector_parameter() %}
    for (long i=0; i < P_.{{inputPort.get_vector_parameter()}}; ++i)
    {
      B_.{{names.buffer_value(inputPort)}}[i] = get_{{names.name(inputPort)}}()[i].get_value(lag);
    }
{%-   else %}
    B_.{{names.buffer_value(inputPort)}} = get_{{names.name(inputPort)}}().get_value(lag);
{%-   endif %}
{%- endfor %}

    // NESTML generated code for the update block:

{%- if neuron.get_update_blocks() %}
{%- filter indent(2) %}
{%- set dynamics = neuron.get_update_blocks() %}
{%- with ast = dynamics.get_block() %}
{%-   include "directives/Block.jinja2" %}
{%- endwith %}
{%- endfilter %}
{%- endif %}

    // voltage logging
    B_.logger_.record_data(origin.get_steps() + lag);
  }

}

// Do not move this function as inline to h-file. It depends on
// universal_data_logger_impl.h being included here.
void {{neuronName}}::handle(nest::DataLoggingRequest& e)
{
  B_.logger_.handle(e);
}
{% if is_spike_input %}
void {{neuronName}}::handle(nest::SpikeEvent &e)
{
  assert(e.get_delay_steps() > 0);
{%- if neuron.is_multisynapse_spikes() %}
{%-   set spikeBuffer = neuron.get_spike_buffers()[0] %}
  B_.{{spikeBuffer.get_symbol_name()}}[e.get_rport() - 1].add_value(
    e.get_rel_delivery_steps( nest::kernel().simulation_manager.get_slice_origin() ),
    e.get_weight() * e.get_multiplicity() );
{%- elif neuron.get_multiple_receptors()|length > 1 %}
  assert( e.get_rport() < static_cast< int >( B_.spike_inputs_.size() ) );

  B_.spike_inputs_[ e.get_rport() ].add_value(
    e.get_rel_delivery_steps( nest::kernel().simulation_manager.get_slice_origin() ),
    e.get_weight() * e.get_multiplicity() );
{%- else %}
  const double weight = e.get_weight();
  const double multiplicity = e.get_multiplicity();
{%-   for buffer in neuron.get_spike_buffers() %}
{%-     if buffer.is_excitatory() %}
  if ( weight >= 0.0 )
  {
    // excitatory
    get_{{buffer.get_symbol_name()}}().
        add_value(e.get_rel_delivery_steps( nest::kernel().simulation_manager.get_slice_origin()),
                       weight * multiplicity );
  }
{%-     endif %}
{%-     if buffer.is_inhibitory() %}
  if ( weight < 0.0 )
  {
    // inhibitory
    get_{{buffer.get_symbol_name()}}().
        add_value(e.get_rel_delivery_steps( nest::kernel().simulation_manager.get_slice_origin()),
                      {% if buffer.is_conductance_based() %} // ensure conductance is positive {% endif %}
                      {% if buffer.is_conductance_based() %} -1 * {% endif %} weight * multiplicity );
  }
{%-     endif %}
{%-   endfor %}
{%- endif %}
}
{%- endif %}

{%- if is_current_input %}

void {{neuronName}}::handle(nest::CurrentEvent& e)
{
  assert(e.get_delay_steps() > 0);

  const double current = e.get_current();     // we assume that in NEST, this returns a current in pA
  const double weight = e.get_weight();

{%- for buffer in neuron.get_current_buffers() %}
  get_{{buffer.get_symbol_name()}}().add_value(
               e.get_rel_delivery_steps( nest::kernel().simulation_manager.get_slice_origin()),
               weight * current );
{%- endfor %}
}
{%- endif %}
{# leave this comment here to ensure newline is generated at end of file -#}
