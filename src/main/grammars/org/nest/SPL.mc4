/*
 * Copyright (c) 2015 RWTH Aachen. All rights reserved.
 *
 * http://www.se-rwth.de/
 */
package org.nest;

grammar SPL extends org.nest.commons.Commons {

  SPLFile = ModuleDefinitionStatement Block;

  ModuleDefinitionStatement = "module" moduleName:QualifiedName;

  Block = ( Stmt | NEWLINE )*;

  Stmt = Simple_Stmt | Compound_Stmt;

  Compound_Stmt = IF_Stmt
                | FOR_Stmt
                | WHILE_Stmt;

  Simple_Stmt = Small_Stmt (";" Small_Stmt)* (";")? NEWLINE?;

  Small_Stmt = Assignment
             | FunctionCall
             | Declaration
             | ReturnStmt
             | OdeDeclaration;

   OdeDeclaration  =
     "ODE" BLOCK_OPEN (NEWLINE)*
       Eq (NEWLINE)*
       ODE (NEWLINE)*
       BLOCK_CLOSE;

  Eq = lhsVariable:Name "===" rhs:Expr;
  ODE = "d/dt" lhsVariable:Name "===" rhs:Expr;

  Assignment = variableName:QualifiedName
    (assignment:["="] |
     compoundSum:["+="] |
     compoundMinus:["-="] |
     compoundProduct:["*="] |
     compoundQuotient:["/="]) Expr;

  // inherited PrimitiveType must be used here because otherwise the parser cannot distinguish
  // between fqn: boolean and "keyword" boolean
  Declaration =
    vars:Name ("," vars:Name)*
    (type:QualifiedName | primitiveType:PrimitiveType)
    ("<" sizeParameter:Name ">")?
    ( "=" Expr )? ;

  ReturnStmt = "return" Expr?;

  IF_Stmt = IF_Clause
            ELIF_Clause*
            (ELSE_Clause)?
            BLOCK_CLOSE;
  IF_Clause = "if" Expr BLOCK_OPEN Block;

  ELIF_Clause = "elif" Expr BLOCK_OPEN Block;

  ELSE_Clause = "else" BLOCK_OPEN Block;

  FOR_Stmt = "for" var:Name "in" from:Expr "..." to:Expr ("step" step:SignedNumericLiteral)? BLOCK_OPEN Block BLOCK_CLOSE;

  WHILE_Stmt = "while" Expr BLOCK_OPEN Block BLOCK_CLOSE;

  Expr =   (unaryPlus:["+"] | unaryMinus:["-"] | unaryTilde:["~"]) term:Expr
         | "not" Expr // TODO not explicit?
         | base:Expr pow:["**"] exponent:Expr // TODO make right assoc keyword asap
         | left:Expr (timesOp:["*"] | divOp:["/"] | moduloOp:["%"]) right:Expr
         | left:Expr (plusOp:["+"] | minusOp:["-"]) right:Expr
         | left:Expr (shiftLeft:["<<"] | shiftRight:[">>"]) right:Expr
         | left:Expr bitAnd:["&"] right:Expr
         | left:Expr bitOr:["|"] right:Expr
         | left:Expr bitXor:["^"]  right:Expr
         | left:Expr (lt:["<"] |
                      le:["<="] |
                      eq:["=="] |
                      ne:["!="] |
                      ne2:["<>"] |
                      ge:[">="] |
                      gt:[">"]) right:Expr
         | left:Expr logicalAnd:["and"] right:Expr
         | left:Expr logicalOr:["or"] right:Expr
         | FunctionCall
         | BooleanLiteral // true & false;
         | NumericLiteral type:QualifiedName?
         | StringLiteral
         | ["inf"]
         | QualifiedName
         | leftParentheses:"(" Expr rightParentheses:")";

  FunctionCall = QualifiedName "(" ArgList ")";

  ArgList = (args:Expr ("," args:Expr)*)?;
}
