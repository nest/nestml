/* generated by template org.nest.nestml.neuron.NeuronClass*/
/*
*  iaf_psc_alpha_neuron.cpp
*
*  This file is part of NEST.
*
*  Copyright (C) 2004 The NEST Initiative
*
*  NEST is free software: you can redistribute it and/or modify
*  it under the terms of the GNU General Public License as published by
*  the Free Software Foundation, either version 2 of the License, or
*  (at your option) any later version.
*
*  NEST is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU General Public License for more details.
*
*  You should have received a copy of the GNU General Public License
*  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
*
*/

// C++ includes:
#include <limits>

// Includes from libnestutil:
#include "numerics.h"

// Includes from nestkernel:
#include "exceptions.h"
#include "kernel_manager.h"
#include "universal_data_logger_impl.h"

// Includes from sli:
#include "dict.h"
#include "dictutils.h"
#include "doubledatum.h"
#include "integerdatum.h"
#include "lockptrdatum.h"

#include "iaf_psc_alpha_neuron.h"

/* ----------------------------------------------------------------
* Recordables map
* ---------------------------------------------------------------- */
nest::RecordablesMap<iaf_psc_alpha_neuron>
    iaf_psc_alpha_neuron::recordablesMap_;

namespace nest {
// Override the create() method with one call to RecordablesMap::insert_()
// for each quantity to be recorded.
template <> void RecordablesMap<iaf_psc_alpha_neuron>::create() {
  // use standard names whereever you can for consistency!
  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("V_abs", &iaf_psc_alpha_neuron::get_V_abs);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("V_m", &iaf_psc_alpha_neuron::get_V_m);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("y1_I_shape_in", &iaf_psc_alpha_neuron::get_y1_I_shape_in);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("y2_I_shape_in", &iaf_psc_alpha_neuron::get_y2_I_shape_in);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("y1_I_shape_ex", &iaf_psc_alpha_neuron::get_y1_I_shape_ex);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("y2_I_shape_ex", &iaf_psc_alpha_neuron::get_y2_I_shape_ex);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the RefractoryCounts with the domain type long

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the r with the domain type long

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the __h__ with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P30 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the y1_I_shape_inPSCInitialValue with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the y1_I_shape_exPSCInitialValue with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_in_00 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_in_01 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_in_02 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_in_10 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_in_11 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_in_12 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_in_20 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_in_21 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_in_22 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_ex_00 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_ex_01 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_ex_02 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_ex_10 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_ex_11 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_ex_12 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_ex_20 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_ex_21 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_ex_22 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the __P01 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the __P11 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the __P21 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the __P31 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the C_m with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the Tau with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the tau_syn_in with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the tau_syn_ex with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the t_ref with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the E_L with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the V_reset with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the Theta with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the I_e with the domain type double
}
}

/* ----------------------------------------------------------------
* Default constructors defining default parameters and state
* ---------------------------------------------------------------- */
iaf_psc_alpha_neuron::Parameters_::Parameters_() {
  C_m = 0;
  Tau = 0;
  tau_syn_in = 0;
  tau_syn_ex = 0;
  t_ref = 0;
  E_L = 0;
  I_e = 0;
}

iaf_psc_alpha_neuron::State_::State_() {
  V_abs = 0;
  y1_I_shape_in = 0;
  y2_I_shape_in = 0;
  y1_I_shape_ex = 0;
  y2_I_shape_ex = 0;
}

/* ----------------------------------------------------------------
* Parameter and state extractions and manipulation functions
* ---------------------------------------------------------------- */

iaf_psc_alpha_neuron::Buffers_::Buffers_(iaf_psc_alpha_neuron &n)
    : logger_(n) {}

iaf_psc_alpha_neuron::Buffers_::Buffers_(const Buffers_ &,
                                         iaf_psc_alpha_neuron &n)
    : logger_(n)

{}

/* ----------------------------------------------------------------
* Default and copy constructor for node
* ---------------------------------------------------------------- */
// TODO inner components
iaf_psc_alpha_neuron::iaf_psc_alpha_neuron()
    : Archiving_Node(), P_(), S_(), B_(*this) {
  recordablesMap_.create();

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.C_m = 250;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.Tau = 10;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.tau_syn_in = 2;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.tau_syn_ex = 2;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.t_ref = 2;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.E_L = ((-70));

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.I_e = 0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.V_abs = 0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y1_I_shape_in = 0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y2_I_shape_in = 0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y1_I_shape_ex = 0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y2_I_shape_ex = 0;
}

iaf_psc_alpha_neuron::iaf_psc_alpha_neuron(const iaf_psc_alpha_neuron &n)
    : Archiving_Node(), P_(n.P_), S_(n.S_), B_(n.B_, *this) {}

/* ----------------------------------------------------------------
* Destructors
* ---------------------------------------------------------------- */

iaf_psc_alpha_neuron::~iaf_psc_alpha_neuron() {}

/* ----------------------------------------------------------------
* Node initialization functions
* ---------------------------------------------------------------- */

void iaf_psc_alpha_neuron::init_state_(
    const Node &proto) { // TODO inner components

  const iaf_psc_alpha_neuron &pr = downcast<iaf_psc_alpha_neuron>(proto);
  S_ = pr.S_;
}

void iaf_psc_alpha_neuron::init_buffers_() {
  get_ex_spikes().clear(); // includes resize
  get_in_spikes().clear(); // includes resize
  get_currents().clear();  // includes resize
  B_.logger_.reset();      // includes resize
  Archiving_Node::clear_history();
}

void iaf_psc_alpha_neuron::calibrate() {
  B_.logger_.init();

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.RefractoryCounts =
      nest::Time(nest::Time::ms((double)P_.t_ref)).get_steps();

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.r = 0;

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.__h__ = nest::Time::get_resolution().get_ms();

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P30 = P_.Tau / P_.C_m - P_.Tau * std::exp(((-V_.__h__)) / P_.Tau) / P_.C_m;

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.y1_I_shape_inPSCInitialValue = numerics::e / P_.tau_syn_in;

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.y1_I_shape_exPSCInitialValue = numerics::e / P_.tau_syn_ex;

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_in_00 = std::exp(((-V_.__h__)) / P_.tau_syn_in);

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_in_01 = 0;

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_in_02 = 0;

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_in_10 = V_.__h__ * std::exp(((-V_.__h__)) / P_.tau_syn_in);

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_in_11 = std::exp(((-V_.__h__)) / P_.tau_syn_in);

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_in_12 = 0;

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_in_20 =
      ((-P_.Tau)) * P_.tau_syn_in *
      (P_.Tau * V_.__h__ * std::exp(V_.__h__ / P_.Tau) +
       P_.Tau * P_.tau_syn_in * std::exp(V_.__h__ / P_.Tau) -
       P_.Tau * P_.tau_syn_in * std::exp(V_.__h__ / P_.tau_syn_in) -
       V_.__h__ * P_.tau_syn_in * std::exp(V_.__h__ / P_.Tau)) *
      std::exp(((-V_.__h__)) / P_.tau_syn_in - V_.__h__ / P_.Tau) /
      (P_.C_m * (pow((P_.Tau), (2)) - 2 * P_.Tau * P_.tau_syn_in +
                 pow((P_.tau_syn_in), (2))));

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_in_21 =
      ((-P_.Tau)) * P_.tau_syn_in *
      (std::exp(V_.__h__ / P_.Tau) - std::exp(V_.__h__ / P_.tau_syn_in)) *
      std::exp(((-V_.__h__)) / P_.tau_syn_in - V_.__h__ / P_.Tau) /
      (P_.C_m * (P_.Tau - P_.tau_syn_in));

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_in_22 = std::exp(((-V_.__h__)) / P_.Tau);

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_ex_00 = std::exp(((-V_.__h__)) / P_.tau_syn_ex);

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_ex_01 = 0;

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_ex_02 = 0;

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_ex_10 = V_.__h__ * std::exp(((-V_.__h__)) / P_.tau_syn_ex);

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_ex_11 = std::exp(((-V_.__h__)) / P_.tau_syn_ex);

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_ex_12 = 0;

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_ex_20 =
      ((-P_.Tau)) * P_.tau_syn_ex *
      (P_.Tau * V_.__h__ * std::exp(V_.__h__ / P_.Tau) +
       P_.Tau * P_.tau_syn_ex * std::exp(V_.__h__ / P_.Tau) -
       P_.Tau * P_.tau_syn_ex * std::exp(V_.__h__ / P_.tau_syn_ex) -
       V_.__h__ * P_.tau_syn_ex * std::exp(V_.__h__ / P_.Tau)) *
      std::exp(((-V_.__h__)) / P_.tau_syn_ex - V_.__h__ / P_.Tau) /
      (P_.C_m * (pow((P_.Tau), (2)) - 2 * P_.Tau * P_.tau_syn_ex +
                 pow((P_.tau_syn_ex), (2))));

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_ex_21 =
      ((-P_.Tau)) * P_.tau_syn_ex *
      (std::exp(V_.__h__ / P_.Tau) - std::exp(V_.__h__ / P_.tau_syn_ex)) *
      std::exp(((-V_.__h__)) / P_.tau_syn_ex - V_.__h__ / P_.Tau) /
      (P_.C_m * (P_.Tau - P_.tau_syn_ex));

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_ex_22 = std::exp(((-V_.__h__)) / P_.Tau);

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.__P01 = std::exp((((-V_.__h__))) / P_.tau_syn_in);

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.__P11 = std::exp((((-V_.__h__))) / P_.tau_syn_in);

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.__P21 = std::exp((((-V_.__h__))) / P_.tau_syn_ex);

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.__P31 = std::exp((((-V_.__h__))) / P_.tau_syn_ex);
}

/* ----------------------------------------------------------------
* Update and spike handling functions
* ---------------------------------------------------------------- */

/*

 */
void iaf_psc_alpha_neuron::update(nest::Time const &origin, const long from,
                                  const long to) {

  for (long lag = from; lag < to; ++lag) {
    // TODO this case must be handled uniformly, also NESTReferenceConverter
    // must be adopted
    B_.ex_spikes_last_value_ = get_ex_spikes().get_value(lag);
    // TODO this case must be handled uniformly, also NESTReferenceConverter
    // must be adopted
    B_.in_spikes_last_value_ = get_in_spikes().get_value(lag);
    // TODO this case must be handled uniformly, also NESTReferenceConverter
    // must be adopted
    B_.currents_last_value_ = get_currents().get_value(lag);

    /* generated by template org.nest.spl.Block*/
    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.CompoundStatement*/
    /* generated by template org.nest.spl.compound_statement.IfStatement*/

    if (V_.r == 0) {
      /* generated by template org.nest.spl.Block*/
      /* generated by template org.nest.spl.Statement*/
      //
      /* generated by template org.nest.spl.SmallStatement*/
      /* generated by template org.nest.spl.small_statement.Assignment*/
      S_.V_abs = V_.P30 * (P_.I_e + B_.currents_last_value_) +
                 S_.V_abs * std::exp(((-V_.__h__)) / P_.Tau);

      /* generated by template org.nest.spl.Statement*/
      //
      /* generated by template org.nest.spl.SmallStatement*/
      /* generated by template org.nest.spl.small_statement.Assignment*/
      S_.V_abs += V_.P_I_shape_in_20 * S_.y1_I_shape_in +
                  V_.P_I_shape_in_21 * S_.y2_I_shape_in;

      /* generated by template org.nest.spl.Statement*/
      //
      /* generated by template org.nest.spl.SmallStatement*/
      /* generated by template org.nest.spl.small_statement.Assignment*/
      S_.V_abs += V_.P_I_shape_ex_20 * S_.y1_I_shape_ex +
                  V_.P_I_shape_ex_21 * S_.y2_I_shape_ex;

    } else {
      /* generated by template org.nest.spl.Block*/
      /* generated by template org.nest.spl.Statement*/
      //
      /* generated by template org.nest.spl.SmallStatement*/
      /* generated by template org.nest.spl.small_statement.Assignment*/
      V_.r = V_.r - 1;

    } /* if end */

    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.CompoundStatement*/
    /* generated by template org.nest.spl.compound_statement.IfStatement*/

    if (S_.V_abs >= get_Theta()) {
      /* generated by template org.nest.spl.Block*/
      /* generated by template org.nest.spl.Statement*/
      // # A supra-threshold membrane potential should never be observable.# The
      // reset at the time of threshold crossing enables accurate# integration
      // independent of the computation step size, see [2,3] for# details.
      /* generated by template org.nest.spl.SmallStatement*/
      /* generated by template org.nest.spl.small_statement.Assignment*/
      V_.r = V_.RefractoryCounts;

      /* generated by template org.nest.spl.Statement*/
      //
      /* generated by template org.nest.spl.SmallStatement*/
      /* generated by template org.nest.spl.small_statement.Assignment*/
      S_.V_abs = get_V_reset();

      /* generated by template org.nest.spl.Statement*/
      //
      /* generated by template org.nest.spl.SmallStatement*/
      /* generated by template org.nest.spl.small_statement.FunctionCall*/
      set_spiketime(nest::Time::step(origin.get_steps() + lag + 1));
      nest::SpikeEvent se;
      nest::kernel().event_delivery_manager.send(*this, se, lag);
      ;

    } /* if end */

    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.SmallStatement*/
    /* generated by template org.nest.spl.small_statement.Assignment*/
    S_.y2_I_shape_in =
        (V_.__h__ * S_.y1_I_shape_in + S_.y2_I_shape_in) * V_.__P01;

    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.SmallStatement*/
    /* generated by template org.nest.spl.small_statement.Assignment*/
    S_.y1_I_shape_in = S_.y1_I_shape_in * V_.__P11;

    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.SmallStatement*/
    /* generated by template org.nest.spl.small_statement.Assignment*/
    S_.y2_I_shape_ex =
        (V_.__h__ * S_.y1_I_shape_ex + S_.y2_I_shape_ex) * V_.__P21;

    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.SmallStatement*/
    /* generated by template org.nest.spl.small_statement.Assignment*/
    S_.y1_I_shape_ex = S_.y1_I_shape_ex * V_.__P31;

    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.SmallStatement*/
    /* generated by template org.nest.spl.small_statement.Assignment*/
    S_.y1_I_shape_in +=
        V_.y1_I_shape_inPSCInitialValue * B_.in_spikes_last_value_;

    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.SmallStatement*/
    /* generated by template org.nest.spl.small_statement.Assignment*/
    S_.y1_I_shape_ex +=
        V_.y1_I_shape_exPSCInitialValue * B_.ex_spikes_last_value_;

    // voltage logging
    B_.logger_.record_data(origin.get_steps() + lag);
  }
}

// Do not move this function as inline to h-file. It depends on
// universal_data_logger_impl.h being included here.
void iaf_psc_alpha_neuron::handle(nest::DataLoggingRequest &e) {
  B_.logger_.handle(e);
}

void iaf_psc_alpha_neuron::handle(nest::SpikeEvent &e) {
  assert(e.get_delay() > 0);

  const double weight = e.get_weight();
  const double multiplicity = e.get_multiplicity();
  if (weight >= 0.0) // excitatory
  {
    get_ex_spikes().add_value(
        e.get_rel_delivery_steps(
            nest::kernel().simulation_manager.get_slice_origin()),
        weight * multiplicity);
  }
  if (weight < 0.0) // inhibitory
  {
    get_in_spikes().add_value(
        e.get_rel_delivery_steps(
            nest::kernel().simulation_manager.get_slice_origin()),

        weight * multiplicity);
  }
}

void iaf_psc_alpha_neuron::handle(nest::CurrentEvent &e) {
  assert(e.get_delay() > 0);

  const double current = e.get_current();
  const double weight = e.get_weight();

  // add weighted current; HEP 2002-10-04
  get_currents().add_value(
      e.get_rel_delivery_steps(
          nest::kernel().simulation_manager.get_slice_origin()),
      weight * current);
}
