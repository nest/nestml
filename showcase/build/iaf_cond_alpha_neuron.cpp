/* generated by template org.nest.nestml.neuron.NeuronClass*/
/*
*  iaf_cond_alpha_neuron.cpp
*
*  This file is part of NEST.
*
*  Copyright (C) 2004 The NEST Initiative
*
*  NEST is free software: you can redistribute it and/or modify
*  it under the terms of the GNU General Public License as published by
*  the Free Software Foundation, either version 2 of the License, or
*  (at your option) any later version.
*
*  NEST is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU General Public License for more details.
*
*  You should have received a copy of the GNU General Public License
*  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
*
*/

// C++ includes:
#include <limits>

// Includes from libnestutil:
#include "numerics.h"

// Includes from nestkernel:
#include "exceptions.h"
#include "kernel_manager.h"
#include "universal_data_logger_impl.h"

// Includes from sli:
#include "dict.h"
#include "dictutils.h"
#include "doubledatum.h"
#include "integerdatum.h"
#include "lockptrdatum.h"

#include "iaf_cond_alpha_neuron.h"

/* ----------------------------------------------------------------
* Recordables map
* ---------------------------------------------------------------- */
nest::RecordablesMap<iaf_cond_alpha_neuron>
    iaf_cond_alpha_neuron::recordablesMap_;

namespace nest {
// Override the create() method with one call to RecordablesMap::insert_()
// for each quantity to be recorded.
template <> void RecordablesMap<iaf_cond_alpha_neuron>::create() {
  // use standard names whereever you can for consistency!
  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("V_m", &iaf_cond_alpha_neuron::get_V_m);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("g_in", &iaf_cond_alpha_neuron::get_g_in);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("g_ex", &iaf_cond_alpha_neuron::get_g_ex);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("g_in'", &iaf_cond_alpha_neuron::get___D_g_in);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("g_ex'", &iaf_cond_alpha_neuron::get___D_g_ex);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the RefractoryCounts with the domain type long

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the r with the domain type long

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the g_in__D_PSCInitialValue with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the g_ex__D_PSCInitialValue with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the V_th with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the V_reset with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the t_ref with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the g_L with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the C_m with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the E_ex with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the E_in with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the E_L with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the tau_syn_ex with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the tau_syn_in with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the I_e with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the I_stim with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the I_syn_exc with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the I_syn_inh with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the I_leak with the domain type double
}
}

/* ----------------------------------------------------------------
* Default constructors defining default parameters and state
* ---------------------------------------------------------------- */
iaf_cond_alpha_neuron::Parameters_::Parameters_() {
  V_th = 0;
  V_reset = 0;
  t_ref = 0;
  g_L = 0;
  C_m = 0;
  E_ex = 0;
  E_in = 0;
  E_L = 0;
  tau_syn_ex = 0;
  tau_syn_in = 0;
  I_e = 0;
  I_stim = 0;
}

iaf_cond_alpha_neuron::State_::State_() {
  y[State_::V_m] = 0;
  y[State_::g_in] = 0;
  y[State_::g_ex] = 0;
  y[State_::__D_g_in] = 0;
  y[State_::__D_g_ex] = 0;
}

/* ----------------------------------------------------------------
* Parameter and state extractions and manipulation functions
* ---------------------------------------------------------------- */

iaf_cond_alpha_neuron::Buffers_::Buffers_(iaf_cond_alpha_neuron &n)
    : logger_(n), __s(0), __c(0), __e(0) {}

iaf_cond_alpha_neuron::Buffers_::Buffers_(const Buffers_ &,
                                          iaf_cond_alpha_neuron &n)
    : logger_(n), __s(0), __c(0), __e(0)

{}

/* ----------------------------------------------------------------
* Default and copy constructor for node
* ---------------------------------------------------------------- */
// TODO inner components
iaf_cond_alpha_neuron::iaf_cond_alpha_neuron()
    : Archiving_Node(), P_(), S_(), B_(*this) {
  recordablesMap_.create();

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.V_th = ((-55.0));

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.V_reset = ((-60.0));

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.t_ref = 2.;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.g_L = 16.6667;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.C_m = 250.0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.E_ex = 0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.E_in = ((-85.0));

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.E_L = ((-70.0));

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.tau_syn_ex = 0.2;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.tau_syn_in = 2.0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.I_e = 0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.I_stim = 0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y[State_::V_m] = get_E_L();

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y[State_::g_in] = 0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y[State_::g_ex] = 0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y[State_::__D_g_in] = 0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y[State_::__D_g_ex] = 0;
}

iaf_cond_alpha_neuron::iaf_cond_alpha_neuron(const iaf_cond_alpha_neuron &n)
    : Archiving_Node(), P_(n.P_), S_(n.S_), B_(n.B_, *this) {}

/* ----------------------------------------------------------------
* Destructors
* ---------------------------------------------------------------- */

iaf_cond_alpha_neuron::~iaf_cond_alpha_neuron() {
  // GSL structs may not have been allocated, so we need to protect destruction
  if (B_.__s)
    gsl_odeiv_step_free(B_.__s);
  if (B_.__c)
    gsl_odeiv_control_free(B_.__c);
  if (B_.__e)
    gsl_odeiv_evolve_free(B_.__e);
}

/* ----------------------------------------------------------------
* Node initialization functions
* ---------------------------------------------------------------- */

void iaf_cond_alpha_neuron::init_state_(
    const Node &proto) { // TODO inner components

  const iaf_cond_alpha_neuron &pr = downcast<iaf_cond_alpha_neuron>(proto);
  S_ = pr.S_;
}

/* generated by template
 * org.nest.nestml.neuron.function.GSLDifferentiationFunction*/
extern "C" inline int iaf_cond_alpha_neuron_dynamics(double, const double y[],
                                                     double f[], void *pnode) {
  typedef iaf_cond_alpha_neuron::State_ State_;
  // get access to node so we can almost work as in a member function
  assert(pnode);
  const iaf_cond_alpha_neuron &node =
      *(reinterpret_cast<iaf_cond_alpha_neuron *>(pnode));

  // y[] here is---and must be---the state vector supplied by the integrator,
  // not the state vector in the node, node.S_.y[].

  double I_syn_exc = y[State_::g_ex] * (y[State_::V_m] - node.get_E_ex());
  double I_syn_inh = y[State_::g_in] * (y[State_::V_m] - node.get_E_in());
  double I_leak = node.get_g_L() * (y[State_::V_m] - node.get_E_L());

  f[State_::V_m] = (((-I_leak)) - I_syn_exc - I_syn_inh + node.get_I_stim() +
                    node.get_I_e()) /
                   node.get_C_m();
  f[State_::g_in] = y[State_::__D_g_in];
  f[State_::g_ex] = y[State_::__D_g_ex];
  f[State_::__D_g_in] =
      ((-(y[State_::g_in] + 2 * y[State_::__D_g_in] * node.get_tau_syn_in()))) /
      pow((node.get_tau_syn_in()), (2));
  f[State_::__D_g_ex] =
      ((-(y[State_::g_ex] + 2 * y[State_::__D_g_ex] * node.get_tau_syn_ex()))) /
      pow((node.get_tau_syn_ex()), (2));

  return GSL_SUCCESS;
}

void iaf_cond_alpha_neuron::init_buffers_() {
  get_spikeInh().clear(); // includes resize
  get_spikeExc().clear(); // includes resize
  get_currents().clear(); // includes resize
  B_.logger_.reset();     // includes resize
  Archiving_Node::clear_history();
  if (B_.__s == 0) {
    B_.__s = gsl_odeiv_step_alloc(gsl_odeiv_step_rkf45, 5);
  } else {
    gsl_odeiv_step_reset(B_.__s);
  }

  if (B_.__c == 0) {
    B_.__c = gsl_odeiv_control_y_new(1e-6, 0.0);
  } else {
    gsl_odeiv_control_init(B_.__c, 1e-6, 0.0, 1.0, 0.0);
  }

  if (B_.__e == 0) {
    B_.__e = gsl_odeiv_evolve_alloc(5);
  } else {
    gsl_odeiv_evolve_reset(B_.__e);
  }

  B_.__sys.function = iaf_cond_alpha_neuron_dynamics;
  B_.__sys.jacobian = NULL;
  B_.__sys.dimension = 5;
  B_.__sys.params = reinterpret_cast<void *>(this);
  B_.__step = nest::Time::get_resolution().get_ms();
  B_.__integration_step = nest::Time::get_resolution().get_ms();
}

void iaf_cond_alpha_neuron::calibrate() {
  B_.logger_.init();

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.RefractoryCounts =
      nest::Time(nest::Time::ms((double)P_.t_ref)).get_steps();

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.r = 0;

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.g_in__D_PSCInitialValue = numerics::e / P_.tau_syn_in;

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.g_ex__D_PSCInitialValue = numerics::e / P_.tau_syn_ex;
}

/* ----------------------------------------------------------------
* Update and spike handling functions
* ---------------------------------------------------------------- */

/*

 */
void iaf_cond_alpha_neuron::update(nest::Time const &origin, const long from,
                                   const long to) {
  double t = 0;

  for (long lag = from; lag < to; ++lag) {
    // TODO this case must be handled uniformly, also NESTReferenceConverter
    // must be adopted
    B_.spikeInh_last_value_ = get_spikeInh().get_value(lag);
    // TODO this case must be handled uniformly, also NESTReferenceConverter
    // must be adopted
    B_.spikeExc_last_value_ = get_spikeExc().get_value(lag);
    // TODO this case must be handled uniformly, also NESTReferenceConverter
    // must be adopted
    B_.currents_last_value_ = get_currents().get_value(lag);

    /* generated by template org.nest.spl.Block*/
    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.SmallStatement*/
    /* generated by template org.nest.spl.small_statement.FunctionCall*/
    /* generated by template org.nest.spl.small_statement.GSLIntegrator*/
    t = 0;

    while (t < B_.__step) {
      const int status = gsl_odeiv_evolve_apply(
          B_.__e, B_.__c, B_.__s,
          &B_.__sys,              // system of ODE
          &t,                     // from t
          B_.__step,              // to t <= step
          &B_.__integration_step, // integration step size
          S_.y);                  // neuronal state

      if (status != GSL_SUCCESS) {
        throw nest::GSLSolverFailure(get_name(), status);
      }
    }

    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.CompoundStatement*/
    /* generated by template org.nest.spl.compound_statement.IfStatement*/

    if (V_.r != 0) {
      /* generated by template org.nest.spl.Block*/
      /* generated by template org.nest.spl.Statement*/
      //
      /* generated by template org.nest.spl.SmallStatement*/
      /* generated by template org.nest.spl.small_statement.Assignment*/
      V_.r = V_.r - 1;

      /* generated by template org.nest.spl.Statement*/
      //
      /* generated by template org.nest.spl.SmallStatement*/
      /* generated by template org.nest.spl.small_statement.Assignment*/
      S_.y[State_::V_m] = P_.V_reset;

    } else if (S_.y[State_::V_m] >= P_.V_th) {
      /* generated by template org.nest.spl.Block*/
      /* generated by template org.nest.spl.Statement*/
      //
      /* generated by template org.nest.spl.SmallStatement*/
      /* generated by template org.nest.spl.small_statement.Assignment*/
      V_.r = V_.RefractoryCounts;

      /* generated by template org.nest.spl.Statement*/
      //
      /* generated by template org.nest.spl.SmallStatement*/
      /* generated by template org.nest.spl.small_statement.Assignment*/
      S_.y[State_::V_m] = P_.V_reset;

      /* generated by template org.nest.spl.Statement*/
      //
      /* generated by template org.nest.spl.SmallStatement*/
      /* generated by template org.nest.spl.small_statement.FunctionCall*/
      set_spiketime(nest::Time::step(origin.get_steps() + lag + 1));
      nest::SpikeEvent se;
      nest::kernel().event_delivery_manager.send(*this, se, lag);
      ;

    } /* if end */

    /* generated by template org.nest.spl.Statement*/
    // # set new input current
    /* generated by template org.nest.spl.SmallStatement*/
    /* generated by template org.nest.spl.small_statement.Assignment*/
    P_.I_stim = B_.currents_last_value_;

    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.SmallStatement*/
    /* generated by template org.nest.spl.small_statement.Assignment*/
    S_.y[State_::__D_g_in] +=
        V_.g_in__D_PSCInitialValue * B_.spikeInh_last_value_;

    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.SmallStatement*/
    /* generated by template org.nest.spl.small_statement.Assignment*/
    S_.y[State_::__D_g_ex] +=
        V_.g_ex__D_PSCInitialValue * B_.spikeExc_last_value_;

    // voltage logging
    B_.logger_.record_data(origin.get_steps() + lag);
  }
}

// Do not move this function as inline to h-file. It depends on
// universal_data_logger_impl.h being included here.
void iaf_cond_alpha_neuron::handle(nest::DataLoggingRequest &e) {
  B_.logger_.handle(e);
}

void iaf_cond_alpha_neuron::handle(nest::SpikeEvent &e) {
  assert(e.get_delay() > 0);

  const double weight = e.get_weight();
  const double multiplicity = e.get_multiplicity();
  if (weight < 0.0) // inhibitory
  {
    get_spikeInh().add_value(
        e.get_rel_delivery_steps(
            nest::kernel().simulation_manager.get_slice_origin()),
        // ensure conductance is positive
        -1 * weight * multiplicity);
  }
  if (weight >= 0.0) // excitatory
  {
    get_spikeExc().add_value(
        e.get_rel_delivery_steps(
            nest::kernel().simulation_manager.get_slice_origin()),
        weight * multiplicity);
  }
}

void iaf_cond_alpha_neuron::handle(nest::CurrentEvent &e) {
  assert(e.get_delay() > 0);

  const double current = e.get_current();
  const double weight = e.get_weight();

  // add weighted current; HEP 2002-10-04
  get_currents().add_value(
      e.get_rel_delivery_steps(
          nest::kernel().simulation_manager.get_slice_origin()),
      weight * current);
}
