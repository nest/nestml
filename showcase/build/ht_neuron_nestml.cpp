/* generated by template org.nest.nestml.neuron.NeuronClass*/
/*
*  ht_neuron_nestml.cpp
*
*  This file is part of NEST.
*
*  Copyright (C) 2004 The NEST Initiative
*
*  NEST is free software: you can redistribute it and/or modify
*  it under the terms of the GNU General Public License as published by
*  the Free Software Foundation, either version 2 of the License, or
*  (at your option) any later version.
*
*  NEST is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU General Public License for more details.
*
*  You should have received a copy of the GNU General Public License
*  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
*
*/

// C++ includes:
#include <limits>

// Includes from libnestutil:
#include "numerics.h"

// Includes from nestkernel:
#include "exceptions.h"
#include "kernel_manager.h"
#include "universal_data_logger_impl.h"

// Includes from sli:
#include "dict.h"
#include "dictutils.h"
#include "doubledatum.h"
#include "integerdatum.h"
#include "lockptrdatum.h"

#include "ht_neuron_nestml.h"

/* ----------------------------------------------------------------
* Recordables map
* ---------------------------------------------------------------- */
nest::RecordablesMap<ht_neuron_nestml> ht_neuron_nestml::recordablesMap_;

namespace nest {
// Override the create() method with one call to RecordablesMap::insert_()
// for each quantity to be recorded.
template <> void RecordablesMap<ht_neuron_nestml>::create() {
  // use standard names whereever you can for consistency!
  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("V_m", &ht_neuron_nestml::get_V_m);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("Theta", &ht_neuron_nestml::get_Theta);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("g_AMPA", &ht_neuron_nestml::get_g_AMPA);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("g_NMDA", &ht_neuron_nestml::get_g_NMDA);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("g_GABAA", &ht_neuron_nestml::get_g_GABAA);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("g_GABAB", &ht_neuron_nestml::get_g_GABAB);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("IKNa_D", &ht_neuron_nestml::get_IKNa_D);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("IT_m", &ht_neuron_nestml::get_IT_m);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("IT_h", &ht_neuron_nestml::get_IT_h);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("Ih_m", &ht_neuron_nestml::get_Ih_m);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the r_potassium with the domain type long

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the g_spike with the domain type bool

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("g_AMPA'", &ht_neuron_nestml::get___D_g_AMPA);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("g_NMDA'", &ht_neuron_nestml::get___D_g_NMDA);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("g_GABAA'", &ht_neuron_nestml::get___D_g_GABAA);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("g_GABAB'", &ht_neuron_nestml::get___D_g_GABAB);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the AMPAInitialValue with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the NMDAInitialValue with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the GABA_AInitialValue with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the GABA_BInitialValue with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the PotassiumRefractoryCounts with the domain type long

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the I_stim with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the E_Na with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the E_K with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the g_NaL with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the g_KL with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the Tau_m with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the Theta_eq with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the Tau_theta with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the Tau_spike with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the t_spike with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the AMPA_g_peak with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the AMPA_E_rev with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the AMPA_Tau_1 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the AMPA_Tau_2 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the NMDA_g_peak with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the NMDA_Tau_1 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the NMDA_Tau_2 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the NMDA_E_rev with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the NMDA_Vact with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the NMDA_Sact with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the GABA_A_g_peak with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the GABA_A_Tau_1 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the GABA_A_Tau_2 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the GABA_A_E_rev with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the GABA_B_g_peak with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the GABA_B_Tau_1 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the GABA_B_Tau_2 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the GABA_B_E_rev with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the NaP_g_peak with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the NaP_E_rev with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the KNa_g_peak with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the KNa_E_rev with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the T_g_peak with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the T_E_rev with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the h_g_peak with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the h_E_rev with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the KNa_D_EQ with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the I_syn_ampa with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the I_syn_nmda with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the I_syn_gaba_a with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the I_syn_gaba_b with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the I_syn with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the INaP_thresh with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the INaP_slope with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the m_inf_NaP with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("I_NaP", &ht_neuron_nestml::get_I_NaP);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the d_half with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the m_inf_KNa with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("I_KNa", &ht_neuron_nestml::get_I_KNa);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("I_T", &ht_neuron_nestml::get_I_T);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("I_h", &ht_neuron_nestml::get_I_h);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the I_spike with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the m_inf_T with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the h_inf_T with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the tau_m_h with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the D_influx_peak with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the tau_D with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the D_thresh with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the D_slope with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the D_influx with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the I_Na with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the I_K with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the tau_m_T with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the tau_h_T with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the I_h_Vthreshold with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the m_inf_h with the domain type double
}
}

/* ----------------------------------------------------------------
* Default constructors defining default parameters and state
* ---------------------------------------------------------------- */
ht_neuron_nestml::Parameters_::Parameters_() {
  E_Na = 0;
  E_K = 0;
  g_NaL = 0;
  g_KL = 0;
  Tau_m = 0;
  Theta_eq = 0;
  Tau_theta = 0;
  Tau_spike = 0;
  t_spike = 0;
  AMPA_g_peak = 0;
  AMPA_E_rev = 0;
  AMPA_Tau_1 = 0;
  AMPA_Tau_2 = 0;
  NMDA_g_peak = 0;
  NMDA_Tau_1 = 0;
  NMDA_Tau_2 = 0;
  NMDA_E_rev = 0;
  NMDA_Vact = 0;
  NMDA_Sact = 0;
  GABA_A_g_peak = 0;
  GABA_A_Tau_1 = 0;
  GABA_A_Tau_2 = 0;
  GABA_A_E_rev = 0;
  GABA_B_g_peak = 0;
  GABA_B_Tau_1 = 0;
  GABA_B_Tau_2 = 0;
  GABA_B_E_rev = 0;
  NaP_g_peak = 0;
  NaP_E_rev = 0;
  KNa_g_peak = 0;
  KNa_E_rev = 0;
  T_g_peak = 0;
  T_E_rev = 0;
  h_g_peak = 0;
  h_E_rev = 0;
  KNa_D_EQ = 0;
}

ht_neuron_nestml::State_::State_() {
  y[State_::V_m] = 0;
  y[State_::Theta] = 0;
  y[State_::g_AMPA] = 0;
  y[State_::g_NMDA] = 0;
  y[State_::g_GABAA] = 0;
  y[State_::g_GABAB] = 0;
  y[State_::IKNa_D] = 0;
  y[State_::IT_m] = 0;
  y[State_::IT_h] = 0;
  y[State_::Ih_m] = 0;
  y[State_::r_potassium] = 0;
  y[State_::g_spike] = 0;
  y[State_::__D_g_AMPA] = 0;
  y[State_::__D_g_NMDA] = 0;
  y[State_::__D_g_GABAA] = 0;
  y[State_::__D_g_GABAB] = 0;
}

/* ----------------------------------------------------------------
* Parameter and state extractions and manipulation functions
* ---------------------------------------------------------------- */

ht_neuron_nestml::Buffers_::Buffers_(ht_neuron_nestml &n)
    : logger_(n),
      spike_inputs_(std::vector<nest::RingBuffer>(SUP_SPIKE_RECEPTOR - 1)),
      __s(0), __c(0), __e(0) {}

ht_neuron_nestml::Buffers_::Buffers_(const Buffers_ &, ht_neuron_nestml &n)
    : logger_(n),
      spike_inputs_(std::vector<nest::RingBuffer>(SUP_SPIKE_RECEPTOR - 1)),
      __s(0), __c(0), __e(0)

{}

/* ----------------------------------------------------------------
* Default and copy constructor for node
* ---------------------------------------------------------------- */
// TODO inner components
ht_neuron_nestml::ht_neuron_nestml() : Archiving_Node(), P_(), S_(), B_(*this) {
  recordablesMap_.create();

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.E_Na = 30.0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.E_K = ((-90.0));

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.g_NaL = 0.2;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.g_KL = 1.0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.Tau_m = 16.0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.Theta_eq = ((-51.0));

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.Tau_theta = 2.0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.Tau_spike = 1.75;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.t_spike = 2.0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.AMPA_g_peak = 0.1;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.AMPA_E_rev = 0.0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.AMPA_Tau_1 = 0.5;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.AMPA_Tau_2 = 2.4;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.NMDA_g_peak = 0.075;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.NMDA_Tau_1 = 4.0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.NMDA_Tau_2 = 40.0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.NMDA_E_rev = 0.0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.NMDA_Vact = ((-58.0));

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.NMDA_Sact = 2.5;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.GABA_A_g_peak = 0.33;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.GABA_A_Tau_1 = 1.0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.GABA_A_Tau_2 = 7.0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.GABA_A_E_rev = ((-70.0));

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.GABA_B_g_peak = 0.0132;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.GABA_B_Tau_1 = 60.0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.GABA_B_Tau_2 = 200.0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.GABA_B_E_rev = ((-90.0));

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.NaP_g_peak = 1.0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.NaP_E_rev = 30.0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.KNa_g_peak = 1.0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.KNa_E_rev = ((-90.0));

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.T_g_peak = 1.0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.T_E_rev = 0.0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.h_g_peak = 1.0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.h_E_rev = ((-40.0));

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.KNa_D_EQ = 0.001;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y[State_::V_m] = (get_g_NaL() * get_E_Na() + get_g_KL() * get_E_K()) /
                      (get_g_NaL() + get_g_KL());

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y[State_::Theta] = get_Theta_eq();

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y[State_::g_AMPA] = 0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y[State_::g_NMDA] = 0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y[State_::g_GABAA] = 0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y[State_::g_GABAB] = 0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y[State_::IKNa_D] = 0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y[State_::IT_m] = 0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y[State_::IT_h] = 0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y[State_::Ih_m] = 0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y[State_::r_potassium] = 0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y[State_::g_spike] = false;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y[State_::__D_g_AMPA] = 0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y[State_::__D_g_NMDA] = 0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y[State_::__D_g_GABAA] = 0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y[State_::__D_g_GABAB] = 0;
}

ht_neuron_nestml::ht_neuron_nestml(const ht_neuron_nestml &n)
    : Archiving_Node(), P_(n.P_), S_(n.S_), B_(n.B_, *this) {}

/* ----------------------------------------------------------------
* Destructors
* ---------------------------------------------------------------- */

ht_neuron_nestml::~ht_neuron_nestml() {
  // GSL structs may not have been allocated, so we need to protect destruction
  if (B_.__s)
    gsl_odeiv_step_free(B_.__s);
  if (B_.__c)
    gsl_odeiv_control_free(B_.__c);
  if (B_.__e)
    gsl_odeiv_evolve_free(B_.__e);
}

/* ----------------------------------------------------------------
* Node initialization functions
* ---------------------------------------------------------------- */

void ht_neuron_nestml::init_state_(const Node &proto) { // TODO inner components

  const ht_neuron_nestml &pr = downcast<ht_neuron_nestml>(proto);
  S_ = pr.S_;
}

/* generated by template
 * org.nest.nestml.neuron.function.GSLDifferentiationFunction*/
extern "C" inline int ht_neuron_nestml_dynamics(double, const double y[],
                                                double f[], void *pnode) {
  typedef ht_neuron_nestml::State_ State_;
  // get access to node so we can almost work as in a member function
  assert(pnode);
  const ht_neuron_nestml &node = *(reinterpret_cast<ht_neuron_nestml *>(pnode));

  // y[] here is---and must be---the state vector supplied by the integrator,
  // not the state vector in the node, node.S_.y[].

  double I_syn_ampa =
      ((-y[State_::g_AMPA])) * (y[State_::V_m] - node.get_AMPA_E_rev());
  double I_syn_nmda = ((-y[State_::g_NMDA])) *
                      (y[State_::V_m] - node.get_NMDA_E_rev()) /
                      (1 + std::exp((node.get_NMDA_Vact() - y[State_::V_m]) /
                                    node.get_NMDA_Sact()));
  double I_syn_gaba_a =
      ((-y[State_::g_GABAA])) * (y[State_::V_m] - node.get_GABA_A_E_rev());
  double I_syn_gaba_b =
      ((-y[State_::g_GABAB])) * (y[State_::V_m] - node.get_GABA_B_E_rev());
  double I_syn = I_syn_ampa + I_syn_nmda + I_syn_gaba_a + I_syn_gaba_b;
  double INaP_thresh = ((-55.7));
  double INaP_slope = 7.7;
  double m_inf_NaP =
      1.0 / (1.0 + std::exp(((-(y[State_::V_m] - INaP_thresh))) / INaP_slope));
  double I_NaP = ((-node.get_NaP_g_peak())) * std::pow(m_inf_NaP, 3.0) *
                 (y[State_::V_m] - node.get_NaP_E_rev());
  double d_half = 0.25;
  double m_inf_KNa = 1.0 / (1.0 + std::pow(d_half / y[State_::IKNa_D], 3.5));
  double I_KNa = ((-node.get_KNa_g_peak())) * m_inf_KNa *
                 (y[State_::V_m] - node.get_KNa_E_rev());
  double I_T = ((-node.get_T_g_peak())) * y[State_::IT_m] * y[State_::IT_m] *
               y[State_::IT_h] * (y[State_::V_m] - node.get_T_E_rev());
  double I_h = ((-node.get_h_g_peak())) * y[State_::Ih_m] *
               (y[State_::V_m] - node.get_h_E_rev());
  double I_spike =
      (((node.get_g_spike())))
          ? ((((-(y[State_::V_m] - node.get_E_K()))) / node.get_Tau_spike()))
          : ((0));
  double m_inf_T = 1.0 / (1.0 + std::exp(((-(y[State_::V_m] + 59.0))) / 6.2));
  double h_inf_T = 1.0 / (1.0 + std::exp((y[State_::V_m] + 83.0) / 4));
  double tau_m_h = 1.0 / (std::exp(((-14.59)) - 0.086 * y[State_::V_m]) +
                          std::exp(((-1.87)) + 0.0701 * y[State_::V_m]));
  double D_influx_peak = 0.025;
  double tau_D = 1250.0;
  double D_thresh = ((-10.0));
  double D_slope = 5.0;
  double D_influx =
      1.0 / (1.0 + std::exp(((-(y[State_::V_m] - D_thresh))) / D_slope));
  double I_Na = ((-node.get_g_NaL())) * (y[State_::V_m] - node.get_E_Na());
  double I_K = ((-node.get_g_KL())) * (y[State_::V_m] - node.get_E_K());
  double tau_m_T = 0.22 / (std::exp(((-(y[State_::V_m] + 132.0))) / 16.7) +
                           std::exp((y[State_::V_m] + 16.8) / 18.2)) +
                   0.13;
  double tau_h_T = 8.2 +
                   (56.6 + 0.27 * std::exp((y[State_::V_m] + 115.2) / 5.0)) /
                       (1.0 + std::exp((y[State_::V_m] + 86.0) / 3.2));
  double I_h_Vthreshold = ((-75.0));
  double m_inf_h =
      1.0 / (1.0 + std::exp((y[State_::V_m] - I_h_Vthreshold) / 5.5));

  f[State_::V_m] =
      (I_Na + I_K + I_syn + I_NaP + I_KNa + I_T + I_h + node.get_I_stim()) /
          node.get_Tau_m() +
      I_spike;
  f[State_::Theta] =
      ((-(y[State_::Theta] - node.get_Theta_eq()))) / node.get_Tau_theta();
  f[State_::g_AMPA] =
      y[State_::__D_g_AMPA] - y[State_::g_AMPA] / node.get_AMPA_Tau_2();
  f[State_::g_NMDA] =
      y[State_::__D_g_NMDA] - y[State_::g_NMDA] / node.get_NMDA_Tau_2();
  f[State_::g_GABAA] =
      y[State_::__D_g_GABAA] - y[State_::g_GABAA] / node.get_GABA_A_Tau_2();
  f[State_::g_GABAB] =
      y[State_::__D_g_GABAB] - y[State_::g_GABAB] / node.get_GABA_B_Tau_2();
  f[State_::IKNa_D] = D_influx_peak * D_influx -
                      (y[State_::IKNa_D] - node.get_KNa_D_EQ()) / tau_D;
  f[State_::IT_m] = (m_inf_T - y[State_::IT_m]) / tau_m_T;
  f[State_::IT_h] = (h_inf_T - y[State_::IT_h]) / tau_h_T;
  f[State_::Ih_m] = (m_inf_h - y[State_::Ih_m]) / tau_m_h;
  f[State_::__D_g_AMPA] = ((-y[State_::__D_g_AMPA])) / node.get_AMPA_Tau_1();
  f[State_::__D_g_NMDA] = ((-y[State_::__D_g_NMDA])) / node.get_NMDA_Tau_1();
  f[State_::__D_g_GABAA] =
      ((-y[State_::__D_g_GABAA])) / node.get_GABA_A_Tau_1();
  f[State_::__D_g_GABAB] =
      ((-y[State_::__D_g_GABAB])) / node.get_GABA_B_Tau_1();

  return GSL_SUCCESS;
}

void ht_neuron_nestml::init_buffers_() {
  get_AMPA().clear();     // includes resize
  get_NMDA().clear();     // includes resize
  get_GABA_A().clear();   // includes resize
  get_GABA_B().clear();   // includes resize
  get_currents().clear(); // includes resize
  B_.logger_.reset();     // includes resize
  Archiving_Node::clear_history();
  if (B_.__s == 0) {
    B_.__s = gsl_odeiv_step_alloc(gsl_odeiv_step_rkf45, 14);
  } else {
    gsl_odeiv_step_reset(B_.__s);
  }

  if (B_.__c == 0) {
    B_.__c = gsl_odeiv_control_y_new(1e-6, 0.0);
  } else {
    gsl_odeiv_control_init(B_.__c, 1e-6, 0.0, 1.0, 0.0);
  }

  if (B_.__e == 0) {
    B_.__e = gsl_odeiv_evolve_alloc(14);
  } else {
    gsl_odeiv_evolve_reset(B_.__e);
  }

  B_.__sys.function = ht_neuron_nestml_dynamics;
  B_.__sys.jacobian = NULL;
  B_.__sys.dimension = 14;
  B_.__sys.params = reinterpret_cast<void *>(this);
  B_.__step = nest::Time::get_resolution().get_ms();
  B_.__integration_step = nest::Time::get_resolution().get_ms();
}

void ht_neuron_nestml::calibrate() {
  B_.logger_.init();

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.AMPAInitialValue =
      compute_synapse_constant(P_.AMPA_Tau_1, P_.AMPA_Tau_2, P_.AMPA_g_peak);

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.NMDAInitialValue =
      compute_synapse_constant(P_.NMDA_Tau_1, P_.NMDA_Tau_2, P_.NMDA_g_peak);

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.GABA_AInitialValue = compute_synapse_constant(
      P_.GABA_A_Tau_1, P_.GABA_A_Tau_2, P_.GABA_A_g_peak);

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.GABA_BInitialValue = compute_synapse_constant(
      P_.GABA_B_Tau_1, P_.GABA_B_Tau_2, P_.GABA_B_g_peak);

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.PotassiumRefractoryCounts =
      nest::Time(nest::Time::ms((double)P_.t_spike)).get_steps();

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.I_stim = 0;
}

/* ----------------------------------------------------------------
* Update and spike handling functions
* ---------------------------------------------------------------- */

/*

 */
void ht_neuron_nestml::update(nest::Time const &origin, const long from,
                              const long to) {
  double t = 0;

  for (long lag = from; lag < to; ++lag) {
    // TODO this case must be handled uniformly, also NESTReferenceConverter
    // must be adopted
    B_.AMPA_last_value_ = get_AMPA().get_value(lag);
    // TODO this case must be handled uniformly, also NESTReferenceConverter
    // must be adopted
    B_.NMDA_last_value_ = get_NMDA().get_value(lag);
    // TODO this case must be handled uniformly, also NESTReferenceConverter
    // must be adopted
    B_.GABA_A_last_value_ = get_GABA_A().get_value(lag);
    // TODO this case must be handled uniformly, also NESTReferenceConverter
    // must be adopted
    B_.GABA_B_last_value_ = get_GABA_B().get_value(lag);
    // TODO this case must be handled uniformly, also NESTReferenceConverter
    // must be adopted
    B_.currents_last_value_ = get_currents().get_value(lag);

    /* generated by template org.nest.spl.Block*/
    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.SmallStatement*/
    /* generated by template org.nest.spl.small_statement.FunctionCall*/
    /* generated by template org.nest.spl.small_statement.GSLIntegrator*/
    t = 0;

    while (t < B_.__step) {
      const int status = gsl_odeiv_evolve_apply(
          B_.__e, B_.__c, B_.__s,
          &B_.__sys,              // system of ODE
          &t,                     // from t
          B_.__step,              // to t <= step
          &B_.__integration_step, // integration step size
          S_.y);                  // neuronal state

      if (status != GSL_SUCCESS) {
        throw nest::GSLSolverFailure(get_name(), status);
      }
    }

    /* generated by template org.nest.spl.Statement*/
    // # Deactivate potassium current after spike time have expired
    /* generated by template org.nest.spl.CompoundStatement*/
    /* generated by template org.nest.spl.compound_statement.IfStatement*/

    if ((((S_.y[State_::r_potassium] > 0))) &&
        (((S_.y[State_::r_potassium] - 1 == 0)))) {
      /* generated by template org.nest.spl.Block*/
      /* generated by template org.nest.spl.Statement*/
      //
      /* generated by template org.nest.spl.SmallStatement*/
      /* generated by template org.nest.spl.small_statement.Assignment*/
      S_.y[State_::g_spike] = false;

    } /* if end */

    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.SmallStatement*/
    /* generated by template org.nest.spl.small_statement.Assignment*/
    S_.y[State_::r_potassium] -= 1;

    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.SmallStatement*/
    /* generated by template org.nest.spl.small_statement.Assignment*/
    S_.y[State_::__D_g_AMPA] += V_.AMPAInitialValue * B_.AMPA_last_value_;

    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.SmallStatement*/
    /* generated by template org.nest.spl.small_statement.Assignment*/
    S_.y[State_::__D_g_NMDA] += V_.NMDAInitialValue * B_.NMDA_last_value_;

    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.SmallStatement*/
    /* generated by template org.nest.spl.small_statement.Assignment*/
    S_.y[State_::__D_g_GABAA] += V_.GABA_AInitialValue * B_.GABA_A_last_value_;

    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.SmallStatement*/
    /* generated by template org.nest.spl.small_statement.Assignment*/
    S_.y[State_::__D_g_GABAB] += V_.GABA_BInitialValue * B_.GABA_B_last_value_;

    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.CompoundStatement*/
    /* generated by template org.nest.spl.compound_statement.IfStatement*/

    if ((((not S_.y[State_::g_spike]))) &&
        ((S_.y[State_::V_m] >= S_.y[State_::Theta]))) {
      /* generated by template org.nest.spl.Block*/
      /* generated by template org.nest.spl.Statement*/
      // # Set V and Theta to the sodium reversal potential.
      /* generated by template org.nest.spl.SmallStatement*/
      /* generated by template org.nest.spl.small_statement.Assignment*/
      S_.y[State_::V_m] = P_.E_Na;

      /* generated by template org.nest.spl.Statement*/
      //
      /* generated by template org.nest.spl.SmallStatement*/
      /* generated by template org.nest.spl.small_statement.Assignment*/
      S_.y[State_::Theta] = P_.E_Na;

      /* generated by template org.nest.spl.Statement*/
      // # Activate fast potassium current. Drives the# membrane potential
      // towards the potassium reversal# potential (activate only if duration is
      // non-zero).
      /* generated by template org.nest.spl.CompoundStatement*/
      /* generated by template org.nest.spl.compound_statement.IfStatement*/

      if (V_.PotassiumRefractoryCounts > 0) {
        /* generated by template org.nest.spl.Block*/
        /* generated by template org.nest.spl.Statement*/
        //
        /* generated by template org.nest.spl.SmallStatement*/
        /* generated by template org.nest.spl.small_statement.Assignment*/
        S_.y[State_::g_spike] = true;

      } else {
        /* generated by template org.nest.spl.Block*/
        /* generated by template org.nest.spl.Statement*/
        //
        /* generated by template org.nest.spl.SmallStatement*/
        /* generated by template org.nest.spl.small_statement.Assignment*/
        S_.y[State_::g_spike] = false;

      } /* if end */

      /* generated by template org.nest.spl.Statement*/
      //
      /* generated by template org.nest.spl.SmallStatement*/
      /* generated by template org.nest.spl.small_statement.Assignment*/
      S_.y[State_::r_potassium] = V_.PotassiumRefractoryCounts;

      /* generated by template org.nest.spl.Statement*/
      //
      /* generated by template org.nest.spl.SmallStatement*/
      /* generated by template org.nest.spl.small_statement.FunctionCall*/
      set_spiketime(nest::Time::step(origin.get_steps() + lag + 1));
      nest::SpikeEvent se;
      nest::kernel().event_delivery_manager.send(*this, se, lag);
      ;

    } /* if end */

    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.SmallStatement*/
    /* generated by template org.nest.spl.small_statement.Assignment*/
    V_.I_stim = B_.currents_last_value_;

    // voltage logging
    B_.logger_.record_data(origin.get_steps() + lag);
  }
}

// Do not move this function as inline to h-file. It depends on
// universal_data_logger_impl.h being included here.
void ht_neuron_nestml::handle(nest::DataLoggingRequest &e) {
  B_.logger_.handle(e);
}

//
double ht_neuron_nestml::compute_synapse_constant(double Tau_1, double Tau_2,
                                                  double g_peak)

{
  /* generated by template org.nest.spl.Block*/
  /* generated by template org.nest.spl.Statement*/
  // # Factor used to account for the missing 1/((1/Tau_2)-(1/Tau_1)) term# in
  // the ht_neuron_dynamics integration of the synapse terms.# See: Exact
  // digital simulation of time-invariant linear systems# with applications to
  // neuronal modeling, Rotter and Diesmann,# section 3.1.2.
  /* generated by template org.nest.spl.SmallStatement*/
  /* generated by template org.nest.spl.small_statement.Declaration*/

  double exact_integration_adjustment = (1 / Tau_2) - (1 / Tau_1);

  /* generated by template org.nest.spl.Statement*/
  //
  /* generated by template org.nest.spl.SmallStatement*/
  /* generated by template org.nest.spl.small_statement.Declaration*/

  double t_peak = (Tau_2 * Tau_1) * std::log(Tau_2 / Tau_1) / (Tau_2 - Tau_1);

  /* generated by template org.nest.spl.Statement*/
  //
  /* generated by template org.nest.spl.SmallStatement*/
  /* generated by template org.nest.spl.small_statement.Declaration*/

  double normalisation_factor =
      1 / (std::exp(((-t_peak)) / Tau_1) - std::exp(((-t_peak)) / Tau_2));

  /* generated by template org.nest.spl.Statement*/
  //
  /* generated by template org.nest.spl.SmallStatement*/
  /* generated by template org.nest.spl.small_statement.ReturnStatement*/
  return g_peak * normalisation_factor * exact_integration_adjustment;
}

void ht_neuron_nestml::handle(nest::SpikeEvent &e) {
  assert(e.get_delay() > 0);

  assert(e.get_rport() < static_cast<int>(B_.spike_inputs_.size()));

  B_.spike_inputs_[e.get_rport()].add_value(
      e.get_rel_delivery_steps(
          nest::kernel().simulation_manager.get_slice_origin()),
      e.get_weight() * e.get_multiplicity());
}

void ht_neuron_nestml::handle(nest::CurrentEvent &e) {
  assert(e.get_delay() > 0);

  const double current = e.get_current();
  const double weight = e.get_weight();

  // add weighted current; HEP 2002-10-04
  get_currents().add_value(
      e.get_rel_delivery_steps(
          nest::kernel().simulation_manager.get_slice_origin()),
      weight * current);
}
