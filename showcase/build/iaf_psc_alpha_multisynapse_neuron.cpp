/* generated by template org.nest.nestml.neuron.NeuronClass*/
/*
*  iaf_psc_alpha_multisynapse_neuron.cpp
*
*  This file is part of NEST.
*
*  Copyright (C) 2004 The NEST Initiative
*
*  NEST is free software: you can redistribute it and/or modify
*  it under the terms of the GNU General Public License as published by
*  the Free Software Foundation, either version 2 of the License, or
*  (at your option) any later version.
*
*  NEST is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU General Public License for more details.
*
*  You should have received a copy of the GNU General Public License
*  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
*
*/

// C++ includes:
#include <limits>

// Includes from libnestutil:
#include "numerics.h"

// Includes from nestkernel:
#include "exceptions.h"
#include "kernel_manager.h"
#include "universal_data_logger_impl.h"

// Includes from sli:
#include "dict.h"
#include "dictutils.h"
#include "doubledatum.h"
#include "integerdatum.h"
#include "lockptrdatum.h"

#include "iaf_psc_alpha_multisynapse_neuron.h"

/* ----------------------------------------------------------------
* Recordables map
* ---------------------------------------------------------------- */
nest::RecordablesMap<iaf_psc_alpha_multisynapse_neuron>
    iaf_psc_alpha_multisynapse_neuron::recordablesMap_;

namespace nest {
// Override the create() method with one call to RecordablesMap::insert_()
// for each quantity to be recorded.
template <> void RecordablesMap<iaf_psc_alpha_multisynapse_neuron>::create() {
  // use standard names whereever you can for consistency!
  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("V_abs", &iaf_psc_alpha_multisynapse_neuron::get_V_abs);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  insert_("V_m", &iaf_psc_alpha_multisynapse_neuron::get_V_m);

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the y1_I_shape with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the y2_I_shape with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the RefractoryCounts with the domain type long

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the r with the domain type long

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the __h__ with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P30 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the y1_I_shapePSCInitialValue with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_00 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_01 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_02 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_10 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_11 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_12 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_20 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_21 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the P_I_shape_22 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the __P01 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the __P11 with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the receptors with the domain type long

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the C_m with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the tau_m with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the tau_syn with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the t_ref with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the E_L with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the V_reset with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the V_th with the domain type double

  /* generated by template org.nest.nestml.neuron.function.RecordCallback*/

  // ignores the I_e with the domain type double
}
}

/* ----------------------------------------------------------------
* Default constructors defining default parameters and state
* ---------------------------------------------------------------- */
iaf_psc_alpha_multisynapse_neuron::Parameters_::Parameters_() {
  receptors = 0;
  C_m = 0;
  tau_m = 0;
  tau_syn.resize(0);
  t_ref = 0;
  E_L = 0;
  I_e = 0;
}

iaf_psc_alpha_multisynapse_neuron::State_::State_() {
  V_abs = 0;
  y1_I_shape.resize(0);
  y2_I_shape.resize(0);
}

/* ----------------------------------------------------------------
* Parameter and state extractions and manipulation functions
* ---------------------------------------------------------------- */

iaf_psc_alpha_multisynapse_neuron::Buffers_::Buffers_(
    iaf_psc_alpha_multisynapse_neuron &n)
    : logger_(n) {}

iaf_psc_alpha_multisynapse_neuron::Buffers_::Buffers_(
    const Buffers_ &, iaf_psc_alpha_multisynapse_neuron &n)
    : logger_(n)

{}

/* ----------------------------------------------------------------
* Default and copy constructor for node
* ---------------------------------------------------------------- */
// TODO inner components
iaf_psc_alpha_multisynapse_neuron::iaf_psc_alpha_multisynapse_neuron()
    : Archiving_Node(), P_(), S_(), B_(*this) {
  recordablesMap_.create();

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.receptors = 100;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.C_m = 250;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.tau_m = 10;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.tau_syn.resize(P_.receptors, 2);

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.t_ref = 2;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.E_L = ((-70));

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  P_.I_e = 0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.V_abs = 0;

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y1_I_shape.resize(0);

  /* generated by template
   * org.nest.nestml.neuron.function.MemberInitialization*/

  S_.y2_I_shape.resize(0);
}

iaf_psc_alpha_multisynapse_neuron::iaf_psc_alpha_multisynapse_neuron(
    const iaf_psc_alpha_multisynapse_neuron &n)
    : Archiving_Node(), P_(n.P_), S_(n.S_), B_(n.B_, *this) {}

/* ----------------------------------------------------------------
* Destructors
* ---------------------------------------------------------------- */

iaf_psc_alpha_multisynapse_neuron::~iaf_psc_alpha_multisynapse_neuron() {}

/* ----------------------------------------------------------------
* Node initialization functions
* ---------------------------------------------------------------- */

void iaf_psc_alpha_multisynapse_neuron::init_state_(
    const Node &proto) { // TODO inner components

  const iaf_psc_alpha_multisynapse_neuron &pr =
      downcast<iaf_psc_alpha_multisynapse_neuron>(proto);
  S_ = pr.S_;
}

void iaf_psc_alpha_multisynapse_neuron::init_buffers_() {
  get_spikes().clear();   // includes resize
  get_currents().clear(); // includes resize
  B_.logger_.reset();     // includes resize
  Archiving_Node::clear_history();
}

void iaf_psc_alpha_multisynapse_neuron::calibrate() {
  B_.logger_.init();

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.RefractoryCounts =
      nest::Time(nest::Time::ms((double)P_.t_ref)).get_steps();

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.r = 0;

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.__h__ = nest::Time::get_resolution().get_ms();

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P30 = P_.tau_m / P_.C_m -
           P_.tau_m * std::exp(((-V_.__h__)) / P_.tau_m) / P_.C_m;

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.y1_I_shapePSCInitialValue.resize(P_.receptors);
  for (long i = 0; i < get_receptors(); i++) {
    V_.y1_I_shapePSCInitialValue[i] = numerics::e / P_.tau_syn[i];
  }

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_00.resize(P_.receptors);
  for (long i = 0; i < get_receptors(); i++) {
    V_.P_I_shape_00[i] = std::exp(((-V_.__h__)) / P_.tau_syn[i]);
  }

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_01 = 0;

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_02 = 0;

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_10.resize(P_.receptors);
  for (long i = 0; i < get_receptors(); i++) {
    V_.P_I_shape_10[i] = V_.__h__ * std::exp(((-V_.__h__)) / P_.tau_syn[i]);
  }

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_11.resize(P_.receptors);
  for (long i = 0; i < get_receptors(); i++) {
    V_.P_I_shape_11[i] = std::exp(((-V_.__h__)) / P_.tau_syn[i]);
  }

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_12 = 0;

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_20.resize(P_.receptors);
  for (long i = 0; i < get_receptors(); i++) {
    V_.P_I_shape_20[i] =
        ((-P_.tau_m)) * P_.tau_syn[i] *
        (V_.__h__ * P_.tau_m * std::exp(V_.__h__ / P_.tau_m) -
         V_.__h__ * P_.tau_syn[i] * std::exp(V_.__h__ / P_.tau_m) +
         P_.tau_m * P_.tau_syn[i] * std::exp(V_.__h__ / P_.tau_m) -
         P_.tau_m * P_.tau_syn[i] * std::exp(V_.__h__ / P_.tau_syn[i])) *
        std::exp(((-V_.__h__)) / P_.tau_syn[i] - V_.__h__ / P_.tau_m) /
        (P_.C_m * (pow((P_.tau_m), (2)) - 2 * P_.tau_m * P_.tau_syn[i] +
                   pow((P_.tau_syn[i]), (2))));
  }

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_21.resize(P_.receptors);
  for (long i = 0; i < get_receptors(); i++) {
    V_.P_I_shape_21[i] =
        ((-P_.tau_m)) * P_.tau_syn[i] *
        (std::exp(V_.__h__ / P_.tau_m) - std::exp(V_.__h__ / P_.tau_syn[i])) *
        std::exp(((-V_.__h__)) / P_.tau_syn[i] - V_.__h__ / P_.tau_m) /
        (P_.C_m * (P_.tau_m - P_.tau_syn[i]));
  }

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.P_I_shape_22 = std::exp(((-V_.__h__)) / P_.tau_m);

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.__P01.resize(P_.receptors);
  for (long i = 0; i < get_receptors(); i++) {
    V_.__P01[i] = std::exp((((-V_.__h__))) / P_.tau_syn[i]);
  }

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  V_.__P11.resize(P_.receptors);
  for (long i = 0; i < get_receptors(); i++) {
    V_.__P11[i] = std::exp((((-V_.__h__))) / P_.tau_syn[i]);
  }

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  S_.y1_I_shape.resize(P_.receptors);
  for (long i = 0; i < get_receptors(); i++) {
    S_.y1_I_shape[i] = 0;
  }

  /* generated by template org.nest.nestml.neuron.function.Calibrate*/

  S_.y2_I_shape.resize(P_.receptors);
  for (long i = 0; i < get_receptors(); i++) {
    S_.y2_I_shape[i] = 0;
  }

  B_.spikes.resize(P_.receptors);
  B_.spikes_last_value_.resize(P_.receptors);
}

/* ----------------------------------------------------------------
* Update and spike handling functions
* ---------------------------------------------------------------- */

/*

 */
void iaf_psc_alpha_multisynapse_neuron::update(nest::Time const &origin,
                                               const long from, const long to) {

  for (long lag = from; lag < to; ++lag) {
    for (long i = 0; i < P_.receptors; i++) {
      B_.spikes_last_value_[i] = get_spikes()[i].get_value(lag);
    }
    // TODO this case must be handled uniformly, also NESTReferenceConverter
    // must be adopted
    B_.currents_last_value_ = get_currents().get_value(lag);

    /* generated by template org.nest.spl.Block*/
    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.CompoundStatement*/
    /* generated by template org.nest.spl.compound_statement.IfStatement*/

    if (V_.r == 0) {
      /* generated by template org.nest.spl.Block*/
      /* generated by template org.nest.spl.Statement*/
      //
      /* generated by template org.nest.spl.SmallStatement*/
      /* generated by template org.nest.spl.small_statement.Assignment*/
      S_.V_abs = V_.P30 * (P_.I_e + B_.currents_last_value_) +
                 S_.V_abs * std::exp(((-V_.__h__)) / P_.tau_m);

      /* generated by template org.nest.spl.Statement*/
      //
      /* generated by template org.nest.spl.SmallStatement*/
      /* generated by template org.nest.spl.small_statement.Assignment*/
      for (long i = 0; i < P_.receptors; i++) {
        S_.V_abs += V_.P_I_shape_20[i] * S_.y1_I_shape[i] +
                    V_.P_I_shape_21[i] * S_.y2_I_shape[i];
      }

    } else {
      /* generated by template org.nest.spl.Block*/
      /* generated by template org.nest.spl.Statement*/
      //
      /* generated by template org.nest.spl.SmallStatement*/
      /* generated by template org.nest.spl.small_statement.Assignment*/
      V_.r = V_.r - 1;

    } /* if end */

    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.CompoundStatement*/
    /* generated by template org.nest.spl.compound_statement.IfStatement*/

    if (S_.V_abs >= get_V_th()) {
      /* generated by template org.nest.spl.Block*/
      /* generated by template org.nest.spl.Statement*/
      //
      /* generated by template org.nest.spl.SmallStatement*/
      /* generated by template org.nest.spl.small_statement.Assignment*/
      V_.r = V_.RefractoryCounts;

      /* generated by template org.nest.spl.Statement*/
      //
      /* generated by template org.nest.spl.SmallStatement*/
      /* generated by template org.nest.spl.small_statement.Assignment*/
      S_.V_abs = get_V_reset();

      /* generated by template org.nest.spl.Statement*/
      // # A supra-threshold membrane potential should never be observable.# The
      // reset at the time of threshold crossing enables accurate# integration
      // independent of the computation step size, see [2,3] for# details.
      /* generated by template org.nest.spl.SmallStatement*/
      /* generated by template org.nest.spl.small_statement.FunctionCall*/
      set_spiketime(nest::Time::step(origin.get_steps() + lag + 1));
      nest::SpikeEvent se;
      nest::kernel().event_delivery_manager.send(*this, se, lag);
      ;

    } /* if end */

    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.SmallStatement*/
    /* generated by template org.nest.spl.small_statement.Assignment*/
    for (long i = 0; i < P_.receptors; i++) {
      S_.y2_I_shape[i] =
          (V_.__h__ * S_.y1_I_shape[i] + S_.y2_I_shape[i]) * V_.__P01[i];
    }

    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.SmallStatement*/
    /* generated by template org.nest.spl.small_statement.Assignment*/
    for (long i = 0; i < P_.receptors; i++) {
      S_.y1_I_shape[i] = S_.y1_I_shape[i] * V_.__P11[i];
    }

    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.SmallStatement*/
    /* generated by template org.nest.spl.small_statement.Assignment*/
    for (long i = 0; i < P_.receptors; i++) {
      S_.y1_I_shape[i] +=
          V_.y1_I_shapePSCInitialValue[i] * B_.spikes_last_value_[i];
    }

    // voltage logging
    B_.logger_.record_data(origin.get_steps() + lag);
  }
}

// Do not move this function as inline to h-file. It depends on
// universal_data_logger_impl.h being included here.
void iaf_psc_alpha_multisynapse_neuron::handle(nest::DataLoggingRequest &e) {
  B_.logger_.handle(e);
}

void iaf_psc_alpha_multisynapse_neuron::handle(nest::SpikeEvent &e) {
  assert(e.get_delay() > 0);

  B_.spikes[e.get_rport() - 1].add_value(
      e.get_rel_delivery_steps(
          nest::kernel().simulation_manager.get_slice_origin()),
      e.get_weight() * e.get_multiplicity());
}

void iaf_psc_alpha_multisynapse_neuron::handle(nest::CurrentEvent &e) {
  assert(e.get_delay() > 0);

  const double current = e.get_current();
  const double weight = e.get_weight();

  // add weighted current; HEP 2002-10-04
  get_currents().add_value(
      e.get_rel_delivery_steps(
          nest::kernel().simulation_manager.get_slice_origin()),
      weight * current);
}
