/* generated by template org.nest.nestml.neuron.NeuronHeader*/
/*
*  iaf_psc_alpha_neuron.h
*
*  This file is part of NEST.
*
*  Copyright (C) 2004 The NEST Initiative
*
*  NEST is free software: you can redistribute it and/or modify
*  it under the terms of the GNU General Public License as published by
*  the Free Software Foundation, either version 2 of the License, or
*  (at your option) any later version.
*
*  NEST is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU General Public License for more details.
*
*  You should have received a copy of the GNU General Public License
*  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
*
*/
#ifndef IAF_PSC_ALPHA_NEURON
#define IAF_PSC_ALPHA_NEURON
#include "config.h"

// Includes from nestkernel:
#include "archiving_node.h"
#include "connection.h"
#include "event.h"
#include "nest_types.h"
#include "ring_buffer.h"
#include "universal_data_logger.h"

// Includes from sli:
#include "dictdatum.h"

/* BeginDocumentation
Name: iaf_psc_alpha_neuron.

//
Name: iaf_psc_alpha - Leaky integrate-and-fire neuron model.

Description:

  iaf_psc_alpha is an implementation of a leaky integrate-and-fire model
  with alpha-function shaped synaptic currents. Thus, synaptic currents
  and the resulting post-synaptic potentials have a finite rise time.

  The threshold crossing is followed by an absolute refractory period
  during which the membrane potential is clamped to the resting potential.

  The linear subthresold dynamics is integrated by the Exact
  Integration scheme [1]. The neuron dynamics is solved on the time
  grid given by the computation step size. Incoming as well as emitted
  spikes are forced to that grid.

  An additional state variable and the corresponding differential
  equation represents a piecewise constant external current.

  The general framework for the consistent formulation of systems with
  neuron like dynamics interacting by point events is described in
  [1].  A flow chart can be found in [2].

  Critical tests for the formulation of the neuron model are the
  comparisons of simulation results for different computation step
  sizes. sli/testsuite/nest contains a number of such tests.

  The iaf_psc_alpha is the standard model used to check the consistency
  of the nest simulation kernel because it is at the same time complex
  enough to exhibit non-trivial dynamics and simple enough compute
  relevant measures analytically.

Remarks:

  The present implementation uses individual variables for the
  components of the state vector and the non-zero matrix elements of
  the propagator.  Because the propagator is a lower triangular matrix
  no full matrix multiplication needs to be carried out and the
  computation can be done "in place" i.e. no temporary state vector
  object is required.

  The template support of recent C++ compilers enables a more succinct
  formulation without loss of runtime performance already at minimal
  optimization levels. A future version of iaf_psc_alpha will probably
  address the problem of efficient usage of appropriate vector and
  matrix objects.

Remarks:

  If tau_m is very close to tau_syn_ex or tau_syn_in, the model
  will numerically behave as if tau_m is equal to tau_syn_ex or
  tau_syn_in, respectively, to avoid numerical instabilities.
  For details, please see IAF_Neruons_Singularity.ipynb in
  the NEST source code (docs/model_details).

References:
  [1] Rotter S & Diesmann M (1999) Exact simulation of time-invariant linear
      systems with applications to neuronal modeling. Biologial Cybernetics
      81:381-402.
  [2] Diesmann M, Gewaltig M-O, Rotter S, & Aertsen A (2001) State space
      analysis of synchronous spiking in cortical neural networks.
      Neurocomputing 38-40:565-571.
  [3] Morrison A, Straube S, Plesser H E, & Diesmann M (2006) Exact subthreshold
      integration with continuous spike times in discrete time neural network
      simulations. Neural Computation, in press

Sends: SpikeEvent

Receives: SpikeEvent, CurrentEvent, DataLoggingRequest
FirstVersion: September 1999
Author:  Diesmann, Gewaltig
SeeAlso: iaf_psc_delta, iaf_psc_exp, iaf_cond_exp
//

Parameters:

Remarks:
Empty

References:
Empty

Sends: nest::SpikeEvent

Receives: Spike, Current,  DataLoggingRequest

SeeAlso:

Empty
*/
class iaf_psc_alpha_neuron : public nest::Archiving_Node {
public:
  /**
  * The constructor is only used to create the model prototype in the model
  * manager.
  */
  iaf_psc_alpha_neuron();

  /**
  * The copy constructor is used to create model copies and instances of the
  * model.
  * @node The copy constructor needs to initialize the parameters and the state.
  *       Initialization of buffers and interal variables is deferred to
  *       @c init_buffers_() and @c calibrate().
  */
  iaf_psc_alpha_neuron(const iaf_psc_alpha_neuron &);

  /**
  * Releases resources.
  */
  ~iaf_psc_alpha_neuron();
  /**
  * Import sets of overloaded virtual functions.
  * This is necessary to ensure proper overload and overriding resolution.
  * @see http://www.gotw.ca/gotw/005.htm.
  */
  using nest::Node::handles_test_event;
  using nest::Node::handle;

  /**
  * Used to validate that we can send nest::SpikeEvent to desired target:port.
  */
  nest::port send_test_event(nest::Node &target, nest::rport receptor_type,
                             nest::synindex, bool);

  /**
  * @defgroup mynest_handle Functions handling incoming events.
  * We tell nest that we can handle incoming events of various types by
  * defining @c handle() and @c connect_sender() for the given event.
  * @{
  */
  void handle(nest::SpikeEvent &);         //! accept spikes
  void handle(nest::CurrentEvent &);       //! accept input current
  void handle(nest::DataLoggingRequest &); //! allow recording with multimeter

  nest::port handles_test_event(nest::SpikeEvent &, nest::port);
  nest::port handles_test_event(nest::CurrentEvent &, nest::port);
  nest::port handles_test_event(nest::DataLoggingRequest &, nest::port);
  /** @} */

  // SLI communication functions:
  void get_status(DictionaryDatum &) const;
  void set_status(const DictionaryDatum &);

private:
  //! Reset parameters and state of neuron.

  //! Reset state of neuron.
  void init_state_(const Node &proto);

  //! Reset internal buffers of neuron.
  void init_buffers_();

  //! Initialize auxiliary quantities, leave parameters and state untouched.
  void calibrate();

  //! Take neuron through given time interval
  void update(nest::Time const &, const long, const long);

  // The next two classes need to be friends to access the State_ class/member
  friend class nest::RecordablesMap<iaf_psc_alpha_neuron>;
  friend class nest::UniversalDataLogger<iaf_psc_alpha_neuron>;

  /**
  * Free parameters of the neuron.
  *
  *
  *
  * These are the parameters that can be set by the user through @c SetStatus.
  * They are initialized from the model prototype when the node is created.
  * Parameters do not change during calls to @c update() and are not reset by
  * @c ResetNetwork.
  *
  * @note Parameters_ need neither copy constructor nor @c operator=(), since
  *       all its members are copied properly by the default copy constructor
  *       and assignment operator. Important:
  *       - If Parameters_ contained @c Time members, you need to define the
  *         assignment operator to recalibrate all members of type @c Time . You
  *         may also want to define the assignment operator.
  *       - If Parameters_ contained members that cannot copy themselves, such
  *         as C-style arrays, you need to define the copy constructor and
  *         assignment operator to copy those members.
  */
  struct Parameters_ {
    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double C_m; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double Tau; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double tau_syn_in; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double tau_syn_ex; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double t_ref; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double E_L; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double I_e; //

    /** Initialize parameters to their default values. */
    Parameters_();
  };

  /**
  * Dynamic state of the neuron.
  *
  *
  *
  * These are the state variables that are advanced in time by calls to
  * @c update(). In many models, some or all of them can be set by the user
  * through @c SetStatus. The state variables are initialized from the model
  * prototype when the node is created. State variables are reset by @c
  * ResetNetwork.
  *
  * @note State_ need neither copy constructor nor @c operator=(), since
  *       all its members are copied properly by the default copy constructor
  *       and assignment operator. Important:
  *       - If State_ contained @c Time members, you need to define the
  *         assignment operator to recalibrate all members of type @c Time . You
  *         may also want to define the assignment operator.
  *       - If State_ contained members that cannot copy themselves, such
  *         as C-style arrays, you need to define the copy constructor and
  *         assignment operator to copy those members.
  */
  struct State_ {
    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double V_abs; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double y1_I_shape_in; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double y2_I_shape_in; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double y1_I_shape_ex; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double y2_I_shape_ex; //

    State_();
  };

  /**
  * Internal variables of the neuron.
  *
  *
  *
  * These variables must be initialized by @c calibrate, which is called before
  * the first call to @c update() upon each call to @c Simulate.
  * @node Variables_ needs neither constructor, copy constructor or assignment
  * operator,
  *       since it is initialized by @c calibrate(). If Variables_ has members
  * that
  *       cannot destroy themselves, Variables_ will need a destructor.
  */
  struct Variables_ {
    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    long RefractoryCounts; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    long r; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double __h__; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double P30; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double y1_I_shape_inPSCInitialValue; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double y1_I_shape_exPSCInitialValue; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double P_I_shape_in_00; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double P_I_shape_in_01; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double P_I_shape_in_02; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double P_I_shape_in_10; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double P_I_shape_in_11; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double P_I_shape_in_12; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double P_I_shape_in_20; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double P_I_shape_in_21; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double P_I_shape_in_22; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double P_I_shape_ex_00; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double P_I_shape_ex_01; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double P_I_shape_ex_02; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double P_I_shape_ex_10; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double P_I_shape_ex_11; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double P_I_shape_ex_12; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double P_I_shape_ex_20; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double P_I_shape_ex_21; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double P_I_shape_ex_22; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double __P01; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double __P11; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double __P21; //

    /* generated by template org.nest.nestml.neuron.function.MemberDeclaration*/

    double __P31; //
  };

  /**
    * Buffers of the neuron.
    * Ususally buffers for incoming spikes and data logged for analog recorders.
    * Buffers must be initialized by @c init_buffers_(), which is called before
    * @c calibrate() on the first call to @c Simulate after the start of NEST,
    * ResetKernel or ResetNetwork.
    * @node Buffers_ needs neither constructor, copy constructor or assignment
   * operator,
    *       since it is initialized by @c init_nodes_(). If Buffers_ has members
   * that
    *       cannot destroy themselves, Buffers_ will need a destructor.
    */
  struct Buffers_ {
    Buffers_(iaf_psc_alpha_neuron &);
    Buffers_(const Buffers_ &, iaf_psc_alpha_neuron &);

    /** Logger for all analog data */
    nest::UniversalDataLogger<iaf_psc_alpha_neuron> logger_;

    inline nest::RingBuffer &get_ex_spikes() { return ex_spikes; }
    nest::RingBuffer ex_spikes;
    //!< Buffer incoming Buffers through delay, as sum
    ;
    double ex_spikes_last_value_;
    inline nest::RingBuffer &get_in_spikes() { return in_spikes; }
    nest::RingBuffer in_spikes;
    //!< Buffer incoming Buffers through delay, as sum
    ;
    double in_spikes_last_value_;

    nest::RingBuffer currents;
    //!< Buffer incoming Buffers through delay, as sum
    ;
    inline nest::RingBuffer &get_currents() { return currents; }
    double currents_last_value_;
  };

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_V_abs() const { return S_.V_abs; }

  inline void set_V_abs(const double __v) { S_.V_abs = __v; }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_V_m() const { return S_.V_abs + P_.E_L; }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_y1_I_shape_in() const { return S_.y1_I_shape_in; }

  inline void set_y1_I_shape_in(const double __v) { S_.y1_I_shape_in = __v; }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_y2_I_shape_in() const { return S_.y2_I_shape_in; }

  inline void set_y2_I_shape_in(const double __v) { S_.y2_I_shape_in = __v; }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_y1_I_shape_ex() const { return S_.y1_I_shape_ex; }

  inline void set_y1_I_shape_ex(const double __v) { S_.y1_I_shape_ex = __v; }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_y2_I_shape_ex() const { return S_.y2_I_shape_ex; }

  inline void set_y2_I_shape_ex(const double __v) { S_.y2_I_shape_ex = __v; }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_C_m() const { return P_.C_m; }

  inline void set_C_m(const double __v) { P_.C_m = __v; }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_Tau() const { return P_.Tau; }

  inline void set_Tau(const double __v) { P_.Tau = __v; }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_tau_syn_in() const { return P_.tau_syn_in; }

  inline void set_tau_syn_in(const double __v) { P_.tau_syn_in = __v; }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_tau_syn_ex() const { return P_.tau_syn_ex; }

  inline void set_tau_syn_ex(const double __v) { P_.tau_syn_ex = __v; }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_t_ref() const { return P_.t_ref; }

  inline void set_t_ref(const double __v) { P_.t_ref = __v; }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_E_L() const { return P_.E_L; }

  inline void set_E_L(const double __v) { P_.E_L = __v; }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_V_reset() const { return ((-70)) - P_.E_L; }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_Theta() const { return ((-55)) - P_.E_L; }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_I_e() const { return P_.I_e; }

  inline void set_I_e(const double __v) { P_.I_e = __v; }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline long get_RefractoryCounts() const { return V_.RefractoryCounts; }

  inline void set_RefractoryCounts(const long __v) {
    V_.RefractoryCounts = __v;
  }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline long get_r() const { return V_.r; }

  inline void set_r(const long __v) { V_.r = __v; }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get___h__() const { return V_.__h__; }

  inline void set___h__(const double __v) { V_.__h__ = __v; }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_P30() const { return V_.P30; }

  inline void set_P30(const double __v) { V_.P30 = __v; }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_y1_I_shape_inPSCInitialValue() const {
    return V_.y1_I_shape_inPSCInitialValue;
  }

  inline void set_y1_I_shape_inPSCInitialValue(const double __v) {
    V_.y1_I_shape_inPSCInitialValue = __v;
  }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_y1_I_shape_exPSCInitialValue() const {
    return V_.y1_I_shape_exPSCInitialValue;
  }

  inline void set_y1_I_shape_exPSCInitialValue(const double __v) {
    V_.y1_I_shape_exPSCInitialValue = __v;
  }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_P_I_shape_in_00() const { return V_.P_I_shape_in_00; }

  inline void set_P_I_shape_in_00(const double __v) {
    V_.P_I_shape_in_00 = __v;
  }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_P_I_shape_in_01() const { return V_.P_I_shape_in_01; }

  inline void set_P_I_shape_in_01(const double __v) {
    V_.P_I_shape_in_01 = __v;
  }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_P_I_shape_in_02() const { return V_.P_I_shape_in_02; }

  inline void set_P_I_shape_in_02(const double __v) {
    V_.P_I_shape_in_02 = __v;
  }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_P_I_shape_in_10() const { return V_.P_I_shape_in_10; }

  inline void set_P_I_shape_in_10(const double __v) {
    V_.P_I_shape_in_10 = __v;
  }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_P_I_shape_in_11() const { return V_.P_I_shape_in_11; }

  inline void set_P_I_shape_in_11(const double __v) {
    V_.P_I_shape_in_11 = __v;
  }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_P_I_shape_in_12() const { return V_.P_I_shape_in_12; }

  inline void set_P_I_shape_in_12(const double __v) {
    V_.P_I_shape_in_12 = __v;
  }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_P_I_shape_in_20() const { return V_.P_I_shape_in_20; }

  inline void set_P_I_shape_in_20(const double __v) {
    V_.P_I_shape_in_20 = __v;
  }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_P_I_shape_in_21() const { return V_.P_I_shape_in_21; }

  inline void set_P_I_shape_in_21(const double __v) {
    V_.P_I_shape_in_21 = __v;
  }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_P_I_shape_in_22() const { return V_.P_I_shape_in_22; }

  inline void set_P_I_shape_in_22(const double __v) {
    V_.P_I_shape_in_22 = __v;
  }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_P_I_shape_ex_00() const { return V_.P_I_shape_ex_00; }

  inline void set_P_I_shape_ex_00(const double __v) {
    V_.P_I_shape_ex_00 = __v;
  }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_P_I_shape_ex_01() const { return V_.P_I_shape_ex_01; }

  inline void set_P_I_shape_ex_01(const double __v) {
    V_.P_I_shape_ex_01 = __v;
  }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_P_I_shape_ex_02() const { return V_.P_I_shape_ex_02; }

  inline void set_P_I_shape_ex_02(const double __v) {
    V_.P_I_shape_ex_02 = __v;
  }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_P_I_shape_ex_10() const { return V_.P_I_shape_ex_10; }

  inline void set_P_I_shape_ex_10(const double __v) {
    V_.P_I_shape_ex_10 = __v;
  }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_P_I_shape_ex_11() const { return V_.P_I_shape_ex_11; }

  inline void set_P_I_shape_ex_11(const double __v) {
    V_.P_I_shape_ex_11 = __v;
  }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_P_I_shape_ex_12() const { return V_.P_I_shape_ex_12; }

  inline void set_P_I_shape_ex_12(const double __v) {
    V_.P_I_shape_ex_12 = __v;
  }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_P_I_shape_ex_20() const { return V_.P_I_shape_ex_20; }

  inline void set_P_I_shape_ex_20(const double __v) {
    V_.P_I_shape_ex_20 = __v;
  }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_P_I_shape_ex_21() const { return V_.P_I_shape_ex_21; }

  inline void set_P_I_shape_ex_21(const double __v) {
    V_.P_I_shape_ex_21 = __v;
  }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get_P_I_shape_ex_22() const { return V_.P_I_shape_ex_22; }

  inline void set_P_I_shape_ex_22(const double __v) {
    V_.P_I_shape_ex_22 = __v;
  }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get___P01() const { return V_.__P01; }

  inline void set___P01(const double __v) { V_.__P01 = __v; }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get___P11() const { return V_.__P11; }

  inline void set___P11(const double __v) { V_.__P11 = __v; }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get___P21() const { return V_.__P21; }

  inline void set___P21(const double __v) { V_.__P21 = __v; }

  /* generated by template
   * org.nest.nestml.neuron.function.MemberVariableGetterSetter*/

  inline double get___P31() const { return V_.__P31; }

  inline void set___P31(const double __v) { V_.__P31 = __v; }

  inline nest::RingBuffer &get_ex_spikes() { return B_.get_ex_spikes(); };
  inline nest::RingBuffer &get_in_spikes() { return B_.get_in_spikes(); };
  inline nest::RingBuffer &get_currents() { return B_.get_currents(); };

  // Generate function header
  /**
  * @defgroup pif_members Member variables of neuron model.
  * Each model neuron should have precisely the following four data members,
  * which are one instance each of the parameters, state, buffers and variables
  * structures. Experience indicates that the state and variables member should
  * be next to each other to achieve good efficiency (caching).
  * @note Devices require one additional data member, an instance of the @c
  * Device
  *       child class they belong to.
  * @{
  */
  Parameters_ P_; //!< Free parameters.
  State_ S_;      //!< Dynamic state.
  Variables_ V_;  //!< Internal Variables
  Buffers_ B_;    //!< Buffers.

  //! Mapping of recordables names to access functions
  static nest::RecordablesMap<iaf_psc_alpha_neuron> recordablesMap_;

  /** @} */
}; /* neuron iaf_psc_alpha_neuron */

inline nest::port iaf_psc_alpha_neuron::send_test_event(
    nest::Node &target, nest::rport receptor_type, nest::synindex, bool) {
  // You should usually not change the code in this function.
  // It confirms that the target of connection @c c accepts @c nest::SpikeEvent
  // on
  // the given @c receptor_type.
  nest::SpikeEvent e;
  e.set_sender(*this);

  return target.handles_test_event(e, receptor_type);
}

inline nest::port
iaf_psc_alpha_neuron::handles_test_event(nest::SpikeEvent &,
                                         nest::port receptor_type) {
  // You should usually not change the code in this function.
  // It confirms to the connection management system that we are able
  // to handle @c SpikeEvent on port 0. You need to extend the function
  // if you want to differentiate between input ports.
  if (receptor_type != 0)
    throw nest::UnknownReceptorType(receptor_type, get_name());
  return 0;
}

inline nest::port
iaf_psc_alpha_neuron::handles_test_event(nest::CurrentEvent &,
                                         nest::port receptor_type) {
  // You should usually not change the code in this function.
  // It confirms to the connection management system that we are able
  // to handle @c CurrentEvent on port 0. You need to extend the function
  // if you want to differentiate between input ports.
  if (receptor_type != 0)
    throw nest::UnknownReceptorType(receptor_type, get_name());
  return 0;
}
inline nest::port
iaf_psc_alpha_neuron::handles_test_event(nest::DataLoggingRequest &dlr,
                                         nest::port receptor_type) {
  // You should usually not change the code in this function.
  // It confirms to the connection management system that we are able
  // to handle @c DataLoggingRequest on port 0.
  // The function also tells the built-in UniversalDataLogger that this node
  // is recorded from and that it thus needs to collect data during simulation.
  if (receptor_type != 0)
    throw nest::UnknownReceptorType(receptor_type, get_name());

  return B_.logger_.connect_logging_device(dlr, recordablesMap_);
}

// TODO call get_status on used or internal components
inline void iaf_psc_alpha_neuron::get_status(DictionaryDatum &__d) const {
  /* generated by template org.nest.nestml.neuron.function.WriteInDictionary*/

  def<double>(__d, "C_m", get_C_m());

  /* generated by template org.nest.nestml.neuron.function.WriteInDictionary*/

  def<double>(__d, "Tau", get_Tau());

  /* generated by template org.nest.nestml.neuron.function.WriteInDictionary*/

  def<double>(__d, "tau_syn_in", get_tau_syn_in());

  /* generated by template org.nest.nestml.neuron.function.WriteInDictionary*/

  def<double>(__d, "tau_syn_ex", get_tau_syn_ex());

  /* generated by template org.nest.nestml.neuron.function.WriteInDictionary*/

  def<double>(__d, "t_ref", get_t_ref());

  /* generated by template org.nest.nestml.neuron.function.WriteInDictionary*/

  def<double>(__d, "E_L", get_E_L());

  /* generated by template org.nest.nestml.neuron.function.WriteInDictionary*/

  def<double>(__d, "V_reset", get_V_reset());

  /* generated by template org.nest.nestml.neuron.function.WriteInDictionary*/

  def<double>(__d, "Theta", get_Theta());

  /* generated by template org.nest.nestml.neuron.function.WriteInDictionary*/

  def<double>(__d, "I_e", get_I_e());

  /* generated by template org.nest.nestml.neuron.function.WriteInDictionary*/

  def<double>(__d, "V_abs", get_V_abs());

  /* generated by template org.nest.nestml.neuron.function.WriteInDictionary*/

  def<double>(__d, "V_m", get_V_m());

  /* generated by template org.nest.nestml.neuron.function.WriteInDictionary*/

  def<double>(__d, "y1_I_shape_in", get_y1_I_shape_in());

  /* generated by template org.nest.nestml.neuron.function.WriteInDictionary*/

  def<double>(__d, "y2_I_shape_in", get_y2_I_shape_in());

  /* generated by template org.nest.nestml.neuron.function.WriteInDictionary*/

  def<double>(__d, "y1_I_shape_ex", get_y1_I_shape_ex());

  /* generated by template org.nest.nestml.neuron.function.WriteInDictionary*/

  def<double>(__d, "y2_I_shape_ex", get_y2_I_shape_ex());

  (*__d)[nest::names::recordables] = recordablesMap_.get_list();
}

inline void iaf_psc_alpha_neuron::set_status(const DictionaryDatum &__d) {
  /* generated by template
   * org.nest.nestml.neuron.function.ReadFromDictionaryToTmp*/

  double tmp_C_m = get_C_m();
  updateValue<double>(__d, "C_m", tmp_C_m);

  /* generated by template
   * org.nest.nestml.neuron.function.ReadFromDictionaryToTmp*/

  double tmp_Tau = get_Tau();
  updateValue<double>(__d, "Tau", tmp_Tau);

  /* generated by template
   * org.nest.nestml.neuron.function.ReadFromDictionaryToTmp*/

  double tmp_tau_syn_in = get_tau_syn_in();
  updateValue<double>(__d, "tau_syn_in", tmp_tau_syn_in);

  /* generated by template
   * org.nest.nestml.neuron.function.ReadFromDictionaryToTmp*/

  double tmp_tau_syn_ex = get_tau_syn_ex();
  updateValue<double>(__d, "tau_syn_ex", tmp_tau_syn_ex);

  /* generated by template
   * org.nest.nestml.neuron.function.ReadFromDictionaryToTmp*/

  double tmp_t_ref = get_t_ref();
  updateValue<double>(__d, "t_ref", tmp_t_ref);

  /* generated by template
   * org.nest.nestml.neuron.function.ReadFromDictionaryToTmp*/

  double tmp_E_L = get_E_L();
  updateValue<double>(__d, "E_L", tmp_E_L);

  /* generated by template
   * org.nest.nestml.neuron.function.ReadFromDictionaryToTmp*/

  // ignores 'V_reset' double' since it is an function and setter isn't defined

  /* generated by template
   * org.nest.nestml.neuron.function.ReadFromDictionaryToTmp*/

  // ignores 'Theta' double' since it is an function and setter isn't defined

  /* generated by template
   * org.nest.nestml.neuron.function.ReadFromDictionaryToTmp*/

  double tmp_I_e = get_I_e();
  updateValue<double>(__d, "I_e", tmp_I_e);

  /* generated by template
   * org.nest.nestml.neuron.function.ReadFromDictionaryToTmp*/

  double tmp_V_abs = get_V_abs();
  updateValue<double>(__d, "V_abs", tmp_V_abs);

  /* generated by template
   * org.nest.nestml.neuron.function.ReadFromDictionaryToTmp*/

  // ignores 'V_m' double' since it is an function and setter isn't defined

  /* generated by template
   * org.nest.nestml.neuron.function.ReadFromDictionaryToTmp*/

  double tmp_y1_I_shape_in = get_y1_I_shape_in();
  updateValue<double>(__d, "y1_I_shape_in", tmp_y1_I_shape_in);

  /* generated by template
   * org.nest.nestml.neuron.function.ReadFromDictionaryToTmp*/

  double tmp_y2_I_shape_in = get_y2_I_shape_in();
  updateValue<double>(__d, "y2_I_shape_in", tmp_y2_I_shape_in);

  /* generated by template
   * org.nest.nestml.neuron.function.ReadFromDictionaryToTmp*/

  double tmp_y1_I_shape_ex = get_y1_I_shape_ex();
  updateValue<double>(__d, "y1_I_shape_ex", tmp_y1_I_shape_ex);

  /* generated by template
   * org.nest.nestml.neuron.function.ReadFromDictionaryToTmp*/

  double tmp_y2_I_shape_ex = get_y2_I_shape_ex();
  updateValue<double>(__d, "y2_I_shape_ex", tmp_y2_I_shape_ex);

  // We now know that (ptmp, stmp) are consistent. We do not
  // write them back to (P_, S_) before we are also sure that
  // the properties to be set in the parent class are internally
  // consistent.
  Archiving_Node::set_status(__d);

  // if we get here, temporaries contain consistent set of properties
  /* generated by template
   * org.nest.nestml.neuron.function.AssignTmpDictionaryValue*/

  set_C_m(tmp_C_m);

  /* generated by template
   * org.nest.nestml.neuron.function.AssignTmpDictionaryValue*/

  set_Tau(tmp_Tau);

  /* generated by template
   * org.nest.nestml.neuron.function.AssignTmpDictionaryValue*/

  set_tau_syn_in(tmp_tau_syn_in);

  /* generated by template
   * org.nest.nestml.neuron.function.AssignTmpDictionaryValue*/

  set_tau_syn_ex(tmp_tau_syn_ex);

  /* generated by template
   * org.nest.nestml.neuron.function.AssignTmpDictionaryValue*/

  set_t_ref(tmp_t_ref);

  /* generated by template
   * org.nest.nestml.neuron.function.AssignTmpDictionaryValue*/

  set_E_L(tmp_E_L);

  /* generated by template
   * org.nest.nestml.neuron.function.AssignTmpDictionaryValue*/

  // ignores 'V_reset' double' since it is an function and setter isn't defined

  /* generated by template
   * org.nest.nestml.neuron.function.AssignTmpDictionaryValue*/

  // ignores 'Theta' double' since it is an function and setter isn't defined

  /* generated by template
   * org.nest.nestml.neuron.function.AssignTmpDictionaryValue*/

  set_I_e(tmp_I_e);

  /* generated by template
   * org.nest.nestml.neuron.function.AssignTmpDictionaryValue*/

  set_V_abs(tmp_V_abs);

  /* generated by template
   * org.nest.nestml.neuron.function.AssignTmpDictionaryValue*/

  // ignores 'V_m' double' since it is an function and setter isn't defined

  /* generated by template
   * org.nest.nestml.neuron.function.AssignTmpDictionaryValue*/

  set_y1_I_shape_in(tmp_y1_I_shape_in);

  /* generated by template
   * org.nest.nestml.neuron.function.AssignTmpDictionaryValue*/

  set_y2_I_shape_in(tmp_y2_I_shape_in);

  /* generated by template
   * org.nest.nestml.neuron.function.AssignTmpDictionaryValue*/

  set_y1_I_shape_ex(tmp_y1_I_shape_ex);

  /* generated by template
   * org.nest.nestml.neuron.function.AssignTmpDictionaryValue*/

  set_y2_I_shape_ex(tmp_y2_I_shape_ex);
};

#endif /* #ifndef IAF_PSC_ALPHA_NEURON */
